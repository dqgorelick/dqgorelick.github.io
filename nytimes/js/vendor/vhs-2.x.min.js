/*	SWFObject v2.2 <http://code.google.com/p/swfobject/>
	is released under the MIT License <http://www.opensource.org/licenses/mit-license.php>
*/

(function (root, factory) {
    if (typeof define === 'function' && define.amd && typeof require === 'function' && require.version) {
        // AMD. Register as an anonymous module.
        define('swfobject/vhs', factory);
    } else {
        // Browser globals (root is window)
        root.swfobject = factory();
    }
}(this, function () {
    /*! SWFObject v2.2 <http://code.google.com/p/swfobject/>
        is released under the MIT License <http://www.opensource.org/licenses/mit-license.php>
    */

    var swfobject = function() {

        var UNDEF = "undefined",
            OBJECT = "object",
            SHOCKWAVE_FLASH = "Shockwave Flash",
            SHOCKWAVE_FLASH_AX = "ShockwaveFlash.ShockwaveFlash",
            FLASH_MIME_TYPE = "application/x-shockwave-flash",
            EXPRESS_INSTALL_ID = "SWFObjectExprInst",
            ON_READY_STATE_CHANGE = "onreadystatechange",

            win = window,
            doc = document,
            nav = navigator,

            plugin = false,
            domLoadFnArr = [main],
            regObjArr = [],
            objIdArr = [],
            listenersArr = [],
            storedAltContent,
            storedAltContentId,
            storedCallbackFn,
            storedCallbackObj,
            isDomLoaded = false,
            isExpressInstallActive = false,
            dynamicStylesheet,
            dynamicStylesheetMedia,
            autoHideShow = true,

        /* Centralized function for browser feature detection
            - User agent string detection is only used when no good alternative is possible
            - Is executed directly for optimal performance
        */
        ua = function() {
            var w3cdom = typeof doc.getElementById != UNDEF && typeof doc.getElementsByTagName != UNDEF && typeof doc.createElement != UNDEF,
                u = nav.userAgent.toLowerCase(),
                p = nav.platform.toLowerCase(),
                windows = p ? /win/.test(p) : /win/.test(u),
                mac = p ? /mac/.test(p) : /mac/.test(u),
                webkit = /webkit/.test(u) ? parseFloat(u.replace(/^.*webkit\/(\d+(\.\d+)?).*$/, "$1")) : false, // returns either the webkit version or false if not webkit
                ie = !+"\v1", // feature detection based on Andrea Giammarchi's solution: http://webreflection.blogspot.com/2009/01/32-bytes-to-know-if-your-browser-is-ie.html
                playerVersion = [0,0,0],
                d = null;
            if (typeof nav.plugins != UNDEF && typeof nav.plugins[SHOCKWAVE_FLASH] == OBJECT) {
                d = nav.plugins[SHOCKWAVE_FLASH].description;
                if (d && !(typeof nav.mimeTypes != UNDEF && nav.mimeTypes[FLASH_MIME_TYPE] && !nav.mimeTypes[FLASH_MIME_TYPE].enabledPlugin)) { // navigator.mimeTypes["application/x-shockwave-flash"].enabledPlugin indicates whether plug-ins are enabled or disabled in Safari 3+
                    plugin = true;
                    ie = false; // cascaded feature detection for Internet Explorer
                    d = d.replace(/^.*\s+(\S+\s+\S+$)/, "$1");
                    playerVersion[0] = parseInt(d.replace(/^(.*)\..*$/, "$1"), 10);
                    playerVersion[1] = parseInt(d.replace(/^.*\.(.*)\s.*$/, "$1"), 10);
                    playerVersion[2] = /[a-zA-Z]/.test(d) ? parseInt(d.replace(/^.*[a-zA-Z]+(.*)$/, "$1"), 10) : 0;
                }
            }
            else if (typeof win.ActiveXObject != UNDEF) {
                try {
                    var a = new ActiveXObject(SHOCKWAVE_FLASH_AX);
                    if (a) { // a will return null when ActiveX is disabled
                        d = a.GetVariable("$version");
                        if (d) {
                            ie = true; // cascaded feature detection for Internet Explorer
                            d = d.split(" ")[1].split(",");
                            playerVersion = [parseInt(d[0], 10), parseInt(d[1], 10), parseInt(d[2], 10)];
                        }
                    }
                }
                catch(e) {}
            }
            return { w3:w3cdom, pv:playerVersion, wk:webkit, ie:ie, win:windows, mac:mac };
        }(),

        /* Cross-browser onDomLoad
            - Will fire an event as soon as the DOM of a web page is loaded
            - Internet Explorer workaround based on Diego Perini's solution: http://javascript.nwbox.com/IEContentLoaded/
            - Regular onload serves as fallback
        */
        onDomLoad = function() {
            if (!ua.w3) { return; }
            if ((typeof doc.readyState != UNDEF && doc.readyState == "complete") || (typeof doc.readyState == UNDEF && (doc.getElementsByTagName("body")[0] || doc.body))) { // function is fired after onload, e.g. when script is inserted dynamically
                callDomLoadFunctions();
            }
            if (!isDomLoaded) {
                if (typeof doc.addEventListener != UNDEF) {
                    doc.addEventListener("DOMContentLoaded", callDomLoadFunctions, false);
                }
                if (ua.ie && ua.win) {
                    doc.attachEvent(ON_READY_STATE_CHANGE, function() {
                        if (doc.readyState == "complete") {
                            doc.detachEvent(ON_READY_STATE_CHANGE, arguments.callee);
                            callDomLoadFunctions();
                        }
                    });
                    if (win == top) { // if not inside an iframe
                        (function(){
                            if (isDomLoaded) { return; }
                            try {
                                doc.documentElement.doScroll("left");
                            }
                            catch(e) {
                                setTimeout(arguments.callee, 0);
                                return;
                            }
                            callDomLoadFunctions();
                        })();
                    }
                }
                if (ua.wk) {
                    (function(){
                        if (isDomLoaded) { return; }
                        if (!/loaded|complete/.test(doc.readyState)) {
                            setTimeout(arguments.callee, 0);
                            return;
                        }
                        callDomLoadFunctions();
                    })();
                }
                addLoadEvent(callDomLoadFunctions);
            }
        }();

        function callDomLoadFunctions() {
            if (isDomLoaded) { return; }
            try { // test if we can really add/remove elements to/from the DOM; we don't want to fire it too early
                var t = doc.getElementsByTagName("body")[0].appendChild(createElement("span"));
                t.parentNode.removeChild(t);
            }
            catch (e) { return; }
            isDomLoaded = true;
            var dl = domLoadFnArr.length;
            for (var i = 0; i < dl; i++) {
                domLoadFnArr[i]();
            }
        }

        function addDomLoadEvent(fn) {
            if (isDomLoaded) {
                fn();
            }
            else {
                domLoadFnArr[domLoadFnArr.length] = fn; // Array.push() is only available in IE5.5+
            }
        }

        /* Cross-browser onload
            - Based on James Edwards' solution: http://brothercake.com/site/resources/scripts/onload/
            - Will fire an event as soon as a web page including all of its assets are loaded
         */
        function addLoadEvent(fn) {
            if (typeof win.addEventListener != UNDEF) {
                win.addEventListener("load", fn, false);
            }
            else if (typeof doc.addEventListener != UNDEF) {
                doc.addEventListener("load", fn, false);
            }
            else if (typeof win.attachEvent != UNDEF) {
                addListener(win, "onload", fn);
            }
            else if (typeof win.onload == "function") {
                var fnOld = win.onload;
                win.onload = function() {
                    fnOld();
                    fn();
                };
            }
            else {
                win.onload = fn;
            }
        }

        /* Main function
            - Will preferably execute onDomLoad, otherwise onload (as a fallback)
        */
        function main() {
            if (plugin) {
                testPlayerVersion();
            }
            else {
                matchVersions();
            }
        }

        /* Detect the Flash Player version for non-Internet Explorer browsers
            - Detecting the plug-in version via the object element is more precise than using the plugins collection item's description:
              a. Both release and build numbers can be detected
              b. Avoid wrong descriptions by corrupt installers provided by Adobe
              c. Avoid wrong descriptions by multiple Flash Player entries in the plugin Array, caused by incorrect browser imports
            - Disadvantage of this method is that it depends on the availability of the DOM, while the plugins collection is immediately available
        */
        function testPlayerVersion() {
            var b = doc.getElementsByTagName("body")[0];
            var o = createElement(OBJECT);
            o.setAttribute("type", FLASH_MIME_TYPE);
            var t = b.appendChild(o);
            if (t) {
                var counter = 0;
                (function(){
                    if (typeof t.GetVariable != UNDEF) {
                        var d = t.GetVariable("$version");
                        if (d) {
                            d = d.split(" ")[1].split(",");
                            ua.pv = [parseInt(d[0], 10), parseInt(d[1], 10), parseInt(d[2], 10)];
                        }
                    }
                    else if (counter < 10) {
                        counter++;
                        setTimeout(arguments.callee, 10);
                        return;
                    }
                    b.removeChild(o);
                    t = null;
                    matchVersions();
                })();
            }
            else {
                matchVersions();
            }
        }

        /* Perform Flash Player and SWF version matching; static publishing only
        */
        function matchVersions() {
            var rl = regObjArr.length;
            if (rl > 0) {
                for (var i = 0; i < rl; i++) { // for each registered object element
                    var id = regObjArr[i].id;
                    var cb = regObjArr[i].callbackFn;
                    var cbObj = {success:false, id:id};
                    if (ua.pv[0] > 0) {
                        var obj = getElementById(id);
                        if (obj) {
                            if (hasPlayerVersion(regObjArr[i].swfVersion) && !(ua.wk && ua.wk < 312)) { // Flash Player version >= published SWF version: Houston, we have a match!
                                setVisibility(id, true);
                                if (cb) {
                                    cbObj.success = true;
                                    cbObj.ref = getObjectById(id);
                                    cb(cbObj);
                                }
                            }
                            else if (regObjArr[i].expressInstall && canExpressInstall()) { // show the Adobe Express Install dialog if set by the web page author and if supported
                                var att = {};
                                att.data = regObjArr[i].expressInstall;
                                att.width = obj.getAttribute("width") || "0";
                                att.height = obj.getAttribute("height") || "0";
                                if (obj.getAttribute("class")) { att.styleclass = obj.getAttribute("class"); }
                                if (obj.getAttribute("align")) { att.align = obj.getAttribute("align"); }
                                // parse HTML object param element's name-value pairs
                                var par = {};
                                var p = obj.getElementsByTagName("param");
                                var pl = p.length;
                                for (var j = 0; j < pl; j++) {
                                    if (p[j].getAttribute("name").toLowerCase() != "movie") {
                                        par[p[j].getAttribute("name")] = p[j].getAttribute("value");
                                    }
                                }
                                showExpressInstall(att, par, id, cb);
                            }
                            else { // Flash Player and SWF version mismatch or an older Webkit engine that ignores the HTML object element's nested param elements: display alternative content instead of SWF
                                displayAltContent(obj);
                                if (cb) { cb(cbObj); }
                            }
                        }
                    }
                    else {  // if no Flash Player is installed or the fp version cannot be detected we let the HTML object element do its job (either show a SWF or alternative content)
                        setVisibility(id, true);
                        if (cb) {
                            var o = getObjectById(id); // test whether there is an HTML object element or not
                            if (o && typeof o.SetVariable != UNDEF) {
                                cbObj.success = true;
                                cbObj.ref = o;
                            }
                            cb(cbObj);
                        }
                    }
                }
            }
        }

        function getObjectById(objectIdStr) {
            var r = null;
            var o = getElementById(objectIdStr);
            if (o && o.nodeName == "OBJECT") {
                if (typeof o.SetVariable != UNDEF) {
                    r = o;
                }
                else {
                    var n = o.getElementsByTagName(OBJECT)[0];
                    if (n) {
                        r = n;
                    }
                }
            }
            return r;
        }

        /* Requirements for Adobe Express Install
            - only one instance can be active at a time
            - fp 6.0.65 or higher
            - Win/Mac OS only
            - no Webkit engines older than version 312
        */
        function canExpressInstall() {
            return !isExpressInstallActive && hasPlayerVersion("6.0.65") && (ua.win || ua.mac) && !(ua.wk && ua.wk < 312);
        }

        /* Show the Adobe Express Install dialog
            - Reference: http://www.adobe.com/cfusion/knowledgebase/index.cfm?id=6a253b75
        */
        function showExpressInstall(att, par, replaceElemIdStr, callbackFn) {
            isExpressInstallActive = true;
            storedCallbackFn = callbackFn || null;
            storedCallbackObj = {success:false, id:replaceElemIdStr};
            var obj = getElementById(replaceElemIdStr);
            if (obj) {
                if (obj.nodeName == "OBJECT") { // static publishing
                    storedAltContent = abstractAltContent(obj);
                    storedAltContentId = null;
                }
                else { // dynamic publishing
                    storedAltContent = obj;
                    storedAltContentId = replaceElemIdStr;
                }
                att.id = EXPRESS_INSTALL_ID;
                if (typeof att.width == UNDEF || (!/%$/.test(att.width) && parseInt(att.width, 10) < 310)) { att.width = "310"; }
                if (typeof att.height == UNDEF || (!/%$/.test(att.height) && parseInt(att.height, 10) < 137)) { att.height = "137"; }
                doc.title = doc.title.slice(0, 47) + " - Flash Player Installation";
                var pt = ua.ie && ua.win ? "ActiveX" : "PlugIn",
                    fv = "MMredirectURL=" + win.location.toString().replace(/&/g,"%26") + "&MMplayerType=" + pt + "&MMdoctitle=" + doc.title;
                if (typeof par.flashvars != UNDEF) {
                    par.flashvars += "&" + fv;
                }
                else {
                    par.flashvars = fv;
                }
                // IE only: when a SWF is loading (AND: not available in cache) wait for the readyState of the object element to become 4 before removing it,
                // because you cannot properly cancel a loading SWF file without breaking browser load references, also obj.onreadystatechange doesn't work
                if (ua.ie && ua.win && obj.readyState != 4) {
                    var newObj = createElement("div");
                    replaceElemIdStr += "SWFObjectNew";
                    newObj.setAttribute("id", replaceElemIdStr);
                    obj.parentNode.insertBefore(newObj, obj); // insert placeholder div that will be replaced by the object element that loads expressinstall.swf
                    obj.style.display = "none";
                    (function(){
                        if (obj.readyState == 4) {
                            obj.parentNode.removeChild(obj);
                        }
                        else {
                            setTimeout(arguments.callee, 10);
                        }
                    })();
                }
                createSWF(att, par, replaceElemIdStr);
            }
        }

        /* Functions to abstract and display alternative content
        */
        function displayAltContent(obj) {
            if (ua.ie && ua.win && obj.readyState != 4) {
                // IE only: when a SWF is loading (AND: not available in cache) wait for the readyState of the object element to become 4 before removing it,
                // because you cannot properly cancel a loading SWF file without breaking browser load references, also obj.onreadystatechange doesn't work
                var el = createElement("div");
                obj.parentNode.insertBefore(el, obj); // insert placeholder div that will be replaced by the alternative content
                el.parentNode.replaceChild(abstractAltContent(obj), el);
                obj.style.display = "none";
                (function(){
                    if (obj.readyState == 4) {
                        obj.parentNode.removeChild(obj);
                    }
                    else {
                        setTimeout(arguments.callee, 10);
                    }
                })();
            }
            else {
                obj.parentNode.replaceChild(abstractAltContent(obj), obj);
            }
        }

        function abstractAltContent(obj) {
            var ac = createElement("div");
            if (ua.win && ua.ie) {
                ac.innerHTML = obj.innerHTML;
            }
            else {
                var nestedObj = obj.getElementsByTagName(OBJECT)[0];
                if (nestedObj) {
                    var c = nestedObj.childNodes;
                    if (c) {
                        var cl = c.length;
                        for (var i = 0; i < cl; i++) {
                            if (!(c[i].nodeType == 1 && c[i].nodeName == "PARAM") && !(c[i].nodeType == 8)) {
                                ac.appendChild(c[i].cloneNode(true));
                            }
                        }
                    }
                }
            }
            return ac;
        }

        /* Cross-browser dynamic SWF creation
        */
        function createSWF(attObj, parObj, id) {
            var r, el = getElementById(id);
            if (ua.wk && ua.wk < 312) { return r; }
            if (el) {
                if (typeof attObj.id == UNDEF) { // if no 'id' is defined for the object element, it will inherit the 'id' from the alternative content
                    attObj.id = id;
                }
                if (ua.ie && ua.win) { // Internet Explorer + the HTML object element + W3C DOM methods do not combine: fall back to outerHTML
                    var att = "";
                    for (var i in attObj) {
                        if (attObj[i] != Object.prototype[i]) { // filter out prototype additions from other potential libraries
                            if (i.toLowerCase() == "data") {
                                parObj.movie = attObj[i];
                            }
                            else if (i.toLowerCase() == "styleclass") { // 'class' is an ECMA4 reserved keyword
                                att += ' class="' + attObj[i] + '"';
                            }
                            else if (i.toLowerCase() != "classid") {
                                att += ' ' + i + '="' + attObj[i] + '"';
                            }
                        }
                    }
                    var par = "";
                    for (var j in parObj) {
                        if (parObj[j] != Object.prototype[j]) { // filter out prototype additions from other potential libraries
                            par += '<param name="' + j + '" value="' + parObj[j] + '" />';
                        }
                    }
                    el.outerHTML = '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"' + att + '>' + par + '</object>';
                    objIdArr[objIdArr.length] = attObj.id; // stored to fix object 'leaks' on unload (dynamic publishing only)
                    r = getElementById(attObj.id);
                }
                else { // well-behaving browsers
                    var o = createElement(OBJECT);
                    o.setAttribute("type", FLASH_MIME_TYPE);
                    for (var m in attObj) {
                        if (attObj[m] != Object.prototype[m]) { // filter out prototype additions from other potential libraries
                            if (m.toLowerCase() == "styleclass") { // 'class' is an ECMA4 reserved keyword
                                o.setAttribute("class", attObj[m]);
                            }
                            else if (m.toLowerCase() != "classid") { // filter out IE specific attribute
                                o.setAttribute(m, attObj[m]);
                            }
                        }
                    }
                    for (var n in parObj) {
                        if (parObj[n] != Object.prototype[n] && n.toLowerCase() != "movie") { // filter out prototype additions from other potential libraries and IE specific param element
                            createObjParam(o, n, parObj[n]);
                        }
                    }
                    el.parentNode.replaceChild(o, el);
                    r = o;
                }
            }
            return r;
        }

        function createObjParam(el, pName, pValue) {
            var p = createElement("param");
            p.setAttribute("name", pName);
            p.setAttribute("value", pValue);
            el.appendChild(p);
        }

        /* Cross-browser SWF removal
            - Especially needed to safely and completely remove a SWF in Internet Explorer
        */
        function removeSWF(id) {
            var obj = getElementById(id);
            if (obj && obj.nodeName == "OBJECT") {
                if (ua.ie && ua.win) {
                    obj.style.display = "none";
                    (function(){
                        if (obj.readyState == 4) {
                            removeObjectInIE(id);
                        }
                        else {
                            setTimeout(arguments.callee, 10);
                        }
                    })();
                }
                else {
                    obj.parentNode.removeChild(obj);
                }
            }
        }

        function removeObjectInIE(id) {
            var obj = getElementById(id);
            if (obj) {
                for (var i in obj) {
                    if (typeof obj[i] == "function") {
                        obj[i] = null;
                    }
                }
                obj.parentNode.removeChild(obj);
            }
        }

        /* Functions to optimize JavaScript compression
        */
        function getElementById(id) {
            var el = null;
            try {
                el = doc.getElementById(id);
            }
            catch (e) {}
            return el;
        }

        function createElement(el) {
            return doc.createElement(el);
        }

        /* Updated attachEvent function for Internet Explorer
            - Stores attachEvent information in an Array, so on unload the detachEvent functions can be called to avoid memory leaks
        */
        function addListener(target, eventType, fn) {
            target.attachEvent(eventType, fn);
            listenersArr[listenersArr.length] = [target, eventType, fn];
        }

        /* Flash Player and SWF content version matching
        */
        function hasPlayerVersion(rv) {
            var pv = ua.pv, v = rv.split(".");
            v[0] = parseInt(v[0], 10);
            v[1] = parseInt(v[1], 10) || 0; // supports short notation, e.g. "9" instead of "9.0.0"
            v[2] = parseInt(v[2], 10) || 0;
            return (pv[0] > v[0] || (pv[0] == v[0] && pv[1] > v[1]) || (pv[0] == v[0] && pv[1] == v[1] && pv[2] >= v[2])) ? true : false;
        }

        /* Cross-browser dynamic CSS creation
            - Based on Bobby van der Sluis' solution: http://www.bobbyvandersluis.com/articles/dynamicCSS.php
        */
        function createCSS(sel, decl, media, newStyle) {
            if (ua.ie && ua.mac) { return; }
            var h = doc.getElementsByTagName("head")[0];
            if (!h) { return; } // to also support badly authored HTML pages that lack a head element
            var m = (media && typeof media == "string") ? media : "screen";
            if (newStyle) {
                dynamicStylesheet = null;
                dynamicStylesheetMedia = null;
            }
            if (!dynamicStylesheet || dynamicStylesheetMedia != m) {
                // create dynamic stylesheet + get a global reference to it
                var s = createElement("style");
                s.setAttribute("type", "text/css");
                s.setAttribute("media", m);
                dynamicStylesheet = h.appendChild(s);
                if (ua.ie && ua.win && typeof doc.styleSheets != UNDEF && doc.styleSheets.length > 0) {
                    dynamicStylesheet = doc.styleSheets[doc.styleSheets.length - 1];
                }
                dynamicStylesheetMedia = m;
            }
            // add style rule
            if (ua.ie && ua.win) {
                if (dynamicStylesheet && typeof dynamicStylesheet.addRule == OBJECT) {
                    dynamicStylesheet.addRule(sel, decl);
                }
            }
            else {
                if (dynamicStylesheet && typeof doc.createTextNode != UNDEF) {
                    dynamicStylesheet.appendChild(doc.createTextNode(sel + " {" + decl + "}"));
                }
            }
        }

        function setVisibility(id, isVisible) {
            if (!autoHideShow) { return; }
            var v = isVisible ? "visible" : "hidden";
            if (isDomLoaded && getElementById(id)) {
                getElementById(id).style.visibility = v;
            }
            else {
                createCSS("#" + id, "visibility:" + v);
            }
        }

        /* Filter to avoid XSS attacks
        */
        function urlEncodeIfNecessary(s) {
            var regex = /[\\\"<>\.;]/;
            var hasBadChars = regex.exec(s) != null;
            return hasBadChars && typeof encodeURIComponent != UNDEF ? encodeURIComponent(s) : s;
        }

        /* Release memory to avoid memory leaks caused by closures, fix hanging audio/video threads and force open sockets/NetConnections to disconnect (Internet Explorer only)
        */
        var cleanup = function() {
            if (ua.ie && ua.win) {
                window.attachEvent("onunload", function() {
                    // remove listeners to avoid memory leaks
                    var ll = listenersArr.length;
                    for (var i = 0; i < ll; i++) {
                        listenersArr[i][0].detachEvent(listenersArr[i][1], listenersArr[i][2]);
                    }
                    // cleanup dynamically embedded objects to fix audio/video threads and force open sockets and NetConnections to disconnect
                    var il = objIdArr.length;
                    for (var j = 0; j < il; j++) {
                        removeSWF(objIdArr[j]);
                    }
                    // cleanup library's main closures to avoid memory leaks
                    for (var k in ua) {
                        ua[k] = null;
                    }
                    ua = null;
                    for (var l in swfobject) {
                        swfobject[l] = null;
                    }
                    swfobject = null;
                });
            }
        }();

        return {
            /* Public API
                - Reference: http://code.google.com/p/swfobject/wiki/documentation
            */
            registerObject: function(objectIdStr, swfVersionStr, xiSwfUrlStr, callbackFn) {
                if (ua.w3 && objectIdStr && swfVersionStr) {
                    var regObj = {};
                    regObj.id = objectIdStr;
                    regObj.swfVersion = swfVersionStr;
                    regObj.expressInstall = xiSwfUrlStr;
                    regObj.callbackFn = callbackFn;
                    regObjArr[regObjArr.length] = regObj;
                    setVisibility(objectIdStr, false);
                }
                else if (callbackFn) {
                    callbackFn({success:false, id:objectIdStr});
                }
            },

            getObjectById: function(objectIdStr) {
                if (ua.w3) {
                    return getObjectById(objectIdStr);
                }
            },

            embedSWF: function(swfUrlStr, replaceElemIdStr, widthStr, heightStr, swfVersionStr, xiSwfUrlStr, flashvarsObj, parObj, attObj, callbackFn, overrideDomReady) {
                var callbackObj = {success:false, id:replaceElemIdStr};
                if (ua.w3 && !(ua.wk && ua.wk < 312) && swfUrlStr && replaceElemIdStr && widthStr && heightStr && swfVersionStr) {
                    if (overrideDomReady) {
                        isDomLoaded = true;
                    }
                    setVisibility(replaceElemIdStr, false);
                    addDomLoadEvent(function() {
                        widthStr += ""; // auto-convert to string
                        heightStr += "";
                        var att = {};
                        if (attObj && typeof attObj === OBJECT) {
                            for (var i in attObj) { // copy object to avoid the use of references, because web authors often reuse attObj for multiple SWFs
                                att[i] = attObj[i];
                            }
                        }
                        att.data = swfUrlStr;
                        att.width = widthStr;
                        att.height = heightStr;
                        var par = {};
                        if (parObj && typeof parObj === OBJECT) {
                            for (var j in parObj) { // copy object to avoid the use of references, because web authors often reuse parObj for multiple SWFs
                                par[j] = parObj[j];
                            }
                        }
                        if (flashvarsObj && typeof flashvarsObj === OBJECT) {
                            for (var k in flashvarsObj) { // copy object to avoid the use of references, because web authors often reuse flashvarsObj for multiple SWFs
                                if (typeof par.flashvars != UNDEF) {
                                    par.flashvars += "&" + k + "=" + flashvarsObj[k];
                                }
                                else {
                                    par.flashvars = k + "=" + flashvarsObj[k];
                                }
                            }
                        }
                        if (hasPlayerVersion(swfVersionStr)) { // create SWF
                            var obj = createSWF(att, par, replaceElemIdStr);
                            if (att.id == replaceElemIdStr) {
                                setVisibility(replaceElemIdStr, true);
                            }
                            callbackObj.success = true;
                            callbackObj.ref = obj;
                        }
                        else if (xiSwfUrlStr && canExpressInstall()) { // show Adobe Express Install
                            att.data = xiSwfUrlStr;
                            showExpressInstall(att, par, replaceElemIdStr, callbackFn);
                            return;
                        }
                        else { // show alternative content
                            setVisibility(replaceElemIdStr, true);
                        }
                        if (callbackFn) { callbackFn(callbackObj); }
                    });
                }
                else if (callbackFn) { callbackFn(callbackObj); }
            },

            switchOffAutoHideShow: function() {
                autoHideShow = false;
            },

            ua: ua,

            getFlashPlayerVersion: function() {
                return { major:ua.pv[0], minor:ua.pv[1], release:ua.pv[2] };
            },

            hasFlashPlayerVersion: hasPlayerVersion,

            createSWF: function(attObj, parObj, replaceElemIdStr) {
                if (ua.w3) {
                    return createSWF(attObj, parObj, replaceElemIdStr);
                }
                else {
                    return undefined;
                }
            },

            showExpressInstall: function(att, par, replaceElemIdStr, callbackFn) {
                if (ua.w3 && canExpressInstall()) {
                    showExpressInstall(att, par, replaceElemIdStr, callbackFn);
                }
            },

            removeSWF: function(objElemIdStr) {
                if (ua.w3) {
                    removeSWF(objElemIdStr);
                }
            },

            createCSS: function(selStr, declStr, mediaStr, newStyleBoolean) {
                if (ua.w3) {
                    createCSS(selStr, declStr, mediaStr, newStyleBoolean);
                }
            },

            addDomLoadEvent: addDomLoadEvent,

            addLoadEvent: addLoadEvent,

            getQueryParamValue: function(param) {
                var q = doc.location.search || doc.location.hash;
                if (q) {
                    if (/\?/.test(q)) { q = q.split("?")[1]; } // strip question mark
                    if (param == null) {
                        return urlEncodeIfNecessary(q);
                    }
                    var pairs = q.split("&");
                    for (var i = 0; i < pairs.length; i++) {
                        if (pairs[i].substring(0, pairs[i].indexOf("=")) == param) {
                            return urlEncodeIfNecessary(pairs[i].substring((pairs[i].indexOf("=") + 1)));
                        }
                    }
                }
                return "";
            },

            // For internal usage only
            expressInstallCallback: function() {
                if (isExpressInstallActive) {
                    var obj = getElementById(EXPRESS_INSTALL_ID);
                    if (obj && storedAltContent) {
                        obj.parentNode.replaceChild(storedAltContent, obj);
                        if (storedAltContentId) {
                            setVisibility(storedAltContentId, true);
                            if (ua.ie && ua.win) { storedAltContent.style.display = "block"; }
                        }
                        if (storedCallbackFn) { storedCallbackFn(storedCallbackObj); }
                    }
                    isExpressInstallActive = false;
                }
            }
        };
    }();

    return swfobject;
}));
/*!
 * Cookies.js - 0.4.0
 *
 * Copyright (c) 2014, Scott Hamper
 * Licensed under the MIT license,
 * http://www.opensource.org/licenses/MIT
 */
(function (undefined) {
    'use strict';

    var Cookies = function (key, value, options) {
        return arguments.length === 1 ?
            Cookies.get(key) : Cookies.set(key, value, options);
    };

    // Allows for setter injection in unit tests
    Cookies._document = document;
    Cookies._navigator = navigator;

    Cookies.defaults = {
        path: '/'
    };

    Cookies.get = function (key) {
        if (Cookies._cachedDocumentCookie !== Cookies._document.cookie) {
            Cookies._renewCache();
        }

        return Cookies._cache[key];
    };

    Cookies.set = function (key, value, options) {
        options = Cookies._getExtendedOptions(options);
        options.expires = Cookies._getExpiresDate(value === undefined ? -1 : options.expires);

        Cookies._document.cookie = Cookies._generateCookieString(key, value, options);

        return Cookies;
    };

    Cookies.expire = function (key, options) {
        return Cookies.set(key, undefined, options);
    };

    Cookies._getExtendedOptions = function (options) {
        return {
            path: options && options.path || Cookies.defaults.path,
            domain: options && options.domain || Cookies.defaults.domain,
            expires: options && options.expires || Cookies.defaults.expires,
            secure: options && options.secure !== undefined ?  options.secure : Cookies.defaults.secure
        };
    };

    Cookies._isValidDate = function (date) {
        return Object.prototype.toString.call(date) === '[object Date]' && !isNaN(date.getTime());
    };

    Cookies._getExpiresDate = function (expires, now) {
        now = now || new Date();
        switch (typeof expires) {
            case 'number': expires = new Date(now.getTime() + expires * 1000); break;
            case 'string': expires = new Date(expires); break;
        }

        if (expires && !Cookies._isValidDate(expires)) {
            throw new Error('`expires` parameter cannot be converted to a valid Date instance');
        }

        return expires;
    };

    Cookies._generateCookieString = function (key, value, options) {
        key = key.replace(/[^#$&+\^`|]/g, encodeURIComponent);
        key = key.replace(/\(/g, '%28').replace(/\)/g, '%29');
        value = (value + '').replace(/[^!#$&-+\--:<-\[\]-~]/g, encodeURIComponent);
        options = options || {};

        var cookieString = key + '=' + value;
        cookieString += options.path ? ';path=' + options.path : '';
        cookieString += options.domain ? ';domain=' + options.domain : '';
        cookieString += options.expires ? ';expires=' + options.expires.toUTCString() : '';
        cookieString += options.secure ? ';secure' : '';

        return cookieString;
    };

    Cookies._getCookieObjectFromString = function (documentCookie) {
        var cookieObject = {};
        var cookiesArray = documentCookie ? documentCookie.split('; ') : [];

        for (var i = 0; i < cookiesArray.length; i++) {
            var cookieKvp = Cookies._getKeyValuePairFromCookieString(cookiesArray[i]);

            if (cookieObject[cookieKvp.key] === undefined) {
                cookieObject[cookieKvp.key] = cookieKvp.value;
            }
        }

        return cookieObject;
    };

    Cookies._getKeyValuePairFromCookieString = function (cookieString) {
        // "=" is a valid character in a cookie value according to RFC6265, so cannot `split('=')`
        var separatorIndex = cookieString.indexOf('=');

        // IE omits the "=" when the cookie value is an empty string
        separatorIndex = separatorIndex < 0 ? cookieString.length : separatorIndex;

        return {
            key: decodeURIComponent(cookieString.substr(0, separatorIndex)),
            value: decodeURIComponent(cookieString.substr(separatorIndex + 1))
        };
    };

    Cookies._renewCache = function () {
        Cookies._cache = Cookies._getCookieObjectFromString(Cookies._document.cookie);
        Cookies._cachedDocumentCookie = Cookies._document.cookie;
    };

    Cookies._areEnabled = function () {
        var testKey = 'cookies.js';
        var areEnabled = Cookies.set(testKey, 1).get(testKey) === '1';
        Cookies.expire(testKey);
        return areEnabled;
    };

    Cookies.enabled = Cookies._areEnabled();

    // AMD support
    if (typeof define === 'function' && define.amd && typeof require === 'function' && require.version) {
        define('cookies/vhs', function () { return Cookies; });
    // CommonJS and Node.js module support.
    } else if (typeof exports !== 'undefined') {
        // Support Node.js specific `module.exports` (which can be a function)
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = Cookies;
        }
        // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
        exports.Cookies = Cookies;
    } else {
        window.Cookies = Cookies;
    }
})();

(function(root, factory) {
    if(typeof exports === 'object') {
        module.exports = factory(require('jQuery'), require('swfobject'), require('Cookies'));
    }
    else if(typeof define === 'function' && define.amd && typeof require === 'function' && require.version) {
        define('vhs', ['jquery/nyt', 'swfobject/vhs', 'cookies/vhs'], factory);
    }
    else {
        root.VHS = factory(root.jQuery, root.swfobject, root.Cookies);
    }
}(this, function(jQuery, swfobject, Cookies) {
"use strict"; var $ = jQuery; if (typeof $ === "undefined") { throw new Error("VHS requires jQuery"); };/**
@module VHS
**/
var VHS = function(selector){
    return {
        ready: function(callback){
            var instance;
            var containers = $(selector);
            var ready;

            containers.one('vhs:ready', function(e, player){
                callback(player);
            });

            containers.each(function(i, el){
                var containerElement = $(el);
                ready = containerElement.data('ready');

                if (ready) {
                    instance = VHS.findInstance(containerElement);
                    containerElement.trigger('vhs:ready', instance);
                }
            });
        },
        loaded: function(callback){
            var instance;
            var containers = $(selector);
            var loaded;

            containers.one('vhs:loaded', function(e, player){
                callback(player);
            });

            containers.each(function(i, el){
                var containerElement = $(el);
                loaded = containerElement.data('loaded');

                if (loaded) {
                    instance = VHS.findInstance(containerElement);
                    containerElement.trigger('vhs:loaded', instance);
                }
            });
        }
    };
};

VHS.config = {
    allowMultiplePlayers: false
};

VHS.api = VHS.api || {};
VHS.html = VHS.html || {};
VHS.configs = VHS.configs || {};

(function(VHS){ this.VHS = VHS;var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;',
  '`': '&#96;'
};

var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
    reUnescapedHtml = /[&<>"'`]/g;

function escapeHtmlChar(chr) {
  return htmlEscapes[chr];
}

function escape(string) {
  // reset `lastIndex` because in IE < 9 `String#replace` does not
  string = (string == null) ? '' : String(string);
  return string && (reUnescapedHtml.lastIndex = 0, reUnescapedHtml.test(string))
    ? string.replace(reUnescapedHtml, escapeHtmlChar)
    : string;
}

var _ = window._ || {};
_.escape = _.escape || escape;

/*
  Copyright 2012-2014 The Dojo Foundation <http://dojofoundation.org/>
  Based on Underscore.js 1.6.0, copyright 2009-2014 Jeremy Ashkenas,
  DocumentCloud and Investigative Reporters & Editors <http://underscorejs.org/>

  Permission is hereby granted, free of charge, to any person obtaining
  a copy of this software and associated documentation files (the
  "Software"), to deal in the Software without restriction, including
  without limitation the rights to use, copy, modify, merge, publish,
  distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to
  the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

this["VHS"] = this["VHS"] || {};
this["VHS"]["templates"] = this["VHS"]["templates"] || {};

this["VHS"]["templates"]["cover"] = function(options) {
var __t, __p = '', __e = _.escape, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
__p += '<div class="vhs-player-cover-background vhs-' +
((__t = ( options.mode )) == null ? '' : __t) +
'-cover"></div>\n';
 if (options.mode === 'mobile') { ;
__p += '\n    <i class="vhs-icon-play vhs-cover-play-button vhs-mobile-play-button"></i>\n';
 } ;
__p += '\n<div class="vhs-media-action-overlay vhs-' +
((__t = ( options.mode )) == null ? '' : __t) +
'-cover">\n    <i class="vhs-icon-play vhs-cover-play-button"></i>\n\n    ';
 if (options.mode !== 'clean') { ;
__p += '\n    <div class="vhs-metadata-container">\n\n        ';
 if (options.mode === 'duration') { ;
__p += '\n            <section class="vhs-metadata">\n                <span class="vhs-video-cta">Play Video</span>\n                <span class="vhs-video-length">' +
((__t = ( options.data.duration )) == null ? '' : __t) +
'</span>\n            </section>\n        ';
 } else if (options.mode === 'article' || options.mode === 'offsite' || options.mode === 'mobile') { ;
__p += '\n            <section class="vhs-metadata">\n                ';
 if (options.mode !== 'mobile') { ;
__p += '\n                    ';
 if (options.data.channelName) { ;
__p += '\n                        <span class="vhs-channel-name">' +
((__t = ( options.data.channelName )) == null ? '' : __t) +
'</span>\n                    ';
 } ;
__p += '\n                    ';
 if (options.data.showName) { ;
__p += '\n                        <span class="vhs-show-name">' +
((__t = ( options.data.showName )) == null ? '' : __t) +
'</span>\n                    ';
 } ;
__p += '\n                ';
 } ;
__p += '\n                ';
 if (options.data.byline) { ;
__p += '\n                    <span class="vhs-byline">' +
((__t = ( options.data.byline )) == null ? '' : __t) +
'</span>\n                ';
 } else { ;
__p += '\n                    <span class="vhs-byline vhs-no-byline"></span>\n                ';
 } ;
__p += '\n                <span class="vhs-video-cta">Play Video</span>\n                <span class="vhs-video-length">' +
((__t = ( options.data.duration )) == null ? '' : __t) +
'</span>\n            </section>\n            <section class="vhs-video-title">\n                <span>' +
((__t = ( options.data.headline )) == null ? '' : __t) +
'</span>\n            </section>\n        ';
 } ;
__p += '\n    </div>\n    ';
 } ;
__p += '\n\n    ';
 if (options.mode === 'offsite') { ;
__p += '\n        <i class="vhs-icon-times-video-logo vhs-embedded-player-cover-logo"></i>\n    ';
 } ;
__p += '\n\n</div>\n';
return __p
};

this["VHS"]["templates"]["endSlate"] = function(options) {
var __t, __p = '', __e = _.escape, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
__p += '<div class="vhs-end-slate-background"></div>\n<div data-id="' +
((__t = ( options.data.id )) == null ? '' : __t) +
'" class="vhs-player-header" data-vhs-et-module="end-slate" data-vhs-et-region="end-slate-header">\n    <div class="vhs-video-title">\n        <a href="http://www.nytimes.com/video" target="_blank" class="vhs-times-logo vhs-icon-times-video-logo vhs-anchor-button" data-vhs-et-name="link-logo"></a>\n        ';
 if (!options.data.byline) { options.titleClasses = 'vhs-no-byline' } ;
__p += '\n        <div class="vhs-video-title-wrapper ' +
((__t = ( options.titleClasses )) == null ? '' : __t) +
'">\n            <p class="vhs-data"> ' +
((__t = ( options.data.headline )) == null ? '' : __t) +
'</p>\n            <span class="vhs-byline"><span>' +
((__t = ( options.data.byline )) == null ? '' : __t) +
'</span></span>\n        </div>\n    </div>\n</div>\n<div class="vhs-end-slate" data-vhs-et-module="end-slate" data-vhs-et-region="end-slate-share">\n    <div class="vhs-social">\n        <button class="vhs-anchor-button vhs-social-icon-wrapper vhs-replay-button" data-vhs-et-name="replay">\n            <h2>Replay</h2>\n            <i class="vhs-icon-replay"></i>\n        </button>\n        ';
 if (!options.url) { ;
__p += '\n        <a class="vhs-anchor-button vhs-social-icon-wrapper" target="_blank" href="' +
((__t = ( options.url || (options.data.domain + options.data.seo_url) )) == null ? '' : __t) +
'" data-vhs-et-name="link-logo">\n            <h2>Times Video</h2>\n            <i class="vhs-anchor-button vhs-icon-times-video-logo"></i>\n        </a>\n        ';
 } ;
__p += '\n        <button class="vhs-anchor-button vhs-share-item vhs-social-icon-wrapper" alt="facebook" data-share-handler="popup" data-share-name="facebook" data-share-url="' +
((__t = ( options.url )) == null ? '' : __t) +
'" data-vhs-et-name="share-facebook">\n            <h2>Share</h2>\n            <i class="vhs-icon-facebook"></i>\n        </button>\n        <button class="vhs-anchor-button vhs-share-item vhs-social-icon-wrapper" alt="twitter" data-share-handler="urlshortener" data-share-name="twitter" data-share-url="' +
((__t = ( options.url )) == null ? '' : __t) +
'" data-vhs-et-name="share-twitter">\n            <h2>Tweet</h2>\n            <i class="vhs-icon-twitter"></i>\n        </button>\n    </div>\n</div>\n';
return __p
};

this["VHS"]["templates"]["pauseSlate"] = function(options) {
var __t, __p = '', __e = _.escape, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
__p += '<div class="vhs-player-header-background"></div>\n<div data-id="' +
((__t = (options.data.id)) == null ? '' : __t) +
'" class="vhs-player-header vhs-pause-slate vhs-top-banner">\n    <div class="vhs-video-title">\n        <a href="http://www.nytimes.com/video" target="_blank" class="vhs-times-logo vhs-icon-times-video-logo vhs-anchor-button ' +
((__t = (options.view.logoClasses)) == null ? '' : __t) +
'"></a>\n        ';
 if (!options.data.byline) { options.view.titleClasses += ' vhs-no-byline' } ;
__p += '\n        <div class="vhs-video-title-wrapper ' +
((__t = (options.view.titleClasses)) == null ? '' : __t) +
'">\n\n            ';
 if (!options.linkUrl || (options.isOnSite && options.isEmbeddedOnly)) { ;
__p += '\n                <p class="vhs-data"> ' +
((__t = (options.data.headline)) == null ? '' : __t) +
' </p>\n            ';
 } else { ;
__p += '\n                <p class="vhs-data"> <a href="' +
((__t = ( options.linkUrl )) == null ? '' : __t) +
'?action=click&amp;gtype=vhs&amp;version=vhs-heading&amp;module=vhs&amp;region=title-area" ';
 if (!options.isOnSite) { ;
__p += ' target="_blank" ';
 } ;
__p += ' > ' +
((__t = (options.data.headline)) == null ? '' : __t) +
' </a> </p>\n            ';
 } ;
__p += '\n\n            <span class="vhs-byline">\n                <span>' +
((__t = (options.data.byline)) == null ? '' : __t) +
'</span>\n            </span>\n        </div>\n    </div>\n    ';
 if (options.showShareTools) { ;
__p += '\n    <div class="vhs-tools ' +
((__t = (options.view.shareClasses)) == null ? '' : __t) +
'" data-vhs-et-module="video-player-share" data-vhs-et-region="playback-share">\n        <div class="vhs-social">\n            <button class="vhs-share-item vhs-icon-facebook" alt="facebook" data-share-handler="popup" data-share-name="facebook" data-share-url="' +
((__t = (options.url)) == null ? '' : __t) +
'" data-vhs-et-name="share-facebook"></button>\n            <button class="vhs-share-item vhs-icon-twitter" alt="twitter" data-share-handler="urlshortener" data-share-name="twitter" data-share-url="' +
((__t = (options.url)) == null ? '' : __t) +
'" data-vhs-et-name="share-twitter"></button>\n        </div>\n        <div class="vhs-embed">\n            <button class="vhs-share-menu vhs-icon-embed" alt="embed" data-vhs-et-name="share-embed"></button>\n        </div>\n    </div>\n    ';
 } ;
__p += '\n</div>\n<div class="vhs-share-module-overlay"></div>\n';
 if (options.showShareTools) { ;
__p += '\n<div class="vhs-share-module" data-vhs-et-module="video-player-share" data-vhs-et-region="playback-extended-share">\n    <div class="vhs-share-module-arrow"></div>\n    <div class="vhs-share-module-inner">\n        <div class="vhs-times-video-link vhs-share-section">\n            <div class="vhs-icon-group">\n                <span>Times Video</span>\n                <a href="http://www.nytimes.com/video" target="_blank" class="vhs-times-logo vhs-icon-times-video-logo vhs-anchor-button"></a>\n            </div>\n        </div>\n        <div class="vhs-share-sidebar">\n            <div class="vhs-social vhs-share-section">\n                <div class="vhs-icon-group">\n                    <span>Share</span>\n                    <button class="vhs-share-item vhs-icon-facebook" alt="facebook" data-share-handler="popup" data-share-name="facebook" data-share-url="' +
((__t = (options.url)) == null ? '' : __t) +
'" data-vhs-et-name="share-facebook"></button>\n                </div>\n                <div class="vhs-icon-group">\n                    <span>Tweet</span>\n                    <button class="vhs-share-item vhs-icon-twitter" alt="twitter" data-share-handler="urlshortener" data-share-name="twitter" data-share-url="' +
((__t = (options.url)) == null ? '' : __t) +
'" data-vhs-et-name="share-twitter"></button>\n                </div>\n            </div>\n            <div class="vhs-embed vhs-share-section">\n                <div class="vhs-icon-group">\n                    <label for="vhs-embed-form">Embed</label>\n                    <button class="vhs-icon-embed" alt="embed"></button>\n                    <div class="vhs-embed-form-container">\n                        ';
 var articleId = (options.data.article_data && options.data.article_data.id) ? '&amp;articleId=' + options.data.article_data.id : ''; ;
__p += '\n                        ';
 var blogpostUrl = (!articleId && options.data.blogpost_data && options.data.blogpost_data.url) ? '&amp;blogPostUrl=' + options.data.blogpost_data.url : ''; ;
__p += '\n                        <input\n                            onClick="this.setSelectionRange(0, this.value.length)"\n                            id="vhs-embed-form"\n                            type="text"\n                            value="<iframe width=&quot;480&quot; height=&quot;373&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; allowfullscreen=&quot;true&quot; marginheight=&quot;0&quot; marginwidth=&quot;0&quot; id=&quot;nyt_video_player&quot; title=&quot;New York Times Video - Embed Player&quot; src=&quot;http://graphics8.nytimes.com/bcvideo/1.0/iframe/embed.html?videoId=' +
((__t = (options.data.id)) == null ? '' : __t) +
'&amp;playerType=embed' +
((__t = (articleId)) == null ? '' : __t) +
'' +
((__t = (blogpostUrl)) == null ? '' : __t) +
'&quot;></iframe>">\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n';
 } ;
__p += '\n\n\n';
return __p
};}).call({}, VHS)
VHS.util = {
    extend: function(proto){
        function F() {}

        if (Object.create) {
            return Object.create(proto);
        } else {
            F.prototype = proto;
            return new F();
        }
    },
    checkFlashSupport: function(){
        var flashVersion =  (typeof swfobject !== "undefined") ? swfobject.getFlashPlayerVersion() : 0;
        return flashVersion && flashVersion.major >= 10;
    },
    checkHtmlSupport: function(){
        var video = document.createElement('video');
        var canvas = document.createElement('canvas').getContext;
        var support = false;

        if (video && canvas) {
            support = true;
        }

        return support;
    },
    supportWebM: function () {
        var webm = 'video/webm; codecs="vp8, vorbis"';

        return this.canPlayType(webm);
    },
    supportH264: function() {
        var codec1 = 'video/mp4; codecs="avc1.42E01E"';
        var codec2 = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"';

        return this.canPlayType(codec1) || this.canPlayType(codec2);
    },
    canPlayType: function (codec) {
        var videoElement = document.createElement('video');

        return typeof videoElement.canPlayType === "function" && videoElement.canPlayType(codec) !== "";
    },
    getDeviceType: function(){
        var device = null;
        var userAgent = navigator.userAgent.toLowerCase();

        var options = [
            ['android_chrome', '(android.*chrome)'],
            ['android_firefox', '(android.*firefox)'],
            ['android_legacy', '(android )(2|3)'],
            ['android_ics', '(android 4.0)'],
            ['android_jellybean', '(android 4.)(1|2|3)'],
            ['android_kitkat', '(android 4.4)'],
            ['ie_mobile', '(windows phone os).*(iemobile)'],
            ['ipad', 'ipad'],
            ['kindle', 'kindle'],
            ['iphone', 'iphone'],
            ['other mobile', '(touchpad|blackberry|opera mobi)']
        ];

        for (var i=0; i < options.length; i++) {
            var pattern = new RegExp(options[i][1]);
            var match = userAgent.match(pattern);

            if (match !== null) {
                device = options[i][0];
            }
        }

        return device || 'desktop';
    },
    isIphone: function(){
        var _navigator = VHS.util.getNavigator();
        var userAgent = _navigator.userAgent.toLowerCase();
        var match = userAgent.match('iphone');
        var isIphone = (match !== null) ? true : false;

        return isIphone;
    },
    isIpad: function() {
        var _navigator = VHS.util.getNavigator();
        var userAgent = _navigator.userAgent.toLowerCase();
        return userAgent.indexOf('ipad') !== -1 ? true : false;
    },
    isIE9: function() {
        var _navigator = VHS.util.getNavigator();
        var userAgent = _navigator.userAgent.toLowerCase();
        return userAgent.indexOf('msie 9') !== -1 ? true : false;
    },
    isAndroid: function(){
        var _navigator = VHS.util.getNavigator();
        var userAgent = _navigator.userAgent.toLowerCase();
        return userAgent.indexOf('android') !== -1 ? true : false;
    },
    isSafari: function() {
        var _navigator = VHS.util.getNavigator();
        var userAgent = _navigator.userAgent.toLowerCase();
        return (userAgent.indexOf('safari') !== -1 && userAgent.indexOf('chrome') === -1) ? true : false;
    },
    supportsAds: function() {
        return (VHS.util.getDeviceType() === 'android_legacy' || VHS.util.getDeviceType() === 'android_ics') ? false : true;
    },
    /**
    * Ideally checks if a browser supports autoplay video
    * but since this feature detection is not supported yet we will do device detection.
    * If iOS or Android then we say we don't support autoplay
    * reference: http://stackoverflow.com/questions/7120703/how-do-i-detect-if-the-html5-autoplay-attribute-is-supported
    *
    * @method supportsAutoplay
    * @return {Boolean} Returns true if can autoplay
    */
    supportsAutoplay: function(){
        return !(VHS.util.isAndroid() || VHS.util.isIpad() || VHS.util.isIphone());
    },
    /**
    * Get the message for the error
    *
    * @method getErrorMessage
    * @param {Object} err A error object {code: Number}
    *
    * error codes
    * Flash Error Codes (codes are arbitrary for NYT only, prefaced with 10 to differentiate from HTML5)
    *  101 - NetStream IO Error
    *  102 - NetStream Download Error
    *  103 - MediaPlayer Media Error
    *  104 - MediaPlayer Live Stall
    *  105 - MediaPlayer State Playback Error
    *  106 - MediaElement Error (Live)
    *
    * HTML5 Error Codes
    *    1 - (Abort)       The fetching process for the media resource was aborted by the user agent at the user's request.
    *    2 - (Network)     A network error of some description caused the user agent to stop fetching the media resource, after the resource was established to be usable.
    *    3 - (Decode)      An error of some description occurred while decoding the media resource, after the resource was established to be usable.
    *    4 - (Unsupported) The media resource indicated by the src attribute was not suitable.
    *    203 - (NETWORK_NO_SOURCE) This is a custom error number. We listen for errors dispatched by the video element's source. If all of them return an error, the video element's networkState attribute will be 3 (NETWORK_NO_SOURCE)
    *
    */
    getErrorMessage: function(err, type, canPlay) {
        var errorMsg;
        var error = err;

        if (type && type === 'vod') {
            errorMsg = "This video is currently unavailable.";
        } else {
            errorMsg = "This stream is not currently available.";
        }

        // for html5 we'll get an error code / flash will be generic
        if (error && error.code) {
            switch (error.code) {
                case error.MEDIA_ERR_ABORTED:
                    errorMsg = "The video playback was aborted. Please refresh to resume playback.";
                    break;
                case error.MEDIA_ERR_NETWORK:
                    errorMsg = "The video connection was lost. Please refresh to resume playback.";
                    break;
                case error.MEDIA_ERR_DECODE:
                    errorMsg = "There was a video playback error. Please refresh to resume playback.";
                    break;
                case error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                    if (canPlay) {
                        errorMsg = "This video is currently unavailable. Please refresh to try again.";
                    } else {
                        errorMsg = "The video format is currently not supported in this browser.";
                    }
                    break;
            }
        }
        return errorMsg;
    },
    getDocument: function() {
        return document;
    },
    getNavigator: function() {
        return navigator;
    },
    getHost: function() {
        return window.location.host;
    },
    getParentHostname: function() {
        try {
            return parent.window.location.hostname;
        } catch (e) {
            return '';
        }
    },
    getReferrer: function() {
        return document.referrer;
    },
    getSupportedType: function (playerType) {
        if (playerType === "flash" || this.supportH264()) {
            return 'mp4';
        } else if (this.supportWebM()) {
            return 'webm';
        }
    },
    supportsFullscreen: function () {
        return VHS.api.Fullscreen.prototype._canRequestFullScreen();
    },

    /**
    * A method to let us know if VHS is using zepto
    *
    * @method zeptoInUse
    * @return {Boolean} Returns true on success
    */
    zeptoInUse: function() {
        return typeof $.zepto === 'object';
    },

    /**
    * A method to let us know if VHS is using jQuery
    *
    * @method jqueryInUse
    * @return {Boolean} Returns true on success
    */
    jqueryInUse: function() {
        return typeof $.fn.jquery === 'string';
    },

    /**
    * A method to load a script either via jQuery ajax library or using the script tag if jQuery is not available
    * This is needed to load Conviva and Freewheel libraries since they do not have CORS enabled.
    * For the jquery ajax request any parameters supported by jquery can be passed.
    * https://api.jquery.com/jQuery.ajax/
    *
    * @method getScriptNative
    * @param {Object} config A config object
    * @param {String} config.url The url of the script to load (only used for native script tag loading)
    * @param {Function} config.success The callback function on successful load (only used for native script tag loading)
    * @param {Function} config.error The callback function on error (only used for native script tag loading)
    * @param {Boolean} config.cache True to cache script (only used in jquery ajax request)
    * @param {Number} config.timeout The timeout in milliseconds for the request
    */
    getScript: function(config) {
        if (VHS.util.jqueryInUse()) {
            config.dataType = "script";
            $.ajax(config);
        } else {
            VHS.util.getScriptNative(config);
        }
    },

    /**
    * A method to load a script via the script tag to avoid cross-origin policy restrictions.
    * This is needed to load Conviva and Freewheel libraries since they do not have CORS enabled.
    * Useful when jQuery is not available. Used by VHS.util.getScript function.
    * Requires the page to have a head or body tag.
    *
    * @method getScriptNative
    * @param {Object} config A config object
    * @param {String} config.url The url of the script to load
    * @param {String} config.success The callback function on successful load
    * @param {String} config.error The callback function on error
    */
    getScriptNative: function(config) {
        var url, callback, errorCallback, head, body, doc;
        var scriptTag = document.createElement("script");

        url = config.url;
        callback = config.success;
        errorCallback = config.error;

        scriptTag.type = 'text/javascript';
        scriptTag.src = url;
        scriptTag.onload = function(){
            if (typeof callback === 'function') {
                callback();
            }
        };
        scriptTag.onerror = function(e){
            if (typeof errorCallback === 'function') {
                errorCallback(e);
            }
        };

        // ensure we have a head or body to append the script tag to
        doc = VHS.util.getDocument();
        head = doc.getElementsByTagName('head')[0];
        if (head) {
            head.appendChild(scriptTag);
        } else {
            body = doc.getElementsByTagName('body')[0];
            if (body) {
                body.appendChild(scriptTag);
            }
        }
    },

    /**
    * A method to normalize a unit for css
    * - If the value is a string make sure the value has a unit associated with it (default px if none provided)
    * - If the value is a number we can just use that
    * (Zepto needs a unit if the value is a string.  Zepto will default to px if the value is a Number.)
    *
    * @method normalizeUnit
    * @param {String|Number} value Value for a css property
    * @return {String|Number} value Returns the number as a number is no suffix or as a string with suffix
    */
    normalizeUnit: function(value) {
        var defaultUnit = 'px';
        if (typeof value === 'string') {
            value = (value.indexOf('%') === -1 && value.indexOf('px') === -1) ? [value,defaultUnit].join('') : value;
        }
        return value;
    },

    /**
     * Determines if the player is in an iframe
     * @return {[type]}
     */
    inIframe: function () {
        try {
                return window.self !== window.top;
        } catch (e) {
                return true;
        }
    },

    /**
     * Determines if the video is on a nyt domain
     * @return {Boolean}
     */
    isOnNYTDomain: function() {
        var referrer = this.getReferrer();
        var hostname;

        //if in iframe, check referrer
        if (this.inIframe() && referrer && referrer.indexOf('.nytimes.com') === -1) {
            return false;
        }

        //use hostname lookup
        if (!this.inIframe()) {
            hostname = this.getParentHostname();

            if (hostname.indexOf('.nytimes.com') === -1) {
                return false;
            }
        }

        return true;
    },

    /**
    * parse and return seek information in seconds from video url.
    * Accepted formats:
    * - t=200
    * - t=20m3s
    * - t=400s
    * - t=1h10m2s
    * @return {boolean}
    */
    seekStringToSeconds: function(url) {
        var parts;
        var seconds = 0;
        var seekTime = this.getUrlParameterByName('t');
        var factor = {'h': 3600, 'm': 60, 's': 1};
        if (!isNaN(seekTime)) {
            return Number(seekTime);
        } else {
            parts = seekTime.match(/[0-9]+[hms]+/g) || [];
            parts.forEach(function(el) {
                if (el) {
                    var suffix = el[el.length - 1];
                    var time = parseInt(el.slice(0, el.length - 1), 10);
                    seconds += time * (factor[suffix]);
                }
            });
            return seconds;
        }
    },

    getCurrentURL: function() {
        return window.location.href;
    },

    getUrlParameterByName: function(name) {
        name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
        var regex = new RegExp("[\\?&#]" + name + "=([^&#]*)");
        var results = regex.exec(this.getCurrentURL());
        return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
    },

    /**
    * Get the environment from the host...
    * i.e. stg, dev, localhost (staging, development, localhost)
    *
    * @method getEnvFromHost
    * @return {String} Returns environment
    */
    getEnvFromHost: function() {
        var host = VHS.util.getHost() || '';
        var env = 'production';

        if (host === 'localhost') {
            env = 'localhost';
        } else if (host.indexOf('.dev.') !== -1) {
            env = 'development';
        } else if (host.indexOf('.stg.') !== -1 || host.indexOf('.sbx.') !== -1) {
            env = 'staging';
        }

        return env;
    }
};

/**
@class Logger
@module VHS.api
@constructor
**/
VHS.api.Logger = function(player){
    this.debug = player.options.debug;
    this.canConsole = player.options.debug && window.console;
};

VHS.api.Logger.prototype = {
    /**
    @method log
    **/
    log: function(){
        if (this.canConsole) {
            window.console.log(arguments);
        }
    },
    /**
    @method info
    **/
    info: function(){
        if (this.canConsole) {
            window.console.info(arguments);
        }
    },
    /**
    @method warn
    **/
    warn: function() {
        if (this.canConsole) {
            window.console.warn(arguments);
        }
    },
    /**
    @method error
    **/
    error: function() {
        if (this.canConsole) {
            window.console.error(arguments);
        }
    }
};

/**
@module VHS
@function plugin
**/
VHS.plugin = function(name, proto, enable){
    var _enable = enable || false;
    var _plugins = VHS.api._plugins || {};
    _plugins[name] = {"enable": _enable, "proto": proto};

    VHS.api._plugins = _plugins;

    return _plugins;
};

/**
@class Plugin
@module VHS.api
@constructor
**/
VHS.api.Plugins = function(player){
    this.player = player;
    this._plugins = VHS.api._plugins;
    this._pluginInstances = [];

    this.register();
};

/**
Register Plugin
@method register
**/
VHS.api.Plugins.prototype.register = function(){
    var p, _plugin;
    var self  = this;
    var options = this.player.options;
    var Plugin = function(){
        this._player = self.player;
        this._container = self.player.container;
        this._data = self.player._data;
        this._options = self.player.options;
        this._logger = self.player.logger;
    };

    for (p in this._plugins) {
        if (options[p] === true || (this._plugins[p].enable === true && options[p] !== false)) {
            Plugin.prototype = this._plugins[p].proto;
            _plugin = new Plugin();
            _plugin._name = p;
            this._pluginInstances.push(_plugin);

            if (typeof _plugin._initialize === 'function') {
                _plugin._initialize();
            }

            this.listeners(_plugin);
        }
    }
};

/**
Reload
@method reload
**/
VHS.api.Plugins.prototype.reload = function() {
    var p, plugin;
    for (p in this._pluginInstances) {
        plugin = this._pluginInstances[p];
        plugin._data = this.player._data;
    }
};

/**
Add listeners
@method listeners
**/
VHS.api.Plugins.prototype.listeners = function(plugin){

    var bindPluginEvent = function(eventName, methodName){
        if (typeof plugin[methodName] === 'function') {
            this.player.on(VHS.api.events[eventName], function(data){
                plugin[methodName](data);
            });
        }
    };

    var pluginEvents = {
        "READY":"_ready",
        "LOADED":"_loaded",
        "PLAY":"_play",
        "PAUSE": "_pause",
        "MUTE": "_mute",
        "SEEKED": "_seeked",
        "ENDED": "_ended",
        "PLAYING": "_playing",
        "AD_STARTED": "_ad_started",
        "AD_COMPLETED": "_ad_completed",
        "AD_PAUSED": "_ad_paused",
        "AD_RESUMED": "_ad_resumed",
        "AD_SKIPPED": "_ad_skipped",
        "GO_FULLSCREEN": "_go_fullscreen",
        "EXIT_FULLSCREEN": "_exit_fullscreen",
        "PROGRESS": "_progress",
        "TIME_UPDATE": "_time_update",
        "LOAD_START": "_loadstart",
        "ERROR": "_error",
        "HD_ON": '_hd_on',
        "HD_OFF": '_hd_off',
        'SHOW_CONTROLS': '_show_controls',
        'HIDE_CONTROLS': '_hide_controls',
        "RENDERED": '_rendered',
        "TRACKING_EVENT": '_tracking_event',
        "RENDITION_NOT_FOUND": '_rendition_not_found'
    };

    for(var prop in pluginEvents){
        if (pluginEvents.hasOwnProperty(prop)) {
            bindPluginEvent.call(this, prop, pluginEvents[prop]);
        }
    }
};

VHS.plugin('webtrends', {
    _initialize: function(){
        var self = this;
        this.utils = VHS.util;
        this.tracked = false;
        this.firstPlay = true;
        this.trackingHistory = [];

        /**
        * Flag to see if media changed
        * @property mediaChanged
        * @type {boolean}
        * @default false
        */
        this.mediaChanged = false;

        /**
        * Flag to see if video is completed
        * @property videoCompleted
        * @type {boolean}
        * @default false
        */
        this.videoCompleted = false;

        /**
        * Flag to see if ad has started
        * @property adStarted
        * @type {boolean}
        * @default false
        */
        this.adStarted = false;

        /**
        * Flag to see if ad has completed
        * @property adCompleted
        * @type {boolean}
        * @default false
        */
        this.adCompleted = false;
    },

    /**
    * Get the reference id of the video.
    * 'id' in cherry api
    *
    * @method getId
    */
    getId: function(){
        if (this._data || this._options.id) {
            var id = (this._data) ? this._data.id : this._options.id;
            return id;
        } else {
            this._logger.warn('VHS::PLUGIN::WEBTRENDS:: ID is not defined');
            return false;
        }
    },

    /**
    * Get the name of the video.
    * 'headline' in cherry api
    *
    * @method getName
    */
    getName: function(){
        if (this._data || this._options.name) {
            var name = (this._data) ? this._data.headline : this._options.name;
            return name;
        } else {
            this._logger.warn('VHS::PLUGIN::WEBTRENDS:: NAME is optional <video data-setup=\'{"name: "name_video"}\'></video>');
            return false;
        }
    },

    /**
    * Get the category of the video.
    * 'section.content' from cherry api
    *
    * @method getCategory
    */
    getCategory: function(){
        var category;

        if (!this._data) {
            if (!this._options.category) {
                this._logger.warn('VHS::PLUGIN::WEBTRENDS:: CATEGORY is optional <video data-setup=\'{"category: "category_video"}\'></video>');
                return false;
            } else {
                category = this._options.category;
            }
        } else if (this._data.section) {
            category = this._data.section.content;
        }

        return category;
    },

    /**
    * Get the category of the video.
    * 'section.content' from cherry api
    *
    * @method getSeries
    */
    getSeries: function(){
        var series = '';

        if (!this._data) {
            if (!this._options.series) {
                this._logger.warn('VHS::PLUGIN::WEBTRENDS:: SERIES is optional <video data-setup=\'{"series: "series_video"}\'></video>');
                return false;
            } else {
                series = this._options.series;
            }
        } else if (this._data.contentSeries) {
            series = this._data.contentSeries.name;
        }

        return series;
    },

    /**
    * Get the Web Trends Parameters
    * - https://confluence.em.nytimes.com/display/VID/Web+Trends
    *
    * @method getParams
    * @param {Object} source A config object
    */
    getParams: function(source){
        var params = [
            'DCS.dcssip', 'www.nytimes.com',
            'DCS.dcsuri', '/video/' + this.getName() + '/' + source.action + '.html',
            'WT.ti', 'Video ' + this.getName() + ' ' + source.ti,
            'WT.cg_n', 'Video',
            'WT.videoCategory', this.getCategory(),
            'WT.videoEvent', source.event,
            'WT.videoLoad', source.load,
            'WT.videoName', this.getName(),
            'WT.z_gpt', 'Multimedia',
            'WT.z_gpst', 'Video',
            'WT.z_gpsst', 'Video-' + source.gpsst,
            'WT.z_vid', this.getId(),
            'WT.z_vpt', this._player.getPlayerType() + '|' + this.utils.getDeviceType(),
            'WT.z_vft', this.getSeries(),
            'WT.z_dcsm', 1
        ];

        if (source.z_vaud && source.action === 'Audio') {
            params.push('WT.z_vaud',source.z_vaud);
        }

        return params;
    },

    /**
    * Call the dcsMultiTrack function
    * - https://confluence.em.nytimes.com/display/VID/Web+Trends
    *
    * @method getParams
    * @param {Array} params A config array of parameters
    */
    track: function(params){
        if (typeof window.dcsMultiTrack !== 'undefined') {
            this._logger.info('VHS::PLUGIN::WEBTRENDS::', params);
            window.dcsMultiTrack.apply(this, params);

            if (this.trackingHistory.length > 0) {
                for (var i = 0, len = this.trackingHistory.length; i < len; i++ ) {
                    window.dcsMultiTrack.apply(this, this.trackingHistory[i]);
                }
                this.trackingHistory = [];
            }
        } else {
            this.trackingHistory.push(params);
        }
    },

    /**
    * Called on video play
    *
    * @method _play
    */
    _play: function(){
        if (!this.tracked) {
            var params;
            var basePlayParams = {
                'action': 'Play',
                'event': 'play',
                'gpsst': 'Play'
            };

            if (this._options.autoplay && this.firstPlay && !this._options.userInitiatedPlay) {
                if (this._options.autoPlayNext) {
                    // event though it is 'first play start' the embed says this is an 'auto play next'
                    // this is for the case where a browser does not support pushState so we reload the page (ie 8 and ie 9)
                    // this is to support TimesVideo
                    basePlayParams.ti = 'Play';
                } else {
                    basePlayParams.ti = 'PlayStart';
                }
                basePlayParams.load = 'auto';
                this.firstPlay = false;
            } else if (this.firstPlay) {
                // first play but not an autoplay
                basePlayParams.ti = 'PlayStart';
                basePlayParams.load = 'user';
                this.firstPlay = false;
            } else if (this._options.userInitiatedNext) {
                // used for endcard when video is complete and a user selects a new video to play, then userInitiatedNext is set so we know it didn't autoplay
                basePlayParams.ti = 'Play';
                basePlayParams.load = 'user';
            } else if (this.videoCompleted && !this.adStarted && this.mediaChanged) {
                // next video autoplayed and no preroll
                // video completed, no ad played, no user interuption
                basePlayParams.ti = 'Play';
                basePlayParams.load = 'auto';
            } else if (this.videoCompleted && this.adStarted && this.adCompleted && this.mediaChanged) {
                // next video autoplayed with preroll complete or skipped
                // video completed, ad played and completed without user interuption
                basePlayParams.ti = 'Play';
                basePlayParams.load = 'auto';
            } else {
                basePlayParams.ti = 'Play';
                basePlayParams.load = 'user';
            }

            params = this.getParams(basePlayParams);

            this.track(params);
            this.tracked = true;

            // reinitialize flags
            this.mediaChanged = false;
            this.videoCompleted = false;
            this.adStarted = false;
            this.adCompleted = false;
        }
    },

    /**
    * Called on video mute
    *
    * @method _mute
    * @param {Boolean} muted
    */
    _mute: function(muted) {
        var params;

        if (muted) {
            params = this.getParams({
                'action': 'Audio',
                'event': 'AudioOff',
                'load': 'null',
                'gpsst': 'Audio',
                'ti': 'Audio',
                'z_vaud': 'Off'
            });
        } else {
            params = this.getParams({
                'action': 'Audio',
                'event': 'AudioOn',
                'load': 'null',
                'gpsst': 'Audio',
                'ti': 'Audio',
                'z_vaud': 'On'
            });
        }

        this.track(params);
    },

    /**
    * Called on video ended
    *
    * @method _ended
    */
    _ended: function() {
        var params = this.getParams({
            'action': 'Finish',
            'event': 'finish',
            'load': 'null',
            'gpsst': 'Play',
            'ti': 'FinishStop'
        });

        this.track(params);
        this.tracked = false;
        this.videoCompleted = true;
    },

    /**
    * Called on video go fullscreen
    *
    * @method _go_fullscreen
    */
    _go_fullscreen: function() {
        var params = this.getParams({
            'action': 'GoBig',
            'event': 'Go Big',
            'load': 'null',
            'gpsst': 'Play',
            'ti': 'GoBig'
        });

        this.track(params);
    },

    /**
    * Called on video exit fullscreen
    *
    * @method _exit_fullscreen
    */
    _exit_fullscreen: function() {
        var params = this.getParams({
            'action': 'GoSmall',
            'event': 'Go Small',
            'load': 'null',
            'gpsst': 'Play',
            'ti': 'GoSmall'
        });

        this.track(params);
    },

    /**
    * Called on ad start.
    * Used only to maintain state.
    *
    * @method _ad_started
    */
    _ad_started: function() {
        this.adStarted = true;
    },

    /**
    * Called on ad completed.
    * Used only to maintain state.
    *
    * @method _ad_started
    */
    _ad_completed: function(){
        this.adCompleted = true;
    },

    /**
    * Called on ad skipped.
    * Used only to maintain state.
    *
    * @method _ad_skipped
    */
    _ad_skipped: function() {
        this.adCompleted = true;
    },

    /**
    * When a new video is loaded
    *
    * @method _loadstart
    */
    _loadstart: function() {
        this.tracked = false;
        this.mediaChanged = true;
    }
}, true);

VHS.plugin('comscore', {
    _initialize: function(){
        this.tracked = false;
    },
    loadLibrary:function(callback){
        var url = (document.location.protocol === "https:" ? "https://sb" : "http://b") + ".scorecardresearch.com/beacon.js";
        VHS.util.getScript({
            url: url,
            success: callback,
            dataType: 'script'
        });
    },
    getParams: function(source){
        var c5 = (this._player.adPlaying()) ? '09' : '02';
        var params = {
            c1:1,
            c2:'3005403',
            c3:'',
            c4:'',
            c5: c5
        };

        this._logger.log('VHS::PLUGIN::COMSCORE::', params);
        return params;
    },
    track: function(){
        var params = this.getParams();

        if (typeof COMSCORE !== 'undefined' && COMSCORE.beacon) {
            COMSCORE.beacon(params);
        } else {
            this.loadLibrary(function() {
                if (typeof COMSCORE !== 'undefined' && COMSCORE.beacon) {
                    COMSCORE.beacon(params);
                }
            });
        }
    },
    _playing: function(){
        if (!this.tracked) {
            this.track();
            this.tracked = true;
        }
    },
    _ended: function(){
        this.tracked = false;
    },
    _ad_started: function(){
        this.track();
    },

    /**
    * When a new video is loaded
    *
    * @method _loadstart
    */
    _loadstart: function() {
        this.tracked = false;
    }
}, true);

VHS.plugin('eventTracker', {
    _initialize: function(){
        this.util = VHS.util;
        this.ETEvents = {
            USER_PLAY: 'user-play',
            MID_STREAM_PLAY: 'mid-stream-play',
            AUTO_PLAY_NEXT: 'auto-play-next',
            AUTO_PLAY_START: 'auto-play-start',
            VIDEO_COMPLETE: 'video-complete',
            PAUSE: 'pause',
            UNPAUSE: 'unpause',
            GO_FULLSCREEN: 'go-fullscreen',
            EXIT_FULLSCREEN: 'exit-fullscreen',
            MUTED: 'muted',
            UNMUTED: 'unmuted',
            SKIP_AD: 'skip-ad',
            AD_START: 'ad-start',
            AD_COMPLETE: 'ad-complete',
            PLAYER_LOAD: 'player-load',
            PERCENT_25_VIEWED: 'percent-25-viewed',
            PERCENT_50_VIEWED: 'percent-50-viewed',
            PERCENT_75_VIEWED: 'percent-75-viewed',
            SEEK: 'seek',
            AD_PAUSE: 'ad-pause',
            AD_RESUME: 'ad-resume',
            MEDIA_ERROR: 'media-error',
            HD_ON: 'hd-on',
            HD_OFF: 'hd-off',
            VIDEO_TIME_TO_START: 'video-time-to-start',
            CONVIVA_NOT_INITIALIZED: 'conviva-not-initialized',
            CONVIVA_NOT_INITIALIZED_YET: 'conviva-not-initialized-yet',
            CONVIVA_LOAD_FAILURE: 'conviva-library-load-failure',
            CONVIVA_INIT_FAILURE: 'conviva-library-init-failure',
            CONVIVA_LOAD_TIME: 'conviva-library-load-time',
            QOS_LOAD_FAILURE: 'qos-library-load-failure',
            RENDITION_NOT_FOUND: 'rendition-not-found',
            FW_ADMANAGER_LOAD_ERROR: 'fw-admanager-load-error',
            FW_AD_MANAGER_LOAD_TIMEOUT: 'fw-ad-manager-load-timeout',
            CHERRY_API_REQUEST_ERROR: 'cherry-api-request-error',
            OSMF_HLS_PLUGIN_LOAD_FAILED: 'osmf-hls-plugin-load-failed',
            OSMF_QOS_PLUGIN_LOAD_FAILED: 'osmf-qos-plugin-load-failed',
            OSMF_CONVIVA_PLUGIN_LOAD_FAILED: 'osmf-conviva-plugin-load-failed',
            OSMF_CONVIVA_PLUGIN_INIT_FAILED: 'osmf-conviva-plugin-init-failed',
            OSMF_CONVIVA_PLUGIN_INIT_TIMEOUT: 'osmf-conviva-plugin-init-timeout',
            OSMF_FW_AD_REQUEST_TIMEOUT: 'osmf-fw-ad-request-timeout',
            OSMF_FW_AD_MANAGER_LOAD_TIMEOUT: 'osmf-fw-ad-manager-load-timeout',
            OSMF_FW_AD_MANAGER_LOAD_TIME: 'osmf-fw-ad-manager-load-time'
        };
        this.tracker = null;
        this.tracked = false;
        this.tracked25Percent = false;
        this.tracked50Percent = false;
        this.tracked75Percent = false;
        this.paused = false;
        this.firstPlay = true;
        this.trackingHistory = [];

        /**
        * Flag to see if media changed
        * @property mediaChanged
        * @type {boolean}
        * @default false
        */
        this.mediaChanged = false;

        /**
        * Flag to see if video is completed
        * @property videoCompleted
        * @type {boolean}
        * @default false
        */
        this.videoCompleted = false;

        /**
        * Flag to see if ad has started
        * @property adStarted
        * @type {boolean}
        * @default false
        */
        this.adStarted = false;

        /**
        * Flag to see if ad has completed
        * @property adCompleted
        * @type {boolean}
        * @default false
        */
        this.adCompleted = false;

        /**
        * Timestamp when player has loaded
        * @property loadedTimestamp
        * @type {Date}
        * @default null
        */
        this.loadedTimestamp = null;

        /**
        * Timestamp when video starts playing if auto-play enabled
        * @property endTimestamp
        * @type {Date}
        * @default null
        */
        this.endTimestamp = null;

        /**
        * Flag to see if startup time has been sent to ET
        * @property startUpTimeSent
        * @type {Boolean}
        * @default false
        */
        this.startUpTimeSent = false;

        this.percentages = {
            duration: 0,
            calculate: function (duration, percentages) {
                if (duration < 1) return;
                if (percentages.length < 1) return;
                this.duration = duration;
                for (var i = percentages.length - 1; i >= 0; i--) {
                    this[percentages[i]] = duration * (percentages[i]*0.01);
                }
                this.ready = true;
            }
        };
    },

    /**
    * Is an ad playing or initializing
    *
    * @method isAdPlaying
    * @return boolean
    */
    isAdPlaying: function() {
        return (this._player && this._player.adsController && (this._player.adsController.isContentPlaying || this._player.adsController.isInitializing));
    },

    /**
    * Get the reference id of the video.
    * 'id' in cherry api
    *
    * @method getId
    */
    getId: function(){
        if (this._data || this._options.id) {
            var id = (this._data) ? this._data.id : this._options.id;
            return id;
        } else {
            this._logger.warn('VHS::PLUGIN::EVENTTRACKER:: ID is not defined');
            return false;
        }
    },

    /**
    * Get the name of the video.
    * 'headline' in cherry api
    *
    * @method getName
    */
    getName: function(){
        if (this._data || this._options.name) {
            var name = (this._data) ? this._data.headline : this._options.name;
            return name;
        } else {
            this._logger.warn('VHS::PLUGIN::EVENTTRACKER:: NAME is optional <video data-setup=\'{"name: "name_video"}\'></video>');
            return false;
        }
    },

    /**
    * Get the category of the video.
    * 'section.content' from cherry api
    *
    * @method getCategory
    */
    getCategory: function(){
        var category;

        if (!this._data) {
            if (!this._options.category) {
                this._logger.warn('VHS::PLUGIN::EVENTTRACKER:: CATEGORY is optional <video data-setup=\'{"category: "category_video"}\'></video>');
                return false;
            } else {
                category = this._options.category;
            }
        } else if (this._data.section) {
            category = this._data.section.content;
        }

        return category;
    },

    /**
    * Get the category of the video.
    * 'section.content' from cherry api
    *
    * @method getSeries
    */
    getSeries: function(){
        var series = '';

        if (!this._data) {
            if (!this._options.series) {
                this._logger.warn('VHS::PLUGIN::EVENTTRACKER:: SERIES is optional <video data-setup=\'{"series: "series_video"}\'></video>');
                return false;
            } else {
                series = this._options.series;
            }
        } else if (this._data.contentSeries) {
            series = this._data.contentSeries.name;
        }

        return series;
    },

    /**
    * Get the primary playlist ID of the video.
    * 'playlist.id' from cherry api
    *
    * @method getPrimaryPlaylistId
    */
    getPrimaryPlaylistId: function(){
        var playlistId;

        if (!this._data) {
            this._logger.warn('VHS::PLUGIN::EVENTTRACKER:: playlistId missing _data');
            return false;
        } else if (this._data.playlist) {
            playlistId = this._data.playlist.id;
        }

        return playlistId;
    },

    /**
    * Get the current position of the video.
    *
    * @method getCurrentVideoPosition
    */
    getCurrentVideoPosition: function(){
        var position = 0;
        var currentTime;

        if (this._element && this._element.length > 0 && this._element[0].currentTime) {
            currentTime = (typeof this._element[0].currentTime === 'function') ? this._element[0].currentTime() : this._element[0].currentTime;
            position = Math.round(currentTime);
        }

        return position;
    },

    getErrorCode: function(evt) {
        var errorCode = '';
        if (this._element && this._element.length > 0 && this._element[0].error) {
            // for html5
            errorCode = this._element[0].error.code;
        } else if (evt && evt.error && evt.error.code) {
            // for flash
            errorCode = evt.error.code;
        }
        return errorCode;
    },

    getTrackingObject: function(evt) {
        var self = this;
        var obj = {
            "subject": "video-nytv",
            "url": window.location.href || "",
            "referrer": document.referrer || "",
            "playerType": self._player.getPlayerType() || "",
            "device": self.util.getDeviceType(),
            "tech": self._player.getType(),
            "event": evt || "",
            "playerVersion": VHS._version,
            "playerUsage": self._options.usage || "",
            "playerMode": self._options.mode,
            "videoDeliveryMethod": (self._options.live) ? 'live' : 'vod'
        };

        switch (evt) {
            case this.ETEvents.USER_PLAY:
            case this.ETEvents.AUTO_PLAY_NEXT:
            case this.ETEvents.AUTO_PLAY_START:
            case this.ETEvents.VIDEO_COMPLETE:
            case this.ETEvents.PAUSE:
            case this.ETEvents.UNPAUSE:
            case this.ETEvents.PERCENT_25_VIEWED:
            case this.ETEvents.PERCENT_50_VIEWED:
            case this.ETEvents.PERCENT_75_VIEWED:
            case this.ETEvents.PLAYER_LOAD:
            case this.ETEvents.SEEK:
            case this.ETEvents.MEDIA_ERROR:
            case this.ETEvents.HD_ON:
            case this.ETEvents.HD_OFF:
            case this.ETEvents.QOS_LOAD_FAILURE:
            case this.ETEvents.CONVIVA_NOT_INITIALIZED:
            case this.ETEvents.CONVIVA_NOT_INITIALIZED_YET:
            case this.ETEvents.CONVIVA_LOAD_FAILURE:
            case this.ETEvents.CONVIVA_INIT_FAILURE:
            case this.ETEvents.CONVIVA_LOAD_TIME:
            case this.ETEvents.RENDITION_NOT_FOUND:
            case this.ETEvents.FW_ADMANAGER_LOAD_ERROR:
            case this.ETEvents.FW_AD_MANAGER_LOAD_TIMEOUT:
            case this.ETEvents.OSMF_HLS_PLUGIN_LOAD_FAILED:
            case this.ETEvents.OSMF_QOS_PLUGIN_LOAD_FAILED:
            case this.ETEvents.OSMF_CONVIVA_PLUGIN_LOAD_FAILED:
            case this.ETEvents.OSMF_CONVIVA_PLUGIN_INIT_FAILED:
            case this.ETEvents.OSMF_CONVIVA_PLUGIN_INIT_TIMEOUT:
            case this.ETEvents.OSMF_FW_AD_MANAGER_LOAD_TIMEOUT:
            case this.ETEvents.OSMF_FW_AD_MANAGER_LOAD_TIME:
                obj = this.addBaseVideoProps(obj);
                obj = this.addVideoProps(obj);
                break;

            case this.ETEvents.GO_FULLSCREEN:
            case this.ETEvents.EXIT_FULLSCREEN:
            case this.ETEvents.MUTED:
            case this.ETEvents.UNMUTED:
            case this.ETEvents.VIDEO_TIME_TO_START:
            case this.ETEvents.OSMF_FW_AD_REQUEST_TIMEOUT:
                obj = this.addBaseVideoProps(obj);
                obj = this.addVideoProps(obj);
                if (this.isAdPlaying()) {
                    obj = this.addAdProps(obj);
                }
                break;

            case this.ETEvents.SKIP_AD:
            case this.ETEvents.AD_START:
            case this.ETEvents.AD_COMPLETE:
            case this.ETEvents.AD_PAUSE:
            case this.ETEvents.AD_RESUME:
                obj = this.addBaseVideoProps(obj);
                obj = this.addAdProps(obj);
                break;
        }

        return obj;
    },

    /**
    * Add Video Specific tracking params to Object
    *
    * @method addVideoProps
    * @param {Object} object - tracking object
    * @return {Object} Returns tracking object
    */
    addVideoProps: function(object) {
        var obj = object;
        obj.videoFranchise = this.getSeries();
        obj.videoDuration = this._player.getDuration();
        obj.videoSection = this.getCategory();
        obj.videoSubSection = '';
        obj.videoPrimaryPlaylistId = this.getPrimaryPlaylistId();
        obj.videoTimeOfEvent = this.getCurrentVideoPosition();
        return obj;
    },

    /**
    * Add Base Video tracking params to Object
    *
    * @method addBaseVideoProps
    * @param {Object} object - tracking object {videoId, videoName}
    * @return {Object} Returns tracking object
    */
    addBaseVideoProps: function(object) {
        var obj = object;
        obj.videoId = this.getId();
        obj.videoName = this.getName();

        if (this.isAdPlaying()) {
            obj.videoType = 'ad';
        } else {
            obj.videoType = 'video';
        }

        return obj;
    },

    addAdProps: function(object) {
        var obj = object;
        var dur = 0;

        if (this._player && this._player.adsController && this._player.adsController.currentSlot) {
            dur = this._player.adsController.currentSlot.getTotalDuration(true) || 0;
        } else if (this._player && this._player.adDuration) {
            dur = this._player.adDuration();
        }

        obj.adPosition = 'preroll';
        obj.adDuration = Math.round(dur);
        return obj;
    },

    track: function(obj){
        var self = this;
        this._logger.info('VHS::PLUGIN::EVENTTRACKER::', obj);
        if (this.tracker) {
            this.tracker.track(obj);
        } else if (typeof window.NYTD !== 'undefined' && window.NYTD.EventTracker){
            // init tracker
            this.tracker = new window.NYTD.EventTracker();

            // loop thru the saved events if any
            if (this.trackingHistory.length > 0) {
                var len = this.trackingHistory.length;
                for (var i = len-1; i >= 0; i-- ) {
                    this.tracker.track(this.trackingHistory[i]);
                }
                this.trackingHistory = [];
            }

            // track the originating event
            this.tracker.track(obj);
        } else {
            // save for later
            this.trackingHistory.push(obj);
        }
    },

    /**
     * Submits to Event Tracker when
     * the video startup time is ready.
     *
     * @method videoStartUpTime
     * @access private
     */
    videoStartUpTime: function() {
        this.startUpTimeSent = true;
        var obj = this.getTrackingObject(this.ETEvents.VIDEO_TIME_TO_START);
        var endTime = this.endTimestamp;
        var loadedTime = this.loadedTimestamp;
        var playerStartTimestamp = (this._player) ? this._player.playerStartTimestamp : null;
        if (endTime && loadedTime && playerStartTimestamp) {
            obj.videoTimeToStartFromLoaded = endTime.getTime() - loadedTime.getTime();
            obj.videoTimeToStartFromInit = endTime.getTime() - playerStartTimestamp.getTime();
            this.track(obj);
        }
    },

    _loadstart: function() {
        this._logger.info('VHS::PLUGIN::EVENTTRACKER::LOADSTART');
        this.tracked = false;
        this.tracked25Percent = false;
        this.tracked50Percent = false;
        this.tracked75Percent = false;
        this.paused = false;
        this.mediaChanged = true;
    },

    _play: function(){
        var obj = {};
        if (!this.tracked) {
            if (this._options.autoplay && this.firstPlay && !this._options.userInitiatedPlay) {
                if (this._player.startupSeek) {
                  obj = this.getTrackingObject(this.ETEvents.MID_STREAM_PLAY);
                } else if (this._options.autoPlayNext) {
                    // event though it is 'first play start' the embed says this is an 'auto play next'
                    // this is for the case where a browser does not support pushState so we reload the page (ie 8 and ie 9)
                    // this is to support TimesVideo
                    obj = this.getTrackingObject(this.ETEvents.AUTO_PLAY_NEXT);
                } else {
                    obj = this.getTrackingObject(this.ETEvents.AUTO_PLAY_START);
                }
                this.firstPlay = false;

                // record first play time
                if (!this.startUpTimeSent) {
                    this.endTimestamp = new Date();
                    this.videoStartUpTime();
                }
            } else if (this._options.userInitiatedNext) {
                if (this._player.startupSeek) {
                  obj = this.getTrackingObject(this.ETEvents.MID_STREAM_PLAY);
                } else {
                  // used for endcard when video is complete and a user selects a new video to play, then userInitiatedNext is set so we know it didn't autoplay
                  obj = this.getTrackingObject(this.ETEvents.USER_PLAY);
                }
            } else if (this.videoCompleted && !this.adStarted && this.mediaChanged) {
                // next video autoplayed and no preroll
                // video completed, no ad played, no user interuption
                obj = this.getTrackingObject(this.ETEvents.AUTO_PLAY_NEXT);
            } else if (this.videoCompleted && this.adStarted && this.adCompleted && this.mediaChanged) {
                // next video autoplayed with preroll complete or skipped
                // video completed, ad played and completed without user interuption
                obj = this.getTrackingObject(this.ETEvents.AUTO_PLAY_NEXT);
            } else {
                if (this._player.startupSeek) {
                  obj = this.getTrackingObject(this.ETEvents.MID_STREAM_PLAY);
                } else {
                  obj = this.getTrackingObject(this.ETEvents.USER_PLAY);
                }
            }
            this.track(obj);
            this.tracked = true;

            // reinitialize flags
            this.mediaChanged = false;
            this.videoCompleted = false;
            this.adStarted = false;
            this.adCompleted = false;

            // set startUpTimeSent flag as a fail safe so it does not trigger after a first play
            this.startUpTimeSent = true;

        } else if (this.paused && !this._player.hdRenditionChanging) {
            // unpaused - resumed
            obj = this.getTrackingObject(this.ETEvents.UNPAUSE);
            this.track(obj);
            this.paused = false;
        }
    },

    _pause: function(){
        if (this._player && (this._options.live || this._player.getDuration() > 0) && !this._player.hdRenditionChanging) {
            var obj = this.getTrackingObject(this.ETEvents.PAUSE);
            this.track(obj);
            this.paused = true;
        }
    },

    _seeked: function(){
        if (!this._player.hdRenditionChanging) {
            var obj = this.getTrackingObject(this.ETEvents.SEEK);
            this.track(obj);
        }
    },

    _mute: function(muted){
        var obj;

        if (muted) {
            obj = this.getTrackingObject(this.ETEvents.MUTED);
        } else {
            obj = this.getTrackingObject(this.ETEvents.UNMUTED);
        }

        this.track(obj);
    },

    _go_fullscreen: function(){
        var obj = this.getTrackingObject(this.ETEvents.GO_FULLSCREEN);
        this.track(obj);
    },

    _exit_fullscreen: function(){
        var obj = this.getTrackingObject(this.ETEvents.EXIT_FULLSCREEN);
        this.track(obj);
    },

    _ended: function(){
        var obj = this.getTrackingObject(this.ETEvents.VIDEO_COMPLETE);
        this.track(obj);
        this.tracked = false;
        this.tracked25Percent = false;
        this.tracked50Percent = false;
        this.tracked75Percent = false;
        this.videoCompleted = true;
    },

    _ad_started: function(){
        var obj = this.getTrackingObject(this.ETEvents.AD_START);
        this.track(obj);
        this.adStarted = true;

        if (!this.startUpTimeSent && this._options.autoplay && !this._options.userInitiatedPlay) {
            this.endTimestamp = new Date();
            this.videoStartUpTime();
        }
    },

    _ad_completed: function(){
        var obj = this.getTrackingObject(this.ETEvents.AD_COMPLETE);
        this.track(obj);
        this.tracked = false;
        this.tracked25Percent = false;
        this.tracked50Percent = false;
        this.tracked75Percent = false;
        this.adCompleted = true;
    },

    _ad_skipped: function() {
        var obj = this.getTrackingObject(this.ETEvents.SKIP_AD);
        this.track(obj);
        this.tracked = false;
        this.tracked25Percent = false;
        this.tracked50Percent = false;
        this.tracked75Percent = false;
        this.adCompleted = true;
    },

    _ad_paused: function(){
        var obj = this.getTrackingObject(this.ETEvents.AD_PAUSE);
        this.track(obj);
    },

    _ad_resumed: function(){
        var obj = this.getTrackingObject(this.ETEvents.AD_RESUME);
        this.track(obj);
    },

    _hd_on: function () {
        var obj = this.getTrackingObject(this.ETEvents.HD_ON);
        this.track(obj);
    },

    _hd_off: function () {
        var obj = this.getTrackingObject(this.ETEvents.HD_OFF);
        this.track(obj);
    },

    _loaded: function(){
        this._logger.info('VHS::PLUGIN::EVENTTRACKER::LOADED');
        var obj = this.getTrackingObject(this.ETEvents.PLAYER_LOAD);
        this.track(obj);
        this.loadedTimestamp = new Date();
    },

    _error: function(evt){
        var obj = this.getTrackingObject(this.ETEvents.MEDIA_ERROR);
        obj.errorCode = this.getErrorCode(evt);
        this.track(obj);
    },

    _time_update: function(pos){
        var dur = this._player.getDuration();

        var position = Math.round(parseInt(pos, 10));
        var duration = Math.round(parseInt(dur, 10));

        if (!this.percentages.ready || this.percentages.duration != duration) {
            this.percentages.calculate(duration, [25, 50, 75]);
        }

        var obj = {};

        if (position > 0) {
            if (position >= this.percentages['25'] && !this.tracked25Percent) {
                obj = this.getTrackingObject(this.ETEvents.PERCENT_25_VIEWED);
                this.track(obj);
                this.tracked25Percent = true;
            } else if (position >= this.percentages['50'] && !this.tracked50Percent) {
                obj = this.getTrackingObject(this.ETEvents.PERCENT_50_VIEWED);
                this.track(obj);
                this.tracked50Percent = true;
            } else if (position >= this.percentages['75'] && !this.tracked75Percent) {
                obj = this.getTrackingObject(this.ETEvents.PERCENT_75_VIEWED);
                this.track(obj);
                this.tracked75Percent = true;
            }
        }
    },

    _rendition_not_found: function(evt){
        var obj = this.getTrackingObject(this.ETEvents.RENDITION_NOT_FOUND);
        this.track(obj);
    },

    _tracking_event: function(evt) {
        var obj;
        if (evt && evt.data && evt.data.name) {
            switch (evt.data.name) {
                case this.ETEvents.CONVIVA_NOT_INITIALIZED:
                    this.track(this.getTrackingObject(this.ETEvents.CONVIVA_NOT_INITIALIZED));
                    break;
                case this.ETEvents.FW_ADMANAGER_LOAD_ERROR:
                    obj = this.getTrackingObject(this.ETEvents.FW_ADMANAGER_LOAD_ERROR);
                    obj.errorStatus = (evt.data.errorStatus) ? evt.data.errorStatus : '';
                    obj.errorThrown = (evt.data.errorThrown) ? evt.data.errorThrown : '';
                    this.track(obj);
                    break;
                case this.ETEvents.CHERRY_API_REQUEST_ERROR:
                    obj = this.getTrackingObject(this.ETEvents.CHERRY_API_REQUEST_ERROR);
                    obj.videoId = this.getId();
                    obj.errorStatus = (evt.data.errorStatus) ? evt.data.errorStatus : '';
                    obj.errorThrown = (evt.data.errorThrown) ? evt.data.errorThrown : '';
                    this.track(obj);
                    break;
                case this.ETEvents.QOS_LOAD_FAILURE:
                    obj = this.getTrackingObject(this.ETEvents.QOS_LOAD_FAILURE);
                    obj.errorStatus = (evt.data.errorStatus) ? evt.data.errorStatus : '';
                    obj.errorThrown = (evt.data.errorThrown) ? evt.data.errorThrown : '';
                    this.track(obj);
                    break;
                case this.ETEvents.CONVIVA_LOAD_FAILURE:
                    obj = this.getTrackingObject(this.ETEvents.CONVIVA_LOAD_FAILURE);
                    obj.errorStatus = (evt.data.errorStatus) ? evt.data.errorStatus : '';
                    obj.errorThrown = (evt.data.errorThrown) ? evt.data.errorThrown : '';
                    this.track(obj);
                    break;
                case this.ETEvents.CONVIVA_INIT_FAILURE:
                    obj = this.getTrackingObject(this.ETEvents.CONVIVA_INIT_FAILURE);
                    obj.code = (evt.data.code) ? evt.data.code : '';
                    obj.message = (evt.data.message) ? evt.data.message : '';
                    this.track(obj);
                    break;
                case this.ETEvents.CONVIVA_LOAD_TIME:
                    obj = this.getTrackingObject(this.ETEvents.CONVIVA_LOAD_TIME);
                    obj.loadtime = (evt.data.loadtime) ? evt.data.loadtime : -1;
                    this.track(obj);
                    break;
                case this.ETEvents.OSMF_FW_AD_MANAGER_LOAD_TIME:
                    obj = this.getTrackingObject(this.ETEvents.OSMF_FW_AD_MANAGER_LOAD_TIME);
                    obj.loadtime = (evt.data.loadtime) ? evt.data.loadtime : -1;
                    this.track(obj);
                    break;
                default:
                    this.track(this.getTrackingObject(evt.data.name));
                    break;
            }
        }
    },

    _rendered: function(evt) {
        this._element = this._player.element;
        this.bind();
    },
    /**
     * Creates tracking data using data in the DOM
     * Triggers a TRACKING_EVENT and sends data to EventTracker
     * @param  {jQuery.Element} el
     * @return {undefined}
     */
    trackDom: function (el) {
        var eventName = el.data('vhsEtName');
        var moduleName = el.closest('[data-vhs-et-module]').data('vhsEtModule') || 'default-module';
        var regionName = el.closest('[data-vhs-et-region]').data('vhsEtRegion') || moduleName;

        var moduleData = {
            "action": "click",
            "region": regionName,
            "module": moduleName,
            "eventName": eventName,
            "version":"video",
            "pgType": "video-player"
        };

        var canonicalUrl = this._getCanonicalUrl();
        var etData = {
            "subject":"module-interactions",
            "assetUrl": canonicalUrl,
            "moduleData": JSON.stringify(moduleData),
            "sourceApp": $('meta[name="sourceApp"]').attr('content') || 'nytv'
        };

        this.track(etData);
    },
    bind: function () {
        var self = this;

        this._container.on('click', '[data-vhs-et-name]', function (evt) {
            self.trackDom($(this));
        });
    },
    _getCanonicalUrl: function () {
        var origin;
        var canonicalUrl = $('link[rel="canonical"]').attr('href');

        if (!canonicalUrl || canonicalUrl.length < 1) {
            origin = document.location.origin;
            if (!origin) {
                origin = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ':' + window.location.port: '');
            }
            canonicalUrl = origin + document.location.pathname;
        }

        return canonicalUrl;
    }
}, true);

/**
* This is the plugin for Tagx Integration.
* This will send events to Google Analytics and Event Tracker through TagX.
*
* Supported modules: 'video-player', 'video-player-share'
*
* @class TagX
*/

VHS.plugin('tagx', {

    /**
    * Initialize Tagx - Set constants and state variables
    *
    * @method _initialize
    */
    _initialize: function() {
        this.trackedPlay = false;
        this.tracked25Percent = false;
        this.tracked50Percent = false;
        this.tracked75Percent = false;
        this.trackingHistory = [];

        this.paused = false;

        this.firstPlay = true;
        this.mediaChanged = false;
        this.videoCompleted = false;
        this.adStarted = false;
        this.adCompleted = false;
        this.loadedTimestamp = null;
        this.endTimestamp = null;
        this.startUpTimeSent = false;

        this.events = {
            PLAYER_LOAD: 'player-load',
            VIDEO_LOAD: 'video-load',

            USER_PLAY: 'user-play',
            MID_STREAM_PLAY: 'mid-stream-play',
            AUTO_PLAY_NEXT: 'auto-play-next',
            AUTO_PLAY_START: 'auto-play-start',
            VIDEO_COMPLETE: 'video-complete',
            PAUSE: 'pause',
            RESUME: 'resume',
            PERCENT_25_VIEWED: 'percent-25-viewed',
            PERCENT_50_VIEWED: 'percent-50-viewed',
            PERCENT_75_VIEWED: 'percent-75-viewed',
            SEEK: 'seek',

            GO_FULLSCREEN: 'go-fullscreen',
            EXIT_FULLSCREEN: 'exit-fullscreen',
            MUTED: 'muted',
            UNMUTED: 'unmuted',
            HD_ON: 'hd-on',
            HD_OFF: 'hd-off',

            SKIP_AD: 'skip-ad',
            AD_START: 'ad-start',
            AD_PAUSE: 'ad-pause',
            AD_RESUME: 'ad-resume',
            AD_COMPLETE: 'ad-complete',

            MEDIA_ERROR: 'media-error',

            VIDEO_TIME_TO_START: 'video-time-to-start',
            CONVIVA_NOT_INITIALIZED: 'conviva-not-initialized',
            CONVIVA_NOT_INITIALIZED_YET: 'conviva-not-initialized-yet',
            CONVIVA_LOAD_FAILURE: 'conviva-library-load-failure',
            CONVIVA_INIT_FAILURE: 'conviva-library-init-failure',
            CONVIVA_LOAD_TIME: 'conviva-library-load-time',
            QOS_LOAD_FAILURE: 'qos-library-load-failure',
            RENDITION_NOT_FOUND: 'rendition-not-found',
            FW_ADMANAGER_LOAD_ERROR: 'fw-admanager-load-error',
            FW_AD_MANAGER_LOAD_TIMEOUT: 'fw-ad-manager-load-timeout',
            CHERRY_API_REQUEST_ERROR: 'cherry-api-request-error',
            OSMF_HLS_PLUGIN_LOAD_FAILED: 'osmf-hls-plugin-load-failed',
            OSMF_QOS_PLUGIN_LOAD_FAILED: 'osmf-qos-plugin-load-failed',
            OSMF_CONVIVA_PLUGIN_LOAD_FAILED: 'osmf-conviva-plugin-load-failed',
            OSMF_CONVIVA_PLUGIN_INIT_FAILED: 'osmf-conviva-plugin-init-failed',
            OSMF_CONVIVA_PLUGIN_INIT_TIMEOUT: 'osmf-conviva-plugin-init-timeout',
            OSMF_FW_AD_REQUEST_TIMEOUT: 'osmf-fw-ad-request-timeout',
            OSMF_FW_AD_MANAGER_LOAD_TIMEOUT: 'osmf-fw-ad-manager-load-timeout',
            OSMF_FW_AD_MANAGER_LOAD_TIME: 'osmf-fw-ad-manager-load-time'
        };

        this.video_type = {
            VIDEO: 'video',
            AD: 'ad'
        };

        this.videoConfig = {
            videoType: this.video_type.VIDEO,
            module: 'video-player'
        };

        this.adConfig = {
            videoType: this.video_type.AD,
            module: 'video-player'
        };
    },

    /**
    * Track will call the event proxy or store the event for later sending
    *
    * @method track
    * @param {String} name The event name
    * @param {Object} config The config object for the tracking event (this.videoConfig, this.adConfig)
    * @param {Object} additionalData Any additional data that will be added to mData prop
    */
    track: function(name, config, additionalData) {
        var interaction = ['interaction', 'tagx-event-video'];
        var data = this.getTrackingData(name, config, additionalData);

        if (window.TAGX) {
            window.TAGX.EventProxy.trigger(name, data, interaction);

            if (this.trackingHistory.length > 0) {
                var len = this.trackingHistory.length;
                for (var i = len-1; i >= 0; i--) {
                    var evt = this.trackingHistory[i];
                    window.TAGX.EventProxy.trigger(evt.name, evt.data, evt.interaction);
                }
                this.trackingHistory = [];
            }
        } else {
            this.trackingHistory.push({
                name: name,
                data: data,
                interaction: interaction
            });
        }
    },

    /**
    * Get the tracking object
    *
    * @method getTrackingData
    * @param {String} name The event name
    * @param {Object} config The config object for the tracking event (this.videoConfig, this.adConfig)
    * @param {Object} additionalData Any additional data that will be added to mData prop
    * @return {Object} Returns obj
    */
    getTrackingData: function(name, config, additionalData) {
        var module = config.module || 'video-player';
        var region = config.region || '';
        var action = config.action || '';
        var videoType = config.videoType || this.video_type.VIDEO;
        var status = (name === this.events.VIDEO_COMPLETE) ? 'completed' : (this._player.isPaused() ? 'paused' : 'playing');

        // base object
        var obj = {
            module: module,
            version: this._player.getPlayerType() || "unknown",
            state: status,
            contentCollection: this._player.getCategory(),
            region: region,
            action: action,
            contentPlacement: '0', // need to revisit once playlist enabled
            contentId: this._player.getVideoId(),
            eventName: name,
            eventTimestamp: new Date().getTime(),
            mData: $.extend({
                videoName: this._player.getTitle()
            }, additionalData)
        };

        // video and ad specific data on mData
        if (module === 'video-player') {
            obj = this.addVideoData(obj, videoType);
        }

        return obj;
    },

    /**
    * Add video specific data to the event object
    *
    * @method addVideoData
    * @param {Object} obj The event object
    * @param {String} videoType The type of video: this.video_type.VIDEO || this.video_type.AD
    * @return {Object} Returns obj
    */
    addVideoData: function(obj, videoType) {
        obj.mData.device = VHS.util.getDeviceType();
        obj.mData.playerMode = this._options.mode;
        obj.mData.playerType = this._player.getPlayerType() || "";
        obj.mData.playerUsage = this._options.usage || "";
        obj.mData.playerVersion = VHS._version;
        obj.mData.tech = this._player.getType();
        obj.mData.videoDeliveryMethod = (this._options.live) ? 'live' : 'vod';
        obj.mData.videoDuration = this._player.getDuration();
        obj.mData.videoFranchise = this._player.getSeries();
        obj.mData.videoPrimaryPlaylistId = this._player.getPrimaryPlaylistId();
        obj.mData.videoSection = this._player.getCategory();
        obj.mData.videoSubSection = "";
        obj.mData.videoTimeOfEvent = this._player.getCurrentTime();
        obj.mData.videoType = videoType;

        if (videoType === this.video_type.AD) {
            obj.mData.adPosition = 'preroll';
            obj.mData.adDuration = Math.round(this._player.adDuration());
        }

        return obj;
    },

    /**
    * Get the error code from the element itself or the passed event
    *
    * @method getErrorCode
    * @param {Object} evt The event
    * @return {Number} Returns errorCode
    */
    getErrorCode: function(evt) {
        var errorCode = '';
        if (this._element && this._element.length > 0 && this._element[0].error) {
            // for html5
            errorCode = this._element[0].error.code;
        } else if (evt && evt.error && evt.error.code) {
            // for flash
            errorCode = evt.error.code;
        }
        return errorCode;
    },

    /**
     * Submits to TagX when
     * the video startup time is ready.
     *
     * @method videoStartUpTime
     * @access private
     */
    videoStartUpTime: function() {
        var config, additionalData;
        var playerStartTimestamp = (this._player) ? this._player.playerStartTimestamp : null;
        this.startUpTimeSent = true;
        if (this.endTimestamp && this.loadedTimestamp && playerStartTimestamp) {
            config = this._player.adPlaying() ? this.adConfig : this.videoConfig;
            additionalData = {
                videoTimeToStartFromLoaded: this.endTimestamp.getTime() - this.loadedTimestamp.getTime(),
                videoTimeToStartFromInit: this.endTimestamp.getTime() - playerStartTimestamp.getTime()
            };
            this.track(this.events.VIDEO_TIME_TO_START, config, additionalData);
        }
    },

    /**
    * player loaded event
    *
    * @method _loaded
    * @access private
    */
    _loaded: function(){
        this._logger.info('VHS::PLUGIN::TAGX::LOADED');
        this.track(this.events.PLAYER_LOAD, this.videoConfig);
        this.loadedTimestamp = new Date();
    },

    /**
    * media load start event
    *
    * @method _loadstart
    * @access private
    */
    _loadstart: function() {
        this._logger.info('VHS::PLUGIN::TAGX::LOADSTART');
        this.trackedPlay = false;
        this.tracked25Percent = false;
        this.tracked50Percent = false;
        this.tracked75Percent = false;
        this.paused = false;
        this.mediaChanged = true;

        this.track(this.events.VIDEO_LOAD, this.videoConfig);
    },

    /**
    * play event
    *
    * @method _play
    * @access private
    */
    _play: function() {
        var evt = this.events.USER_PLAY;

        if (!this.trackedPlay) {
            if (this._options.autoplay && this.firstPlay && !this._options.userInitiatedPlay) {
                if (this._player.startupSeek) {
                    evt = this.events.MID_STREAM_PLAY;
                } else if (this._options.autoPlayNext) {
                    // event though it is 'first play start' the embed says this is an 'auto play next'
                    // this is for the case where a browser does not support pushState so we reload the page (ie 8 and ie 9)
                    // this is to support TimesVideo
                    evt = this.events.AUTO_PLAY_NEXT;
                } else {
                    evt = this.events.AUTO_PLAY_START;
                }

                // record first play time
                if (!this.startUpTimeSent) {
                    this.endTimestamp = new Date();
                    this.videoStartUpTime();
                }
            } else if (this._options.userInitiatedNext) {
                // used for endcard when video is complete and a user selects a new video to play, then userInitiatedNext is set so we know it didn't autoplay
                evt = this.events.USER_PLAY;
            } else if (this.videoCompleted && !this.adStarted && this.mediaChanged) {
                // next video autoplayed and no preroll
                // video completed, no ad played, no user interuption
                evt = this.events.AUTO_PLAY_NEXT;
            } else if (this.videoCompleted && this.adStarted && this.adCompleted && this.mediaChanged) {
                // next video autoplayed with preroll complete or skipped
                // video completed, ad played and completed without user interuption
                evt = this.events.AUTO_PLAY_NEXT;
            } else {
                if (this._player.startupSeek) {
                    evt = this.events.MID_STREAM_PLAY;
                } else {
                    evt = this.events.USER_PLAY;
                }
            }

            // set that we've tracked this first play of this media
            this.trackedPlay = true;

            // set that this is no longer the first play
            this.firstPlay = false;

            // reinitialize flags
            this.mediaChanged = false;
            this.videoCompleted = false;
            this.adStarted = false;
            this.adCompleted = false;

            // set startUpTimeSent flag as a fail safe so it does not trigger after a first play
            this.startUpTimeSent = true;

            this.track(evt, this.videoConfig);

        } else if (this.paused && !this._player.hdRenditionChanging) {
            this.track(this.events.RESUME, this.videoConfig);
        }

        this.paused = false;
    },

    /**
    * pause event
    *
    * @method _pause
    * @access private
    */
    _pause: function() {
        if (this._player && (this._options.live || this._player.getDuration() > 0) && !this._player.hdRenditionChanging) {
            this.paused = true;
            this.track(this.events.PAUSE, this.videoConfig);
        }
    },

    /**
    * ended event
    *
    * @method _ended
    * @access private
    */
    _ended: function(){
        this.trackedPlay = false;
        this.tracked25Percent = false;
        this.tracked50Percent = false;
        this.tracked75Percent = false;
        this.videoCompleted = true;
        this.track(this.events.VIDEO_COMPLETE, this.videoConfig);
    },

    /**
    * Time Update event - computes quartiles
    *
    * @method _time_update
    * @access private
    */
    _time_update: function(pos){
        var position = Math.round(parseInt(pos, 10));
        var duration = Math.round(parseInt(this._player.getDuration(), 10));
        if (duration < 1 || position < 1) return;
        var evt;
        var pct25 = (duration * 0.25);
        var pct50 = (duration * 0.50);
        var pct75 = (duration * 0.75);

        if (position > 0) {
            if (position >= pct25 && position < pct50 && !this.tracked25Percent) {
                evt = this.events.PERCENT_25_VIEWED;
                this.tracked25Percent = true;
            } else if (position >= pct50 && position < pct75 && !this.tracked50Percent) {
                evt = this.events.PERCENT_50_VIEWED;
                this.tracked50Percent = true;
            } else if (position >= pct75 && !this.tracked75Percent) {
                evt = this.events.PERCENT_75_VIEWED;
                this.tracked75Percent = true;
            }

            if (evt) {
                this.track(evt, this.videoConfig);
            }
        }
    },

    /**
    * Seek event
    *
    * @method _seeked
    * @access private
    */
    _seeked: function() {
        if (!this._player.hdRenditionChanging) {
            this.track(this.events.SEEK, this.videoConfig);
        }
    },

    /**
    * Mute event
    *
    * @method _mute
    * @param {Boolean} muted true: muted, false: unmuted
    * @access private
    */
    _mute: function(muted) {
        var evt = (muted) ? this.events.MUTED : this.events.UNMUTED;
        var config = this._player.adPlaying() ? this.adConfig : this.videoConfig;
        this.track(evt, config);
    },

    /**
    * Fullscreen event
    *
    * @method _go_fullscreen
    * @access private
    */
    _go_fullscreen: function(){
        var config = this._player.adPlaying() ? this.adConfig : this.videoConfig;
        this.track(this.events.GO_FULLSCREEN, config);
    },

    /**
    * Exit Fullscreen event
    *
    * @method _exit_fullscreen
    * @access private
    */
    _exit_fullscreen: function(){
        var config = this._player.adPlaying() ? this.adConfig : this.videoConfig;
        this.track(this.events.EXIT_FULLSCREEN, config);
    },

    /**
    * HD on event
    *
    * @method _hd_on
    * @access private
    */
    _hd_on: function () {
        this.track(this.events.HD_ON, this.videoConfig);
    },

    /**
    * HD off event
    *
    * @method _hd_off
    * @access private
    */
    _hd_off: function () {
        this.track(this.events.HD_OFF, this.videoConfig);
    },

    /**
    * Ad Started event
    *
    * @method _ad_started
    * @access private
    */
    _ad_started: function() {
        this.adStarted = true;
        this.track(this.events.AD_START, this.adConfig);

        if (!this.startUpTimeSent && this._options.autoplay && !this._options.userInitiatedPlay) {
            this.endTimestamp = new Date();
            this.videoStartUpTime();
        }
    },

    /**
    * Ad Completed event
    *
    * @method _ad_completed
    * @access private
    */
    _ad_completed: function() {
        this.trackedPlay = false;
        this.tracked25Percent = false;
        this.tracked50Percent = false;
        this.tracked75Percent = false;
        this.adCompleted = true;
        this.track(this.events.AD_COMPLETE, this.adConfig);
    },

    /**
    * Ad Skipped event
    *
    * @method _ad_skipped
    * @access private
    */
    _ad_skipped: function() {
        this.trackedPlay = false;
        this.tracked25Percent = false;
        this.tracked50Percent = false;
        this.tracked75Percent = false;
        this.adCompleted = true;
        this.track(this.events.SKIP_AD, this.adConfig);
    },

    /**
    * Ad Paused event
    *
    * @method _ad_paused
    * @access private
    */
    _ad_paused: function() {
        this.track(this.events.AD_PAUSE, this.adConfig);
    },

    /**
    * Ad Resume event
    *
    * @method _ad_resumed
    * @access private
    */
    _ad_resumed: function() {
        this.track(this.events.AD_RESUME, this.adConfig);
    },

    /**
    * Media Error event
    *
    * @method _error
    * @param {Object} evt The event to be used to get the error code if we can not get from element
    * @access private
    */
    _error: function(evt){
        var config = this._player.adPlaying() ? this.adConfig : this.videoConfig;
        var additionalData = {};
        additionalData.errorCode = this.getErrorCode(evt);
        this.track(this.events.MEDIA_ERROR, config, additionalData);
    },

    /**
    * Rendition Not Found event
    *
    * @method _rendition_not_found
    * @access private
    */
    _rendition_not_found: function(){
        this.track(this.events.RENDITION_NOT_FOUND, this.videoConfig);
    },

    /**
    * Media Error event
    *
    * @method _tracking_event
    * @param {Object} evt The tracking event with all the data
    * @access private
    */
    _tracking_event: function(evt) {
        var additionalData = {};
        if (evt && evt.data && evt.data.name) {
            switch (evt.data.name) {
                case this.events.FW_ADMANAGER_LOAD_ERROR:
                case this.events.QOS_LOAD_FAILURE:
                case this.events.CONVIVA_LOAD_FAILURE:
                    additionalData.errorStatus = (evt.data.errorStatus) ? evt.data.errorStatus : '';
                    additionalData.errorThrown = (evt.data.errorThrown) ? evt.data.errorThrown : '';
                    break;

                case this.events.CHERRY_API_REQUEST_ERROR:
                    additionalData.videoId = this._player.getVideoId();
                    additionalData.errorStatus = (evt.data.errorStatus) ? evt.data.errorStatus : '';
                    additionalData.errorThrown = (evt.data.errorThrown) ? evt.data.errorThrown : '';
                    break;

                case this.events.CONVIVA_INIT_FAILURE:
                    additionalData.code = (evt.data.code) ? evt.data.code : '';
                    additionalData.message = (evt.data.message) ? evt.data.message : '';
                    break;

                case this.events.CONVIVA_LOAD_TIME:
                case this.events.OSMF_FW_AD_MANAGER_LOAD_TIME:
                    additionalData.loadtime = (evt.data.loadtime) ? evt.data.loadtime : -1;
                    break;
            }

            this.track(evt.data.name, this.videoConfig, additionalData);
        }
    },

    /**
    * Rendered event - when video obj or tag has rendered on DOM
    *
    * @method _rendered
    * @access private
    */
    _rendered: function() {
        this._element = this._player.element;
        this.bindTaggedDomElement();
    },

    /**
    * Bind the click event to track items tagged with attribute 'data-vhs-et-name'
    * div structure should have 'data-vhs-et-module' and 'data-vhs-et-region' for complete tracking
    *
    * @method bindTaggedDomElement
    * @access private
    */
    bindTaggedDomElement: function () {
        var self = this;

        if (this._container) {
            this._container.on('click', '[data-vhs-et-name]', function (evt) {
                self.trackDomClickEvent($(this));
            });
        }
    },

    /**
     * Creates tracking data using data in the DOM
     * Triggers a TRACKING_EVENT and sends data to TagX
     * @param  {jQuery.Element} el
     * @return {undefined}
     */
    trackDomClickEvent: function (el) {
        var eventName = el.data('vhsEtName');
        var moduleName = el.closest('[data-vhs-et-module]').data('vhsEtModule') || 'default-module';
        var regionName = el.closest('[data-vhs-et-region]').data('vhsEtRegion') || moduleName;
        var config = {
            module: moduleName,
            videoType: this.video_type.VIDEO,
            region: regionName,
            action: 'click'
        };

        this.track(eventName, config);
    }

}, false);

VHS.plugin('upt', {
    _initialize: function() {
        var self = this;
        this.utils = VHS.util;

        // setup upt tracking container
        this.body = $('body').first();
        this.uptContainer = $(document.createElement('div'));
        this.hideElement(this.uptContainer);
        this.body.append(this.uptContainer);

        // init UPT URL
        this.uptURL = [document.location.protocol, '//up.nytimes.com/'].join('');

        // get dcsvid from the dom - this relates to the user
        var dcsvid = window['dcsvid'] || $("meta[name='WT.dcsvid']").attr('content') || '';
        this.uid = encodeURIComponent(dcsvid);

        // set tracked flag
        this.tracked = false;
        this.trackedUptProgress = false;
    },

    /**
    * Get the UPT Parameters
    *
    * @method getParams
    * @param {Object} source A config object
    */
    getParams: function(source) {
        var url = (this._data && this._data.publish_url) ? 'http://www.nytimes.com'+encodeURIComponent(this._data.publish_url) : '';
        var href = encodeURIComponent(window.location.href);
        var evt = encodeURIComponent(source.event);
        var value = encodeURIComponent(((source.value !== null || source.value !== 'undefined' && source.value !== '') ? ['{"', source.event, '":"', source.value, '"}'].join('') : ''));
        var params = ['d=',0,'&m=','','&ui=',this.uid,'&u=',url,'&r=', href,'&e=', evt,'&p=', value].join('');

        return params;
    },

    /**
    * Add the UPT tracking image pixel to the dom
    *
    * @method getParams
    * @param {Array} params A config array of parameters
    */
    track: function(params){
        if (this._player.hasOwnProperty('adsController') && this._player.adsController.isContentPlaying) {
            return;
        }

        this._logger.info('VHS::PLUGIN::UPT::', params);

        var img = $(document.createElement('img'));
        img.attr('src', this.uptURL + '?' + params);
        this.hideElement(img);

        if (this.uptContainer) {
            this.uptContainer.empty();
            this.uptContainer.append(img);
        }
    },

    /**
     * Hides the container element which holds the
     * dynamically generated tracking beacon.
     *
     * @param {object} element The HTMLElement.
     * @access private
     */
    hideElement: function(element) {
        element.css({
            width: '0px',
            height: '0px',
            border: '0px'
        });

        element.hide();

        return element;
    },

    /**
    * Called on video play
    *
    * @method _play
    */
    _play: function() {
        if (!this.tracked) {
            var params = this.getParams({
                'event': 'videoStart',
                'value': ''
            });

            this.track(params);
            this.tracked = true;
        }
    },

    /**
    * Called on video complete
    *
    * @method _ended
    */
    _ended: function() {
        var params = this.getParams({
            'event': 'videoComplete',
            'value': ''
        });

        this.track(params);
        this.tracked = false;
        this.trackedUptProgress = false;
    },

    /**
    * Called on video progress
    *  Track if user watch up to 75%
    *
    * @method _progress
    */
    _time_update: function(pos){
        var dur = this._player.getDuration();
        var position = Math.round(parseInt(pos, 10));
        var duration = Math.round(parseInt(dur, 10));
        var targetPercentage = Math.round(duration * 0.75);

        if (position > 0 && position === targetPercentage && !this.trackedUptProgress) {
            var params = this.getParams({
                'event': 'videoWatched',
                'value': '75%'
            });
            this.track(params);
            this.trackedUptProgress = true;
        }
    },

    /**
    * When a new video is loaded
    *
    * @method _loadstart
    */
    _loadstart: function() {
        this.tracked = false;
        this.trackedUptProgress = false;
    }
}, true);

VHS.plugin('playNext', {
    _initialize: function(){
        this.playlist = null;
        this.currentVideo = 0;
    },
    _ended: function(){
        var self = this;

        this.getPlaylistData(function(){
            var currentVideoFromPlaylist = self.playlist.videos[self.currentVideo];

            if (self._data.id === currentVideoFromPlaylist.id) {
                self.currentVideo = self.currentVideo + 1;
            }

            self._options.poster = '';
            self._player.load(currentVideoFromPlaylist.id, true);
            self.currentVideo = self.currentVideo + 1;
        });
    },
    getPlaylistData: function(callback){
        var self = this;

        if (!self.playlist) {
            this._player.getData(this._data.playlist.id, 'playlist', function(result){
                self.playlist = result;
                callback();
            });
        } else {
            callback();
        }
    }
}, false);

/**
 * A plugin which uses event delegation and data- attributes on the DOM to determine how the current '_data' object of the video may be shared.
 * Metadata of the video which is exposed through the '_data' property is only shared when a share item is clicked has a matching key in the property config of the sharetools plugin.
 * Items which use the logic above must be nested within the player's container and have a class set to '.share-item'.
 * Those items must also contain data-share-handler (type of popup to use), data-share-name (config key to match), data-share-url (optional override for the url).
 */
VHS.plugin('sharetools', {
    _initialize: function () {
        this.config = {
            facebook: {
                name: "facebook",
                active: true,
                postUrl: "http://www.facebook.com/sharer.php",
                shareParameters: {
                    url : "u"
                },
                smid: "fb-share",
                width: 655,
                height: 430
            },
            twitter: {
                name: "twitter",
                active: true,
                postUrl: "https://twitter.com/share",
                shareParameters: {
                    url: "url",
                    title: "text",
                    related: "nytimes",
                    via: "nytvideo"
                },
                smid: "tw-share",
                width: 600,
                height: 450
            }
        };
        this.bind(this._container);
        this._container.addClass('vhs-plugin-' + this._name);
    },
    openShareHandler: function (target, evt, _data) {
        var el = $(target);
        var shareName = el.data('shareName');
        var shareHandler = el.data('shareHandler');
        var shareAltUrl = el.data('shareUrl');  //deprecated override
        var handlerFn = this[shareHandler];
        var options = this.config[shareName];
        var shareUrl = shareAltUrl ? shareAltUrl : _data.tiny_url || _data.url;
        var handlerOptions;

        if (options) {
            handlerOptions = $.extend({}, options, { shareUrl: shareUrl });
        }

        handlerOptions = this.checkShareDataOverride(handlerOptions, _data);

        if (typeof handlerFn === 'function') {
            handlerFn.call(this, handlerOptions, _data);
        }
    },
    /**
     * Checks to see if we have share override set for
     * the share link (used in the case of embedded-only videos).
     * Works in descending order of priority
     *
     * @param  {[object]} handlerOptions [the current handler options object]
     * @return {[object]}                [the modified handler options object]
     */
    checkShareDataOverride: function(handlerOptions, _data) {

        //handle blogpost override
        if (_data.blogpost_data) {
            if (_data.blogpost_data.url) {
                handlerOptions.shareUrl = _data.blogpost_data.url;
                handlerOptions.headline = _data.blogpost_data.headline || '';
            }
        }

        //handle article override
        if (_data.article_data) {
            if (_data.article_data.publish_url) {
                handlerOptions.shareUrl = 'http://www.nytimes.com' + _data.article_data.publish_url;
                handlerOptions.headline = _data.article_data.headline || '';
            }
        }

        return handlerOptions;
    },
    popup: function (options) {
        var postUrl = !options.encoded ? options.postUrl + "?" + options.shareParameters.url + "=" + encodeURIComponent(options.shareUrl) : options.postUrl;
        window.open(postUrl, options.name + 'Share', 'toolbar=0,status=0,height=' + options.height + ',width=' + options.width + ',scrollbars=yes,resizable=yes');
    },
    urlshortener: function (options, data) {
        var ricoUrl = '';
        var surlregex = /[\?&]share_url=([^&#]*)/;
        var results = surlregex.exec(window.location.search);
        var shareName = options.name;
        var queryParams = '';
        var shortUrlApi = 'http://www.nytimes.com/svc/bitly/shorten.jsonp';
        var shareUrl = options.shareUrl;
        var headline = options.headline || data.headline || '';

        if (headline) {
            queryParams += '&text=' + encodeURIComponent(headline);
        }

        if (options.shareParameters) {
            if (options.shareParameters.related) {
                queryParams += '&related=' + encodeURIComponent(options.shareParameters.related);
            }
            if (options.shareParameters.via) {
                queryParams += '&via=' + encodeURIComponent(options.shareParameters.via);
            }
        }

        if (shareUrl === data.tiny_url) {
            this.popup($.extend({}, options, { postUrl: options.postUrl + '?url=' + encodeURIComponent(data.tiny_url) + queryParams, encoded: true }));
            return;
        }

        if (results !== null) {
            ricoUrl = decodeURIComponent(results[1].replace(/\+/g, ' '));
        }

        var content = ['<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">',
            '<html><head>',
            '<script type="text/javascript" src="http://graphics8.nytimes.com/js/common.js"></script>',
            '<script type="text/javascript">',
                'function loadShortUrl() {',
                        'var url;',
                        'var ricoUrl = "', ricoUrl, '".replace(/\\s/g, "");',
                        'if (ricoUrl.length > 0) {',
                                'shortUrlRedirect(ricoUrl);',
                        '} else {',
                                'NYTD.jQuery.ajax({',
                                        'url: "', shortUrlApi, '",',
                                        'dataType: "jsonp",',
                                        'data: { "url" : "', shareUrl, '" },',
                                        'jsonpCallback: "callback",',
                                        'cache: true',
                                '}).success(function(data, textStatus, jqXHR){',
                                        'if (data && data.payload && data.payload.short_url) {',
                                                'short_url = data.payload.short_url;',
                                                'url = short_url;',
                                        '}',
                                        'shortUrlRedirect(url);',
                                '}).error(function(jqXHR, textStatus, errorThrown){',
                                        'shortUrlRedirect(url);',
                                '});',
                        '}',
                '};',
                'function shortUrlRedirect(url) {',
                        'window.location.href = "', options.postUrl, '?url=" + encodeURIComponent(url) + "', queryParams, '";',
                '};',
            '</script>',
            '</head>',
            '<body onload="loadShortUrl();"></body></html>'].join('');
        var w = window.open('', shareName + 'Share', 'toolbar=0,status=0,height=' + options.height + ',width=' + options.width + ',scrollbars=yes,resizable=yes');
        w.document.write(content);
        w.document.close(); // needed for chrome and safari
    },
    bind: function (_container) {
        var self = this;

        // standard share tool buttons
        // end-slate and pause-slate
        _container.on('click', '.vhs-share-item[data-share-handler]', function (evt) {
            self.openShareHandler.call(self, this, evt, self._data);
        });

        // only in pause-slate
        _container.on('click', '.vhs-share-module-overlay', $.proxy(function() {
            if (VHS.util.jqueryInUse()) {
                _container.find('.vhs-share-module, .vhs-share-module-overlay').fadeToggle();
            }
            _container.find('.vhs-pause-slate, .nytd-player-controls').toggleClass('vhs-share-showing');
            this._player.play();
        }, self));

        // extended share menu
        // only in pause-slate
        _container.on('click', '.vhs-share-menu', $.proxy(function() {
            this._player.pause();
            if (VHS.util.jqueryInUse()) {
                _container.find('.vhs-share-module, .vhs-share-module-overlay')
                    .fadeToggle()
                    .find('input')
                    .select()
                    .focus();
            }
            _container.find('.vhs-pause-slate, .nytd-player-controls').toggleClass('vhs-share-showing');
        }, self));

        // click text as well as buttons
        // only in pause-slate
        _container.on('click', '.vhs-icon-group span', function(){
            $(this).siblings('button').first().trigger('click');
            var icon = $(this).siblings('a').first();
            //js won't navigate to links so we have to do window.open
            if(icon.length > 0) {
                window.open(icon.attr('href'), '_blank');
            }
        });
    }
}, true);

/**
 * This plugin renderes an overlay after a video has ended which will render the times video logo, video title, video byline, and share buttons.
 * The plugin is visible whenever the sharetools plugin is enabled, the player's content is a video has not ended, and the controls are visible.
 */
VHS.plugin('endSlate', {
    shareToolsClass: 'vhs-plugin-sharetools',
    /**
     * has the end slate's rendered template and is only set when
     * the end slate is visible.
     * @type {Element}
     */
    el: null,
    template: VHS.templates.endSlate,
    replayButtonClick: function () {
        this._player.seek(0);
        this._player.play();
    },
    canRender: function () {
        var hasPlayNext = this._player.options.playNext === true;
        var domDeps = !hasPlayNext && !!this._container && this._container.length > 0 && !!this._data && this._container.hasClass(this.shareToolsClass);

        return this.options !== null && typeof this.options === 'object' && domDeps;
    },
    renderSlate: function () {
        var tmplOptions;
        if (this.canRender()) {
            tmplOptions = $.extend({}, this.options, { data: this._data });
            // create the plugin html wrapper
            this.el = $('<div class="vhs-plugin-' + this._name + '" />');
            // append the plugin's html to the wrapper
            this.el.html(this.template(tmplOptions));
            this._container.prepend(this.el);
        }
    },
    removeSlate: function () {
        if (this.isVisible()) {
            // remove the endslate from the DOM
            this.el.remove();
            this.el = null;
        }
    },
    isVisible: function () {
        return this.el && this.el.length;
    },
    _initialize: function () {
        var pluginOptions = this._player.options[this._name];

        if (pluginOptions === true || pluginOptions === 'true') {
            pluginOptions = {};
        }

        this.options = pluginOptions;
    },
    _ready: function () {
        if (this.canRender()) {
            this._container.addClass('vhs-plugin-' + this._name);
            this._container.on('click', '.vhs-replay-button', $.proxy(this.replayButtonClick, this));
        }
    },
    _show_controls: function () {
        // when the end slate is visible hide the controls
        if (this.isVisible() && this._player.modules && this._player.modules.controls && typeof this._player.modules.controls.hide === "function") {
            this._player.modules.controls.hide(true);
        }
    },
    _play: function () {
        this.removeSlate();
    },
    _playing: function () {
        this.removeSlate();
    },
    _ad_started: function () {
        this.removeSlate();
    },
    _ended: function () {
        this.renderSlate();
    }
}, true);

/**
 * This plugin renderes an overlay to the player which will render the times video logo, video title, video byline, and share buttons.
 * The plugin is visible whenever the sharetools plugin is enabled, the player's content is a video has not ended, and the controls are visible.
 */
VHS.plugin('controlsOverlay', {
    shareToolsClass: 'vhs-plugin-sharetools',
    defaults: {
        mode: 'clean',
        // Constants are not loaded yet using the values of [VHS.api.status.VIDEO_PLAYING, VHS.api.status.VIDEO_PAUSED]
        allowedStates: ["playing", "paused"]
    },
    template: VHS.templates.pauseSlate,
    renderContainer: function () {
        this.el = $('<div class="vhs-plugin-container-' + this._name + '" style="display: none;" />').prependTo(this._container);
        this.templateFn = this.options.template || this.template;
        this._container.addClass('vhs-plugin-' + this._name);
    },
    renderSlate: function (evt) {
        var viewOptions;

        if (!this.isEnabled) return;
        if (typeof this.templateFn !== "function") return;
        if (typeof this._data !== "object") return;

        //determine if sharetools should be hidden
        this.options.showShareTools = this.isValidShareUrl();
        this.options.isOnSite = VHS.util.isOnNYTDomain();
        this.options.linkUrl = this.getVideoLinkUrl();
        this.options.isEmbeddedOnly = this.isEmbeddedOnly();

        viewOptions = $.extend({}, this.options, { view: this.viewSettings[this.options.mode], data: this._data });

        //use the new shareOptions url in place of the deprecated controlsOverlay.url if provided
        if (this._player.options.shareOptions && this._player.options.shareOptions.url) {
            viewOptions.url = this._player.options.shareOptions.url;
        }

        if (!this.el.find('.vhs-pause-slate[data-id]').length) {
            this.el.append(this.templateFn(viewOptions));
        }

        if (VHS.util.jqueryInUse()) {
            this.el
                .show()
                .find('.vhs-pause-slate, .vhs-player-header-background')
                .stop(true, false)
                .fadeTo(evt.fadeArgs[0], evt.fadeArgs[1]);
        } else {
            this.el
                .show()
                .find('.vhs-pause-slate, .vhs-player-header-background')
                .css({'opacity': evt.fadeArgs[1]});
        }

        this.setupTimesVideoLinks();
    },
    removeSlate: function (evt) {
        var self = this;
        var slate;

        if (!this.isEnabled) return;

        slate = this.el.find('.vhs-pause-slate, .vhs-player-header-background, .vhs-share-module, .vhs-share-module-overlay');
        if (VHS.util.jqueryInUse()) {
            slate.fadeTo(evt.fadeArgs[0], evt.fadeArgs[1], function(){
                self.el.find('.vhs-pause-slate').removeClass('vhs-share-showing');
                self.el.empty();
            });
        } else {
            slate.css({opacity: evt.fadeArgs[1]});
            this.el.find('.vhs-pause-slate').removeClass('vhs-share-showing');
            this.el.empty();
        }
    },
    createOptions: function () {
        var options = $.extend({}, this.defaults, this._player.options[this._name] || {});
        options.mode = VHS.util.isAndroid() || VHS.util.isIphone() ? "clean" : options.mode;

        return options;
    },
    /**
     * Checks to see if we have a valid url when enabled any share tools
     * in the template.
     *
     * Rules (OR):
     *   1) Not embedded only video
     *   2) Has article_data publish url
     *   3) Has a override url
     *
     * @return {Boolean} [Do we have a valid url?]
     */
    isValidShareUrl: function() {
        var valid = false;

        //not an embedded-only video
        valid = !this.isEmbeddedOnly();

        //has an override url (deprecated)
        if (this.options.url) {
            valid = true;
        }

        //has an override url
        if (this._player.options.shareOptions && this._player.options.shareOptions.url) {
            valid = true;
        }

        //has an article override id
        if (this._data.article_data && this._data.article_data.publish_url) {
            valid = true;
        }

        //has a blogpost override
        if (this._data.blogpost_data && this._data.blogpost_data.url) {
            valid = true;
        }

        return valid;
    },
    /**
     * Determines if the video is embedded only or not
     * @return {Boolean}
     */
    isEmbeddedOnly: function() {
        if (typeof this._data.playlist === 'object' && Object.getOwnPropertyNames(this._data.playlist).length > 0) {
            return false;
        }

        return true;
    },
    /**
     * Retrieves the proper url for the video based on if it
     * is embedded only or not and if it has article/blog overrides
     * @return {[string]}
     */
    getVideoLinkUrl: function() {
        //not embedded-only video, return the standard url
        if (!this.isEmbeddedOnly()) {
            return this._data.domain + this._data.publish_url;
        }

        //has an article override url
        if (this._data.article_data && this._data.article_data.publish_url) {
            return 'http://www.nytimes.com' + this._data.article_data.publish_url;
        }

        //has a blog override url
        if (this._data.blogpost_data && this._data.blogpost_data.url) {
            return this._data.blogpost_data.url;
        }

        //no valid url to use
        return null;
    },
    setupTimesVideoLinks: function() {
        if (this._player.options.deeplinkingToTimesVideo) {
            if (this.getDeepLinkingType() === 'titleandlogo') {
                this.bindTitleAndLogo();
            } else {
                this.bindPlayerArea();
            }
        } else {
            this.bindTitleAndLogo();
        }
    },
    getDeepLinkingType: function() {
        // return titleAndLogo or playerArea from cookie.
        // Set one value if nothing is set, according
        // to our experiment described on VR-7015.
        var now, expireTime;
        var deepLinkingType = Cookies.get('nytvhsdeeplinking');
        if (!deepLinkingType) {
            deepLinkingType = (Math.random() * 10 > 5)? 'titleandlogo': 'playerarea';
            now = new Date();
            expireTime = new Date(now.setMonth(now.getMonth() + 1));

            Cookies.set('nytvhsdeeplinking', deepLinkingType, { expires: expireTime });
        }
        return deepLinkingType;
    },
    bindTitleAndLogo: function() {
        var self = this;
        var titleWrapper = this.el.find('.vhs-video-title-wrapper .vhs-data a');
        var timesLogo = this.el.find('.vhs-player-header .vhs-times-logo');

        titleWrapper.off('click');
        titleWrapper.one('click', $.proxy(function(e) {
            e.preventDefault();
            self.pauseAndRedirect('title-area');
        }, this));

        if (this.options.linkUrl) {
            timesLogo.off('click');
            timesLogo.one('click', $.proxy(function(e) {
                e.preventDefault();
                self.pauseAndRedirect('times-logo-area');
            }, this));
        }
    },
    bindPlayerArea: function() {
        var self = this;
        var playerArea = this._player.container.find('.nytd-player-video-area');

        //append to DOM if not already there
        if (playerArea.length === 0) {
            this._player.container.append('<div class="nytd-player-video-area"></div>');
            playerArea = this._player.container.find('.nytd-player-video-area');
        }

        playerArea.addClass('nytd-clickable-area');
        playerArea.off();
        playerArea.one('click', function() {
            self.pauseAndRedirect('video-area');
        });
    },
    pauseAndRedirect: function(region) {
        this._player.pause();
        var linkUrl = this.getRedirectUrl(region);
        window.open(linkUrl, '_blank');
    },
    getRedirectUrl: function(region) {
        var querystring = "?action=click&gtype=vhs&version=vhs-heading&module=vhs&region=" + region;
        var abTestTrack, startupSeek;
        if (this._player.options.deeplinkingToTimesVideo) {
            if (region === 'times-logo-area' || region === 'title-area') {
                abTestTrack = '&video-click-enabled=false';
            } else {
                abTestTrack = '&video-click-enabled=true';
            }
            startupSeek = Math.round(this._player.getCurrentTime());
            return this.getVideoLinkUrl() + querystring + abTestTrack + "&t=" + startupSeek + "&cview=true";
        } else {
            return region === 'times-logo-area' ? 'http://nytimes.com/video' : this.getVideoLinkUrl() + querystring;
        }
    },
    _initialize: function() {
        this.options = this.createOptions();
    },
    _rendered: function () {
        this.isEnabled = this._data && this.options.mode !== "clean" && typeof this.viewSettings[this.options.mode] === 'object';

        if (this.isEnabled && this._container.hasClass(this.shareToolsClass)) {
            this.renderContainer();
        }

        if (this.options.mode == "clean") {
            this.destroy();
        }
    },
    _show_controls: function(evt) {
        if ($.inArray(this._player.status, this.options.allowedStates) < 0) {
            return;
        }

        this.renderSlate(evt);
    },
    _hide_controls: function(evt) {
        if ($.inArray(this._player.status, this.options.allowedStates) < 0) {
            return;
        }

        this.removeSlate(evt);
    },
    _ad_started: function() {
        this.removeSlate({ fadeArgs: [0, 1] });
    },
    _ended: function () {
        this.removeSlate({ fadeArgs: [0, 1] });
    },
    destroy: function () {
        var noop = function(){};
        // prevent vhs from triggering these events
        this._show_controls = noop;
        this._hide_controls = noop;
        this._ad_started = noop;
    },
    viewSettings: {
        // clean - disables content
        share: {
            logoClasses: "vhs-no-pipe",
            titleClasses: "vhs-invisible"
        },
        article: {
            logoClasses: "",
            titleClasses: ""
        },
        offsite: {
            logoClasses: "",
            titleClasses: ""
        }
    }
}, true);

VHS.plugin('stats', {
    _initialize: function(){
        this.stats = false;
        this.videoStats = {
            droppedFrames:0,
            decodedFrames:0,
            videoDecodedBytes:0,
            audioDecodedBytes:0,
            bitrate:0,
            mimetype:"",
            volume:100,
            videoId:0,
            dimensions: {width:0, height:0},
            videoResolution: {width:0, height:0},
            streamType:"http",
            bandwidth:0,
            buffered:0,
            currentTime:0
        };
    },
    _loaded:function(){
        var video = this._player.element[0];
        this.videoStats.videoId = (this._data) ? this._data.id : this._options.id||-1;

    },
    _time_update:function(pos){
        var video = this._player.element[0];
        this.videoStats.decodedFrames = video.webkitDecodedFrameCount;
        this.videoStats.droppedFrames = video.webkitDroppedFrameCount;
        this.videoStats.videoDecodedBytes = video.webkitVideoDecodedByteCount;
        this.videoStats.audioDecodedBytes = video.webkitAudioDecodedByteCount;
        this.videoStats.currentTime = pos;
        this.videoStats.volume = video.volume;
        this.videoStats.buffered = video.buffered;
        this.videoStats.videoResolution = {width: video.videoWidth, height:video.videoHeight};
        this.videoStats.dimensions = {width: this._container.width(), height:this._container.width()};
        //console.log(this.videoStats);
    }
}, false);

VHS.plugin('vpaidUpdateAd', {
    _time_update: function(pos) {
        if (this._player.element.get(0) && typeof this._player.element.get(0).updateAd === 'function') {
            this._player.element.get(0).updateAd({
                videoTime: pos
            });
        }
    }
}, true);

/**
* Global external library manager.
* Used if VHS players share a 3rd party library.
* Conviva can only be initialized once even if multiple players on the page
*
* @module VHS.libraries.conviva
* @constructor
*/

VHS.libraries = VHS.libraries || {};
VHS.libraries.conviva = {
    // flag var to let other VHS instances know if conviva is already loading
    loading: false,

    // flag to indicate if conviva failed to initialized on this page - useful for new players created on the page
    failed: false,

    // store play callbacks when conviva is loading and intitializing
    callbacks: [],

    // check for any play cmds that were issued while conviva was loading
    checkForQueuedCallback: function() {
        // there can be multiple players on the page so we need to call play on the correct player
        if (VHS.libraries.conviva.callbacks.length > 0) {
            var callbackObject = VHS.libraries.conviva.callbacks.pop();
            var callback = callbackObject.callback;
            var context = callbackObject.context;
            if (typeof callback === 'function' && typeof context === 'object') {
                callback.apply(context);
            }
        }
    },

    // only queue one play callback - we only ever play one video at a time...
    queuePlayback: function(player) {
        // only store the last play callback since only one video should be playing on the page anyway
        // save the context of the play callback so we know which player use
        VHS.libraries.conviva.callbacks = [{context: player, callback: player.play}];
    }
};

/**
* This is a module for integrating Conviva analytics.
* This was a plugin but it requires tighter integration with VHS so needs to be a module.
* There is one module instance per VHS instance
*
* @class Conviva
* @module VHS.api
* @constructor
*/
VHS.api.Conviva = function(player){
    this._player = player;
    this._options = player.options;
    this._logger = player.logger;
    this.listenersSetup = false;

    this.LIBRARY_URL = 'http://livepassdl.conviva.com/ver/2.88.0.23377/LivePass.js';
    this.FLASH_PLUGIN_URL = 'https://livepassdl.conviva.com/OSMF/ConvivaOSMFPlugin_OSMF2_0_FP10_0.swf';
    this.CUSTOMER_ID = 'c3.NYTimes';
    this.SERVICE_URL = 'http://livepass.conviva.com';

    if (this._options.debugConviva && this._options.env !== 'production') {
        this.CUSTOMER_ID = 'c3.NYTimes-Test';
        this.SERVICE_URL = 'https://testonly.conviva.com';
    }

    if (this._options.conviva && typeof this._player.getType === 'function' && this._player.getType() === 'html5') {
        // only initialize for HTML5 - flash configures internally
        this.initialize();
    }
};

VHS.api.Conviva.prototype = {
    initialize: function () {
        var self = this;
        this.utils = VHS.util;
        this.session = null;
        this.sessionInitialized = false;

        if (typeof Conviva === 'function' && Conviva.hasOwnProperty('LivePass') && !Conviva.LivePass.ready && !Conviva.LivePass.pending) {
            // Conviva is already loaded but not initialized (ready) and not in the process of being initialized (pending)
            this.convivaInitialize();
        } else {
            this.loadConvivaLibrary(function(){self.convivaInitialize();});
        }
    },

    loadConvivaLibrary: function(callback) {
        var self = this;
        var convivaLoadLibraryErrorHandler;

        // check to make sure another VHS instance isn't already loading the lib
        if (!VHS.libraries.conviva.loading) {
            this.convivaLoadStartTimestamp = new Date();

            // setup load error handler
            convivaLoadLibraryErrorHandler = function(err, errStatus, errThrown) {
                // library failed to load
                // log to event tracker
                if (self && self._player && typeof self._player.trigger === 'function') {
                    self._player.trigger(VHS.api.events.TRACKING_EVENT, {
                        data: {
                            name: "conviva-library-load-failure",
                            errorStatus: errStatus || '',
                            errorThrown: errThrown || ''
                        }
                    });

                    self.convivaFailure();
                }
            };

            // load conviva library
            VHS.util.getScript({
                url: this.LIBRARY_URL,
                success: callback,
                error: convivaLoadLibraryErrorHandler,
                timeout: 3000,
                cache: true,
                dataType: "script"
            });

            VHS.libraries.conviva.loading = true;
        }
    },

    convivaInitialize: function() {
        var self = this;
        if (typeof Conviva === 'function' && Conviva.hasOwnProperty('LivePass')) {
            // toggleTraces must be called before 'init' to hide or show console logs
            Conviva.LivePass.toggleTraces(this._options.debug);
            Conviva.LivePass.init(this.SERVICE_URL , this.CUSTOMER_ID, function(convivaNotification){
                self.livePassNotifier(convivaNotification);
            });
        }
    },

    livePassNotifier: function(convivaNotification) {
        var convivaLoadTime;
        if ( convivaNotification && convivaNotification.code === 0 ) {
            this._logger.info( "Conviva LivePass initialized successfully." );
            // call global initialized so all instances of VHS know Conviva is ready
            VHS.libraries.conviva.checkForQueuedCallback();

            this.convivaLoadEndTimestamp = new Date();
            // log to event tracker
            if (this.convivaLoadStartTimestamp) {
                convivaLoadTime = this.convivaLoadEndTimestamp.getTime() - this.convivaLoadStartTimestamp.getTime();
                this._player.trigger(VHS.api.events.TRACKING_EVENT, {
                    data: {
                        name: "conviva-library-load-time",
                        loadtime: convivaLoadTime
                    }
                });
            }
        } else {
            if ( convivaNotification && Conviva.LivePass.ready ) { // check if LivePass is already initialized
                this._logger.info( "Conviva LivePass post-initialization feedback.\n " +
                "\tCode: " + convivaNotification.code + ";\n " +
                "\tMessage: " + convivaNotification.message );
            } else if (convivaNotification) {
                this._logger.info( "Conviva LivePass failed to initialize!\n " +
                "\tConviva metrics will not be captured! " +
                "\tCode: " + convivaNotification.code + "; " +
                "\tMessage: " + convivaNotification.message );
                // library failed to initialize
                // log to event tracker
                this._player.trigger(VHS.api.events.TRACKING_EVENT, {
                    data: {
                        name: "conviva-library-init-failure",
                        code: convivaNotification.code,
                        message: convivaNotification.message
                    }
                });

                this.convivaFailure();
            }
        }
    },

    convivaFailure: function() {
        // loop through all players on page and turn conviva off if conviva fails to load or initialize
        for (var i in window.vhs_instances) {
            if (window.vhs_instances.hasOwnProperty(i) && window.vhs_instances[i].options) {
                window.vhs_instances[i].options.conviva = false;
            }
        }

        VHS.libraries.conviva.failed = true;

        //  check to see if we have any queued plays
        VHS.libraries.conviva.checkForQueuedCallback();
    },

    getSource: function() {
        var src = '';
        if (this._player && this._player.modules && this._player.modules.renditions) {
            src = this._player.modules.renditions.getActive();
        }
        return src;
    },

    getParams: function(){
        var convivaMetadata = {};
        var headline = (this._player._data) ? this._player._data.headline : this._options.name;
        var info = (this._options.id) ? '[' + this._options.id + ']' + headline : headline;

        if (typeof Conviva === 'function' && Conviva.hasOwnProperty('ConvivaContentInfo') && Conviva.ConvivaContentInfo) {
            convivaMetadata = Conviva.ConvivaContentInfo.createInfoForLightSession( info );
            convivaMetadata.cdnName = Conviva.ConvivaContentInfo.CDN_NAME_AKAMAI;
            convivaMetadata.streamUrl = this.getSource();
            convivaMetadata.isLive = this._options.live;
            convivaMetadata.playerName = this._player.getPlayerType();
            convivaMetadata.tags = {
                autoplay : this._options.autoplay,
                mode: 'html5',
                version: VHS._version
            };

            this._logger.info('VHS::MODULE::CONVIVA:: cdnName',  convivaMetadata.cdnName);
            this._logger.info('VHS::MODULE::CONVIVA:: playerName',  convivaMetadata.playerName);
            this._logger.info('VHS::MODULE::CONVIVA:: streamUrl',  convivaMetadata.streamUrl);
            this._logger.info('VHS::MODULE::CONVIVA:: isLive',  convivaMetadata.isLive);
        }
        return convivaMetadata;
    },

    // ref: http://developer.conviva.com/integration/html5
    startConvivaSession: function() {
        // only start once
        if (!this.sessionInitialized && (this._player && this._player.element && typeof this._player.getType === 'function' && this._player.getType() === 'html5')) {
            var videoElem = this._player.element[0];
            var params = {};
            var duration = this._player.getDuration();

            if (typeof Conviva === 'function' && Conviva.hasOwnProperty('LivePass')) {
                if (this.session) {
                    Conviva.LivePass.cleanupMonitoringSession(videoElem);
                    this.session.cleanup();
                    this._logger.info('VHS::MODULE::CONVIVA:: cleanup session');
                }

                params = this.getParams();

                this.session = Conviva.LivePass.createSession(videoElem, params);
                this.session.setContentLength(duration);
                this._logger.info('VHS::MODULE::CONVIVA:: creating session');

                this.sessionInitialized = true;
            }
        }
    },

    endConvivaSession: function() {
        var videoElem;
        if (this.session && this._player && this._player.element && typeof Conviva === 'function' && Conviva.hasOwnProperty('LivePass')) {
            videoElem = this._player.element[0];
            Conviva.LivePass.cleanupMonitoringSession(videoElem);
            this.session.cleanup();
            this.session = null;
            this._logger.info('VHS::MODULE::CONVIVA:: end session');
            this.sessionInitialized = false;
            // reset video changed, if the video gets replayed we want to track that play too
            this._player.videoChanged = true;
        }
    },

    setupListeners: function() {
        var self = this;

        if (this.listenersSetup) return false;

        this._player.on(VHS.api.events.ENDED, function() {
            self._ended();
        });

        this.listenersSetup = true;
    },

    trackVideo: function () {
        this._logger.info('VHS::MODULE::CONVIVA:: track video');
        var success = false;
        if (typeof Conviva === 'function' && Conviva.hasOwnProperty('LivePass') && Conviva.LivePass.ready) {
            this.setupListeners();
            // if no ads then start session now
            // if there will be ads then we'll start the session when the content begins
            if (!this._player.options.ads || !VHS.util.supportsAds()) {
                this.startConvivaSession();
            }
            success = true;
        } else {
            // conviva not initialized yet
            this._logger.info('VHS::MODULE::CONVIVA:: not initialized yet');
            this._player.trigger(VHS.api.events.TRACKING_EVENT, {data: {name: "conviva-not-initialized-yet"}});

            // queue playback function
            VHS.libraries.conviva.queuePlayback(this._player);
        }
        return success;
    },

    _ended: function(){
        this.endConvivaSession();
    }

};

/* Media Analytics from Akamai
 *
 */

VHS.libraries = VHS.libraries || {};
VHS.libraries.qos = {
    /**
    * Flag var to let other VHS instances know if qos is already loading
    *
    * @static
    * @public
    * @property loading
    * @type {Boolean}
    * @default false
    */
    loading: false,

    /**
    * flag var to let other VHS instances know if qos is already loaded
    *
    * @static
    * @public
    * @property loaded
    * @type {Boolean}
    * @default false
    */
    loaded: false,

    /**
    * Flag to indicate if qos failed to load on this page - useful for new players created on the page
    *
    * @static
    * @public
    * @property failed
    * @type {Boolean}
    * @default false
    */
    failed: false,

    /**
    * Flag to indicate that this is the first stream
    *
    * @static
    * @public
    * @property firstStream
    * @type {Boolean}
    * @default true
    */
    firstStream: true,


    /**
    * Store active playerId
    *
    * @static
    * @public
    * @property activePlayerId
    * @type {String}
    * @default null
    */
    activePlayerId: null,

    /**
    * Store callbacks when qos is loading
    *
    * @static
    * @public
    * @property callbacks
    * @type {Array}
    * @default []
    */
    callbacks: [],

    /**
    * Reset state of qos library loader
    *
    * @static
    * @public
    * @method reset
    * @return {undefined} Returns undefined
    */
    reset: function() {
        VHS.libraries.qos.loading = false;
        VHS.libraries.qos.loaded = false;
        VHS.libraries.qos.failed = false;
        VHS.libraries.qos.firstStream = true;
        VHS.libraries.qos.activePlayerId = null;
        VHS.libraries.qos.callbacks = [];
    },

    /**
    * Queue initializion of this module when library loads globally
    *
    * @static
    * @public
    * @method queueInitialization
    * @param {Object} context The context of the function
    * @param {Function} callback The function callback
    * @return {undefined} Returns undefined
    */
    queueInitialization: function(context, callback) {
        VHS.libraries.qos.callbacks.push(
            {
                context: context,
                callback: callback
            }
        );
    },

    /**
    * Run through all the callbacks to execute once the library is loaded to initialize qos on each player
    *
    * @static
    * @public
    * @method initializePlayersForQos
    * @return {undefined} Returns undefined
    */
    initializePlayersForQos: function() {
        if (VHS.libraries.qos.callbacks.length > 0) {
            var callbackObject = VHS.libraries.qos.callbacks.pop();
            var callback = callbackObject.callback;
            var context = callbackObject.context;
            if (typeof callback === 'function' && typeof context === 'object') {
                callback.apply(context);
            }
        }
    }

};

/**
* This is a module for integrating Akamai Media Analytics.
* This was a plugin but it requires tighter integration with VHS so needs to be a module.
* There is one module instance per VHS instance
*
* @class Qos
* @module VHS.api
* @constructor
*/

VHS.api.Qos = function(player){
    this._player = player;
    this._options = player.options;
    this._logger = player.logger;

    //this.CONFIG_PATH = "http://79423.analytics.edgesuite.net/csma/configuration/CSMASampleConfiguration.xml"; //6.7kb
    //this.CONFIG_PATH = "http://ma791-r.analytics.edgesuite.net/config/beacon-8164.xml";

    // QOS VHS VOD - type: QoS_On-demand Streams
    this.CONFIG_PATH = this._options.qosConfigUrl || "http://ma800-r.analytics.edgesuite.net/config/beacon-8173.xml";
    this.SWF_PATH = "http://79423.analytics.edgesuite.net/csma/plugin/csma.swf"; //78kb
    this.JS_URL = "http://79423.analytics.edgekey.net/html5/akamaihtml5-min.js";

    // init only for HTML5 - in Flash the swf handles the lib - we cannot use QOS when multiple videos play on a page
    if (this._options.qos && this._options.mode === 'html5' && !VHS.config.allowMultiplePlayers) {
        this.initialize();
    }
};

VHS.api.Qos.prototype = {
    /**
    * Sets vars and initiates load of library or waiting for library to load
    * Private by convention, not for external use.
    *
    * @private
    * @method initialize
    * @return {undefined} Returns undefined
    */
    initialize: function() {
        // set global vars
        window.AKAMAI_MEDIA_ANALYTICS_CONFIG_FILE_PATH = this.CONFIG_PATH;

        // load library
        if (VHS.libraries.qos.loaded && !VHS.libraries.qos.loading) {
            // loaded and not loading -> init
            this.qosInitialize();
        } else if (!VHS.libraries.qos.loaded && VHS.libraries.qos.loading) {
            // not loaded, and loading -> queue init
            VHS.libraries.qos.queueInitialization(this, this.qosInitialize);
        } else {
            // not loaded, and not loading -> load
            this.loadQosLibrary();
        }
    },

    /**
    * Loads the QOS Library
    * Private by convention, not for external use.
    *
    * @private
    * @method loadQosLibrary
    * @return {undefined} Returns undefined
    */
    loadQosLibrary: function() {
        // load qos library
        var self = this;

        VHS.libraries.qos.loading = true;

        VHS.util.getScript({
            url: this.JS_URL,
            success: function(){
                VHS.libraries.qos.loaded = true;
                VHS.libraries.qos.loading = false;
                self.qosInitialize();
                VHS.libraries.qos.initializePlayersForQos();
            },
            error: function(err, errStatus, errThrown) {
                self.qosLoadLibraryErrorHandler(err, errStatus, errThrown);
            },
            timeout: 3000,
            cache: true,
            dataType: "script"
        });
    },

    /**
    * Initialize QOS for this player
    *
    * @public
    * @method qosInitialize
    * @return {undefined} Returns undefined
    */
    qosInitialize: function() {
        var self = this;
        var onRenderedSetupQos;

        // bind to player events
        this._player.on(VHS.api.events.LOAD_START, $.proxy(this.onLoadStart, this));

        this._player.on(VHS.api.events.AD_STARTED, $.proxy(this.onAdStarted, this));
        this._player.on(VHS.api.events.AD_COMPLETED, $.proxy(this.onAdCompleted, this));
        this._player.on(VHS.api.events.AD_SKIPPED, $.proxy(this.onAdSkipped, this));
        this._player.on(VHS.api.events.AD_STOPPED, $.proxy(this.onAdStopped, this));

        this._player.on(VHS.api.events.AD_FIRST_QUARTILE, $.proxy(this.onAdFirstQuartile, this));
        this._player.on(VHS.api.events.AD_MIDPOINT, $.proxy(this.onAdMidpoint, this));
        this._player.on(VHS.api.events.AD_THIRD_QUARTILE, $.proxy(this.onAdThirdQuartile, this));
        this._player.on(VHS.api.events.AD_ERROR, $.proxy(this.onAdError, this));


        // set player level parameters
        this.setPlayerData();

        onRenderedSetupQos = function() {
            if (self._player.options.autoplay) {
                self.setVideoData();
                VHS.libraries.qos.firstStream = false;
            }
            self.setVideoTag();
            self.tagVideoAsNoAd();
        };

        // set video tag
        if (this._player.rendered) {
            onRenderedSetupQos();
        } else {
            this._player.on(VHS.api.events.RENDERED, function onRenderedPlayerForQos() {
                onRenderedSetupQos();
                self._player.off(VHS.api.events.RENDERED, onRenderedPlayerForQos);
            });
        }
    },

    /**
    * Handle QOS library load error
    * Private by convention, not for external use.
    *
    * @private
    * @method qosLoadLibraryErrorHandler
    * @param {Object} err jqXHR error object
    * @param {String} errStatus A string describing the type of error. "timeout", "error", "abort", and "parsererror"
    * @param {String} errThrown A string representing the error thrown. "Not Found" or "Internal Server Error."
    * @return {undefined} Returns undefined
    */
    qosLoadLibraryErrorHandler: function(err, errStatus, errThrown) {
        // library failed to load
        // log to event tracker
        if (this._player && typeof this._player.trigger === 'function') {
            this._player.trigger(VHS.api.events.TRACKING_EVENT, {
                data: {
                    name: "qos-library-load-failure",
                    errorStatus: errStatus || '',
                    errorThrown: errThrown || ''
                }
            });
        }

        VHS.libraries.qos.loading = false;
        VHS.libraries.qos.loaded = false;
        VHS.libraries.qos.failed = true;

        // loop through all players on page and turn qos off if qos fails to load
        for (var i in window.vhs_instances) {
            if (window.vhs_instances.hasOwnProperty(i) && window.vhs_instances[i].options) {
                window.vhs_instances[i].options.qos = false;
            }
        }
    },

    /**
    * Handles load start of the media from the player.  So right before the play...
    * This sets/resets the in focus video object and tells akamai a new stream is starting
    * Private by convention, not for external use.
    *
    * @private
    * @method onLoadStart
    * @return {undefined} Returns undefined
    */
    onLoadStart: function() {
        // reset video tag if player switched
        if (VHS.libraries.qos.activePlayerId !== this._player.instanceId) {
            this.setVideoTag();
        }

        if (!VHS.libraries.qos.firstStream && typeof window.akamaiHandleStreamSwitch === 'function') {
            window.akamaiHandleStreamSwitch();
        }
        VHS.libraries.qos.firstStream = false;

        // set data should come after switch stream call
        this.setVideoData();
    },

    /**
    * Handles calling akamai function for ad start event from player
    * Private by convention, not for external use.
    *
    * @private
    * @method onAdStarted
    * @return {undefined} Returns undefined
    */
    onAdStarted: function() {
        this.tagVideoAsAd();
        this.onAdLoaded();
        if (typeof window.akamaiHandleAdStarted === 'function') {
            window.akamaiHandleAdStarted();
        }
    },

    /**
    * Handles calling akamai function for ad complete event from player
    * Private by convention, not for external use.
    *
    * @private
    * @method onAdCompleted
    * @return {undefined} Returns undefined
    */
    onAdCompleted: function() {
        this.tagVideoAsNoAd();
        if (typeof window.akamaiHandleAdCompleted === 'function') {
            window.akamaiHandleAdCompleted();
        }
    },

    /**
    * Handles calling akamai function for ad skipped event from player
    * Private by convention, not for external use.
    *
    * @private
    * @method onAdSkipped
    * @return {undefined} Returns undefined
    */
    onAdSkipped: function() {
        this.tagVideoAsNoAd();
        if (typeof window.akamaiHandleAdStopped === 'function') {
            window.akamaiHandleAdStopped();
        }
    },

    /**
    * Handles calling akamai function for ad stopped event from player
    * Private by convention, not for external use.
    *
    * @private
    * @method onAdStopped
    * @return {undefined} Returns undefined
    */
    onAdStopped: function() {
        this.tagVideoAsNoAd();
        if (typeof window.akamaiHandleAdStopped === 'function') {
            window.akamaiHandleAdStopped();
        }
    },

    /**
    * Handles calling akamai function for ad first quartile event from player
    * Private by convention, not for external use.
    *
    * @private
    * @method onAdFirstQuartile
    * @return {undefined} Returns undefined
    */
    onAdFirstQuartile: function() {
        if (typeof window.akamaiHandleAdFirstQuartile === 'function') {
            window.akamaiHandleAdFirstQuartile();
        }
    },

    /**
    * Handles calling akamai function for ad midpoint event from player
    * Private by convention, not for external use.
    *
    * @private
    * @method onAdMidpoint
    * @return {undefined} Returns undefined
    */
    onAdMidpoint: function() {
        if (typeof window.akamaiHandleAdMidpoint === 'function') {
            window.akamaiHandleAdMidpoint();
        }
    },

    /**
    * Handles calling akamai function for ad third quartile event from player
    * Private by convention, not for external use.
    *
    * @private
    * @method onAdThirdQuartile
    * @return {undefined} Returns undefined
    */
    onAdThirdQuartile: function() {
        if (typeof window.akamaiHandleAdThirdQuartile === 'function') {
            window.akamaiHandleAdThirdQuartile();
        }
    },

    /**
    * Handles calling akamai function for ad error event from player
    * Private by convention, not for external use.
    *
    * @private
    * @method onAdError
    * @param {Object} evt error event object
    * @return {undefined} Returns undefined
    */
    onAdError: function(evt) {
        if (typeof window.akamaiHandleAdError === 'function') {
            window.akamaiHandleAdError();
        }
    },

    /**
    * Handles setting up akamai for ad loaded. Called from this.onAdStarted handler
    * Private by convention, not for external use.
    *
    * @private
    * @method onAdLoaded
    * @return {undefined} Returns undefined
    */
    onAdLoaded: function() {
        var adObject = {};
        adObject["adTitle"] = this._player.getAdTitle();
        adObject["adDuration"] = this._player.adDuration();
        if (typeof window.akamaiHandleAdLoaded === 'function') {
            window.akamaiHandleAdLoaded(adObject);
        }
    },

    /**
    * Sets the data attribute on the video tag to isad true.
    * Called from this.onAdStarted handler
    * Private by convention, not for external use.
    *
    * @private
    * @method tagVideoAsAd
    * @return {undefined} Returns undefined
    */
    tagVideoAsAd: function() {
        if (this._player && this._player.element) {
            this._player.element.attr('data-isad', true);
        }
    },

    /**
    * Sets the data attribute on the video tag to isad false.
    * Called from this.onAdStarted, this.onAdComplete, this.onAdSkipped, this.onAdStopped and
    * when the player video tag is rendered
    * Private by convention, not for external use.
    *
    * @private
    * @method tagVideoAsNoAd
    * @return {undefined} Returns undefined
    */
    tagVideoAsNoAd: function() {
        if (this._player && this._player.element) {
            this._player.element.attr('data-isad', false);
        }
    },

    /**
    * Sets the video tag for akamai object.
    * Private by convention, not for external use.
    *
    * @private
    * @method setVideoTag
    * @return {undefined} Returns undefined
    */
    setVideoTag: function() {
        if (this._player && this._player.element && this._player.element[0] && typeof window.akamaiSetVideoObject === 'function') {
            window.akamaiSetVideoObject(this._player.element[0]);
            VHS.libraries.qos.activePlayerId = this._player.instanceId;
        }
    },

    /**
    * Sets the player video meta data
    * Private by convention, not for external use.
    *
    * @private
    * @method setPlayerData
    * @return {undefined} Returns undefined
    */
    setPlayerData: function() {
        if (typeof window.setAkamaiMediaAnalyticsData === 'function') {
            window.setAkamaiMediaAnalyticsData('mode', this._options.mode);
            window.setAkamaiMediaAnalyticsData('autoplay', this._options.autoplay);
            window.setAkamaiMediaAnalyticsData('version', VHS._version);
            window.setAkamaiMediaAnalyticsData('playerId', this._player.getPlayerType());

            if (this._options.live === true) {
                window.setAkamaiMediaAnalyticsData("deliveryType", "L");
            } else {
                window.setAkamaiMediaAnalyticsData("deliveryType", "O");
            }
        }
    },

    /**
    * Sets the video content meta data
    * Private by convention, not for external use.
    *
    * @private
    * @method setVideoData
    * @return {undefined} Returns undefined
    */
    setVideoData: function() {
        if (typeof window.setAkamaiMediaAnalyticsData === 'function') {
            window.setAkamaiMediaAnalyticsData('title', this._player.getTitle());
            window.setAkamaiMediaAnalyticsData('contentLength', this._player.getDuration());
            window.setAkamaiMediaAnalyticsData('category', this._player.getCategory());
            window.setAkamaiMediaAnalyticsData('videoId', this._player.getVideoId());
        }
    }

};

/**
* Global config for feature flags for VHS.
* All instances of VHS will use this feature flag config setup
*
* For usage see: https://confluence.em.nytimes.com/display/VID/VHS+-+Feature+Flags
*
* NOTE: Feature names are case-sensitive
*
* @module VHS.configs.features
*
*/

VHS.configs.features = {
    "test-feature": {
        "environments": {
            "production": false,
            "staging": false,
            "development": true,
            "localhost": true
        }
    },
    "flash-hd-switch-seek": {
        "environments": {
            "production": true,
            "staging": true,
            "development": true,
            "localhost": true
        }
    },
    "poster-image-select": {
        "ticket": "https://jira.nyt.net/browse/VR-6438",
        "environments": {
            "production": true,
            "staging": true,
            "development": true,
            "localhost": true
        }
    }
};

/**
* Front End Feature Flags for VHS.
* We had to create our own feature flags implementation since the Web Products version was reliant on a backend integration.
* We also wanted to avoid collision since the host app will have its own feature flags, then vhs will have its own set.
*
* Usage:
* instantiate:
*   this.modules.features = new VHS.api.FeatureFlags(this);
* use:
*   this.modules.features.isEnabled('testFeature');
*
* @class FeatureFlags
* @module VHS.api
* @constructor
*/
VHS.api.FeatureFlags = function(player){
    this._player = player;
    this._options = player.options;
    this._logger = player.logger;

    this.config = VHS.configs.features || {};
};

VHS.api.FeatureFlags.prototype = {

    /**
     * Returns boolean whether this feature is on or off (true/false)
     *
     * @method isEnabled
     * @param {String} name The name of the feature in the config.
     * @return {Boolean} true if on, false if off
     */
    isEnabled: function(name) {
        var featureOn = false;
        if (name in this.config) {
            try {
                featureOn = this.config[name].environments[this._options.env];
            } catch (e) {
                this._logger.warn("feature flags: config for feature '" + name +
                    "' in env '" + this._options.env + "' is missing or malformed");
            }

            // fail safe
            if (typeof featureOn !== 'boolean') {
                featureOn = false;
            }
        }
        return featureOn;
    }

};

/**
@class Controls
@module VHS.api
@constructor
**/
VHS.api.Controls = function(player){
    var element = [
        '<div class="nytd-player-controls">',
            '<span class="nytd-player-controls-play vhs-icon-play"></span>',
            '<span class="nytd-player-controls-reload vhs-icon-reload"></span>',
            '<span class="nytd-player-controls-exclamation vhs-icon-exclamation"></span>',
            '<div class="nytd-player-controls-ad-label">Advertisement</div>',
            '<div class="nytd-player-controls-live-label">LIVE</div>',
            '<div class="nytd-player-controls-error-msg">Error</div>',
            '<div class="nytd-player-controls-current-time">00:00</div>',
            '<div class="nytd-player-controls-progress">',
                '<span class="nytd-player-controls-progress-marker vhs-icon-circle"></span>',
                '<span class="nytd-player-controls-progress-time"></span>',
                '<span class="nytd-player-controls-progress-buffer"></span>',
                '<span class="nytd-player-controls-progress-scrubber"></span>',
            '</div>',
            '<span class="nytd-player-controls-fullscreen vhs-icon-resize-full"></span>',
            '<span class="nytd-player-controls-volume vhs-icon-volume-up"></span>',
            '<span class="nytd-player-controls-hd vhs-icon-hd-off"></span>',
            '<div class="nytd-player-controls-duration">00:00</div>',
        '</div>'
    ].join('');

    this.player = player;
    this.rendered = false;
    this.seeking = false;
    this.draggingMarker = false;
    this.mouseoverContainer = true;
    this.controlsVisible = false;
    this.element = $(element);
    this.device = VHS.util.getDeviceType();
    this.live = (this.player && this.player.options && this.player.options.live) ? true : false;
    this.touchedControls = false;
};

VHS.api.Controls.prototype = {
    initialize: function(){
        this.render();
        this.registerUI();
        this.actions();
        this.listeners();
        if (this.live) {
            this.configureLive();
        }
    },
    render: function() {
        if (this.rendered || this.device === 'android_legacy' || this.device === 'ie_mobile') {
            return false;
        }
        this.player.container.append(this.element);
        this.rendered = true;
        this.controlsVisible = true;
    },
    registerUI: function(){
        this.ui = {
            "play": this.element.find('.nytd-player-controls-play'),
            "reload": this.element.find('.nytd-player-controls-reload'),
            "fullscreen": this.element.find('.nytd-player-controls-fullscreen'),
            "volume": this.element.find('.nytd-player-controls-volume'),
            "progress": this.element.find('.nytd-player-controls-progress'),
            "marker": this.element.find('.nytd-player-controls-progress-marker'),
            "progressBuffer": this.element.find('.nytd-player-controls-progress-buffer'),
            "progressTime": this.element.find('.nytd-player-controls-progress-time'),
            "duration": this.element.find('.nytd-player-controls-duration'),
            "current": this.element.find('.nytd-player-controls-current-time'),
            "errormsg": this.element.find('.nytd-player-controls-error-msg'),
            "hd": this.element.find('.nytd-player-controls-hd')
        };
    },
    actions: function() {
        var self = this;

        this.ui.play.on('click', function(e){
            self.player.togglePlay();
            if (self.player.isTouch) {
                e.preventDefault();
                e.stopPropagation();
            }
        });

        this.ui.reload.on('click', function(e){
            self.player.reloadVideo();
            /**
             *  Fix for strange flash behaviour where VIDEO_READY event not being triggered
             *  Reproduce by blocking access to the src video then trying to play it then hitting
             *  the reload button. The video will not load but the error message will not
             *  appear again without the below call.
             */
            if (!self.live) {
                self.player.play();
            }

            if (self.player.isTouch) {
                e.preventDefault();
                e.stopPropagation();
            }
        });

        this.ui.fullscreen.on('click', function(e){
            self.player.toggleFullscreen();
            if (self.player.isTouch) {
                e.preventDefault();
                e.stopPropagation();
            }
        });

        if (!VHS.util.supportsFullscreen()) {
            this.ui.fullscreen.addClass('vhs-icon-disabled');
            this.ui.fullscreen.off();
        }

        this.ui.volume.on('click', function(e){
            self.player.toggleVolume();
            if (self.player.isTouch) {
                e.preventDefault();
                e.stopPropagation();
            }
        });

        this.ui.marker.on('click', function(e){
            e.preventDefault();
            e.stopPropagation();
        });

        this.ui.progress.on('mousedown touchstart', function(e){
            e.stopPropagation();
            self.draggingMarker = true;
        });

        this.ui.progress.on('touchstart click', function(e){
            e.preventDefault();
            e.stopPropagation();
            self.seek(e);
        });

        this.ui.hd.on('click', function(e){
            e.preventDefault();
            e.stopPropagation();
            if (self.player.status === VHS.api.status.VIDEO_PLAYING || self.player.status === VHS.api.status.VIDEO_PAUSED) {
                self.player.toggleHD(e);
                self.setHDIconState();
            }
        });

        $(document).on('mouseup touchend', $.proxy(this.onDocumentMouseup, this));
        $(document).on('mousemove touchmove', $.proxy(this.onDocumentMousemove, this));

        // only for jquery, not Zepto
        if (VHS.util.jqueryInUse()) {
            this.element.hover(function(){
                self.element.addClass('nytd-player-controls-hover');
            },function(){
                self.element.removeClass('nytd-player-controls-hover');
            });
        }
    },
    listeners: function() {
        this.player.on(VHS.api.events.PLAY, $.proxy(this.onPlay, this));
        this.player.on(VHS.api.events.PLAYING, $.proxy(this.onPlay, this));
        this.player.on(VHS.api.events.ENDED, $.proxy(this.onEnded, this));
        this.player.on(VHS.api.events.LEVEL_ENDLIST, $.proxy(this.hlsEndListFound, this));
        this.player.on(VHS.api.events.AD_COMPLETED, $.proxy(this.onAdCompleted, this));
        this.player.on(VHS.api.events.AD_PAUSED, $.proxy(this.onAdPaused, this));
        this.player.on(VHS.api.events.AD_RESUMED, $.proxy(this.onAdResumed, this));
        this.player.on(VHS.api.events.AD_STARTED, $.proxy(this.onAdStarted, this));
        this.player.on(VHS.api.events.AD_TIME_UPDATE, $.proxy(this.onAdTimeUpdate, this));
        this.player.on(VHS.api.events.AD_SKIPPED, $.proxy(this.onAdSkipped, this));
        this.player.on(VHS.api.events.AD_STOPPED, $.proxy(this.onAdStopped, this));
        this.player.on(VHS.api.events.PAUSE, $.proxy(this.onPause, this));
        this.player.on(VHS.api.events.MUTE, $.proxy(this.onMute, this));
        this.player.on(VHS.api.events.DURATION_CHANGE, $.proxy(this.onDurationChange, this));
        this.player.on(VHS.api.events.TIME_UPDATE, $.proxy(this.onTimeupdate, this));
        this.player.on(VHS.api.events.GO_FULLSCREEN, $.proxy(this.onEnterFullscreen, this));
        this.player.on(VHS.api.events.EXIT_FULLSCREEN, $.proxy(this.onExitFullscreen, this));
        this.player.on(VHS.api.events.ERROR, $.proxy(this.onError, this));
        this.player.on(VHS.api.events.LOAD_START, $.proxy(this.onLoadStart, this));
        this.player.on(VHS.api.events.PROGRESS, $.proxy(this.onProgress, this));
        this.player.on(VHS.api.events.VIDEO_FLASH_BYTES_LOADED_CHANGE, $.proxy(this.onVideoFlashBytesLoadedChange, this));

        // user interaction listeners
        // more information here on how to deal with mouse and touch events together
        // - http://www.html5rocks.com/en/mobile/touchandmouse/
        this.player.container.on('touchend', $.proxy(this.onTouchEndVideo, this));
        this.element.on('touchend', $.proxy(this.onTouchEndControls, this));
        this.player.container.on('mouseenter', $.proxy(this.onMouseEnterVideo, this));
        this.player.container.on('mouseleave', $.proxy(this.onMouseLeaveVideo, this));
        this.player.container.on('mousemove', $.proxy(this.onMouseMoveVideo, this));
        this.element.on('mouseenter', $.proxy(this.onMouseEnterControls, this));
        this.element.on('mouseleave', $.proxy(this.onMouseLeaveControls, this));
    },
    configureLive: function(){
        this.element.addClass('nytd-player-live-controls');
        this.element.addClass('withouthd');
    },
    configureVOD: function(){
        this.element.removeClass('nytd-player-live-controls');
        this.renderHdButton(this.player._data && this.player._data.renditions && !this.player.options.live);
    },
    hlsEndListFound: function() {
        this.configureVOD();
    },
    onMouseEnterVideo: function() {
        this.mouseoverContainer = true;
        this.show();
        // start fade out timer if we are not hovering over the controls
        if (!this.element.hasClass('nytd-player-controls-hover')) {
            this.startFadeOutTimer();
        }
    },
    onMouseLeaveVideo: function() {
        this.mouseoverContainer = false;

        if (this.player.status !== VHS.api.status.VIDEO_PAUSED && this.player.status !== VHS.api.status.AD_PAUSED) {
            //hide right away if video is playing
            this.hide();
        } else if (this.device === 'desktop') {
            //if desktop and paused, hide after given time
            this.startFadeOutTimer(2000, true);
        }
    },
    onMouseMoveVideo: function() {
        if (this.mouseoverContainer && !this.controlsVisible) {
            this.show();
            // start fade out timer if we are not hovering over the controls
            if (!this.element.hasClass('nytd-player-controls-hover')) {
                this.startFadeOutTimer();
            }
        }
    },
    onMouseEnterControls: function() {
        clearInterval(this.controlsHideTimeout);
    },
    onMouseLeaveControls: function() {
        if (this.mouseoverContainer && this.controlsVisible) {
            this.startFadeOutTimer();
        }
    },
    onTouchEndVideo: function(e) {
        // do not execute if the user touched the controls
        if (!this.touchedControls) {
            // prevent propagation to mouse events since we have listeners for both
            e.preventDefault();
            if (this.player.adPlaying()) {
                // show controls
                this.show();
            } else {
                if (this.controlsVisible) {
                    this.startFadeOutTimer(100);
                } else {
                    this.show();
                    this.startFadeOutTimer();
                }
            }
            // propagate click to element in video clicked (poster)
            $(e.target).click();
        }
        this.touchedControls = false;
    },
    onTouchEndControls: function(e) {
        // prevent propagation to mouse events since we have listeners for both
        e.preventDefault();
        // set flag so we do not execute onTouchEndVideo
        this.touchedControls = true;
        this.show();
        if (!this.player.adPlaying()) {
            this.startFadeOutTimer();
        }
        // propagate click to element in controls clicked
        $(e.target).click();
    },
    onPlay: function(){
        this.player.status = VHS.api.status.VIDEO_PLAYING;
        this.ui.play
            .addClass('vhs-icon-pause')
            .removeClass('vhs-icon-play');
        this.hideErrorSlate();
        this.setHDIconState();
        this.startFadeOutTimer(300); //in case play used without mouse hover (i.e. keyboard)
    },
    onEnded: function(){
        this.player.status = VHS.api.status.VIDEO_ENDED;
        this.ui.play
            .addClass('vhs-icon-play')
            .removeClass('vhs-icon-pause');
        // live only ends when the video stream is down for HTML5
        if (this.live && this.player.getType() === 'html5') {
            this.configureVOD();
        }
        this.show();
    },
    onAdCompleted: function(){
        this.element
            .removeClass('nytd-player-ad-controls');

        this.ui.hd.removeClass('vhs-icon-hd-disabled');
        this.ui.play
            .removeClass('vhs-icon-pause')
            .addClass('vhs-icon-play');

        if (this.player.isTouch) {
            this.hide();
        }
    },
    onAdPaused: function(){
        this.player.status = VHS.api.status.AD_PAUSED;
        this.ui.play
            .removeClass('vhs-icon-pause')
            .addClass('vhs-icon-play');
        this.show();
    },
    onAdResumed: function(){
        this.player.status = VHS.api.status.AD_PLAYING;
        this.ui.play
            .addClass('vhs-icon-pause')
            .removeClass('vhs-icon-play');
        this.startFadeOutTimer(300); //in case play used without mouse hover (i.e. keyboard)
    },
    onAdStarted: function(){
        this.player.status = VHS.api.status.AD_PLAYING;
        this.element
            .addClass('nytd-player-ad-controls');
        this.ui.hd.addClass('vhs-icon-hd-disabled');

        this.ui.play
            .addClass('vhs-icon-pause')
            .removeClass('vhs-icon-play');

        if (this.player.poster) {
            this.player.poster.hide();
        }

        if (this.player.isTouch) {
            this.show();
        }
    },
    onAdSkipped: function() {
        this.element
            .removeClass('nytd-player-ad-controls');
        this.ui.hd.removeClass('vhs-icon-hd-disabled');

        if (this.player.isTouch) {
            this.hide();
        }
    },
    onAdStopped: function() {
        this.element
            .removeClass('nytd-player-ad-controls');
        this.ui.hd.removeClass('vhs-icon-hd-disabled');

        if (this.player.isTouch) {
            this.hide();
        }
    },
    onPause: function(data) {
        if (typeof data === 'object' && data.playingOverlayAd === true) {
            this.player.status = VHS.api.status.AD_OVERLAY_ACTIVE;
        }

        this.ui.play
            .addClass('vhs-icon-play')
            .removeClass('vhs-icon-pause');
        this.show();
    },
    onMute: function(muted) {
        if (muted) {
            this.ui.volume
                .addClass('vhs-icon-volume-off')
                .removeClass('vhs-icon-volume-up');
        } else {
            this.ui.volume
                .addClass('vhs-icon-volume-up')
                .removeClass('vhs-icon-volume-off');
        }
    },
    onEnterFullscreen: function() {
        //if iPad hide the controls and enable nativeControls
        if (VHS.util.isIpad()) {
            this.hide(true);
            this.player.element.attr('controls', 'controls');
        }

        this.ui.fullscreen
            .addClass('vhs-icon-resize-default')
            .removeClass('vhs-icon-resize-full');
    },
    onExitFullscreen: function() {
        //if iPad hide the controls and disable nativeControls
        if (VHS.util.isIpad()) {
            this.show();
            this.player.element.removeAttr('controls');
        }

        this.ui.fullscreen
            .addClass('vhs-icon-resize-full')
            .removeClass('vhs-icon-resize-default');
    },
    onError: function(evt) {
        this.player.logger.error('!!! Error Event', evt);
        if (this.live) {
            this.showLiveStreamDownMsg(evt);
        } else {
            this.showVodErrorMsg(evt);
        }
    },
    onLoadStart: function() {
        this.hideErrorSlate();
    },
    onDurationChange: function(t) {
        var time = parseInt(t, 10);
        this.ui.duration.html(this.formatTime(time));
    },
    onTimeupdate: function(time) {
        if (!this.seeking) {
            this.updateProgressUI(time);
        }
    },
    onAdTimeUpdate: function(time){
        var remain = this.player.adDuration() - time;
        var formatedRemain = this.formatTime(remain);

        this.ui.duration.html(formatedRemain);
        if (this.player.options.skipAd) {
            this.player.skipAdUpdate(remain);
        }
    },
    onDocumentMousemove: function(e) {
        var pageX;
        var markerPositionXInitial;
        var markerPositionXFinal;
        var time;

        if (this.draggingMarker && this.player && typeof this.player.duration === 'function') {
            markerPositionXInitial = 0;
            markerPositionXFinal = 0;
            time = 0;

            if (this.player.isTouch && e && e.originalEvent && e.originalEvent.touches) {
                pageX = e.originalEvent.touches[0].pageX || e.originalEvent.changedTouches[0].pageX;
            } else {
                pageX = e.pageX;
            }

            markerPositionXFinal = (this.ui.progress.offset().left - pageX) * -1;

            if (markerPositionXInitial < markerPositionXFinal && markerPositionXFinal < this.ui.progress.width()) {
                time = (this.player.duration() * markerPositionXFinal) / this.ui.progress.width();
            } else if (markerPositionXFinal >= this.ui.progress.width()) {
                time = this.player.duration();
            }

            this.player.seek(time);
            this.updateProgressUI(time);
            this.seeking = true;
        }
    },
    onDocumentMouseup: function(){
        var self = this;
        this.draggingMarker = false;

        setTimeout(function(){
            self.seeking = false;
        }, 500);
    },
    /**
    * Progress handler for how much of the video has buffered
    * Only used in an HTML5 video element
    * Event: VHS.api.events.PROGRESS
    *
    * @method onProgress
    * @param {Object} e An event object
    */
    onProgress: function(e) {
        var bufferWidth = 0;
        var bufferTime = 0;
        if (this.player && this.player.element && this.player.element[0] && this.player.element[0].buffered && this.player.element[0].buffered.end) {
            try {
                var lastIndex = this.player.element[0].buffered.length-1;
                if (lastIndex >= 0) {
                    bufferTime = this.player.element[0].buffered.end(lastIndex);
                }
            } catch (err) {
                this.player.logger.error('error getting the buffer from the video element', err);
            }
        }

        bufferWidth = this.getTimePosition(bufferTime);
        this.ui.progressBuffer.css({'width': bufferWidth + "%"});
    },
    /**
    * Progress handler for how much of the video has loaded (bytesloaded)
    * Only used for Flash video element
    * Event: VHS.api.events.VIDEO_FLASH_BYTES_LOADED_CHANGE
    *
    * @method onVideoFlashBytesLoadedChange
    * @param {Object} e An event object. example evt obj: {data: {bytesloaded: 0, bytestotal: 5}}
    */
    onVideoFlashBytesLoadedChange: function(e) {
        var bytesloaded = (e && e.data && e.data.bytesloaded) ? e.data.bytesloaded : 0;
        var bytestotal = (e && e.data && e.data.bytestotal) ? e.data.bytestotal : 0;
        var bufferPercent = (bytestotal > 0) ? Math.round((bytesloaded / bytestotal) * 100) : 0;
        this.ui.progressBuffer.css({'width': bufferPercent+'%'});
    },
    show: function() {
        var fadeArgs = [400, 1];
        this.player.logger.log('controls show');
        clearInterval(this.controlsHideTimeout);
        this.controlsVisible = true;
        if (VHS.util.jqueryInUse()) {
            // desktop
            this.element.stop(true, false).fadeTo(fadeArgs[0], fadeArgs[1]);
        } else {
            // mobile
            this.element.css({'opacity': fadeArgs[1]});
        }

        this.player.trigger(VHS.api.events.SHOW_CONTROLS, { fadeArgs: fadeArgs });
    },
    hide: function(forceHide) {
        var fadeArgs = [400, 0];
        this.player.logger.log('controls hide');
        if (!this.player.firstPlay || forceHide) {
            var self = this;
            if (VHS.util.jqueryInUse()) {
                // desktop
                this.element.stop(true, false).fadeTo(fadeArgs[0], fadeArgs[1], function(){
                    self.controlsVisible = false;
                });
            } else {
                // mobile
                this.element.css({'opacity': fadeArgs[1]});
                this.controlsVisible = false;
            }

            this.player.trigger(VHS.api.events.HIDE_CONTROLS, { fadeArgs: fadeArgs });
        }
    },
    startFadeOutTimer: function(time, override) {
        override = override || false; //overides anything preventing the timer

        //disable if in paused state
        if (!override && this.player.status === VHS.api.status.VIDEO_PAUSED || this.player.status === VHS.api.status.AD_PAUSED) {
            return false;
        }

        this.player.logger.log('controls startFadeOutTimer');
        var timeoutTime = time || 6000;
        var self = this;
        clearInterval(this.controlsHideTimeout);
        this.controlsHideTimeout = setTimeout(function(){
                self.hide();
        }, timeoutTime);
    },
    seek: function(e) {
        var pageX = 0;
        if (this.player.isTouch) {
            pageX = e.originalEvent.touches[0].pageX || e.originalEvent.changedTouches[0].pageX;
        } else {
            pageX = e.pageX;
        }

        var markerPositionXFinal = (this.ui.progress.offset().left - pageX) * -1;
        var time = Math.round((this.player.duration() * markerPositionXFinal) / this.ui.progress.width());

        this.player.seek(time);
        this.updateProgressUI(time);
    },
    formatTime: function(time) {
        var currentTime, minutes, seconds;

        currentTime = parseInt(time, 10);
        if (currentTime < 0) {
            currentTime = 0;
        }

        minutes = Math.floor(currentTime / 60);
        seconds = currentTime - (minutes * 60);

        if (minutes < 10) {
            minutes = '0' + minutes;
        }

        if (seconds < 10) {
            seconds = '0' + seconds;
        }

        return minutes + ':' + seconds;
    },
    /**
     * returns the position as a percentage of
     * the `time` value relative to the overall video
     * duration
     * @param  {Number} time time in seconds
     * @return {Number}      percentage based of the total video duration
     */
    getTimePosition: function(time) {
        var position = time / this.player.duration() * 100;
        return parseFloat(position.toFixed(2));
    },
    updateProgressUI: function(time) {
        var markerRelative;
        var position = this.getTimePosition(time);
        this.ui.progressTime.css({'width': position + "%"});
        markerRelative = (this.ui.progressTime.width() - 9) / this.ui.progress.width() * 100;
        this.ui.marker.css({'left': markerRelative.toFixed(2) + "%" });
        this.ui.current.html(this.formatTime(time));
    },
    onSourceError: function() {
        //determine if all sources failed
        if (!this.live && this.player.element[0].networkState === 3) { //NETWORK_NO_SOURCE
            this.player.trigger(VHS.api.events.ERROR, {error: { code: 203, msg: 'NETWORK_NO_SOURCE: All video sources unavailable.'}});
        }
    },
    /**
    * Show the live stream down error message based on either the error or
    * the generic if the stream ended.
    *
    * @method showLiveStreamDownMsg
    * @param {Object} evt A event object
    */
    showLiveStreamDownMsg: function(evt) {
        var error = (this.player.element && this.player.element[0]) ? this.player.element[0].error : null;
        var errMsg = VHS.util.getErrorMessage(error);

        this.element.addClass('nytd-player-error-controls');
        this.ui.errormsg.html(errMsg);

        // check if this stream format is not-supported in the browser.  if so do not show the reload button.
        if (error && error.code && error.code === error.MEDIA_ERR_SRC_NOT_SUPPORTED) {
            if (this.player && this.player.element[0] && this.player.element[0].canPlayType('application/x-mpegURL') === "") {
                this.element.addClass('nytd-player-error-not-supported');
            }
        }
    },
    showVodErrorMsg: function(evt) {
        //evt is required
        if (!evt) {
            return;
        }

        var error = evt.currentTarget ? evt.currentTarget.error : evt.error;
        var canPlay = true;
        var errorMsg;

        //add the error controls to dom and update text
        this.element.addClass('nytd-player-error-controls');

        // check if this stream format is not-supported in the browser.  if so do not show the reload button.
        if (this.player.options.mode === 'html5' && error && error.code && error.code === error.MEDIA_ERR_SRC_NOT_SUPPORTED) {
            //BUG: video type should be that of the source, not hardcoded. Will fix in another ticket
            if (this.player && this.player.element[0] && this.player.element[0].canPlayType('video/mp4') === "") {
                this.element.addClass('nytd-player-error-not-supported');
                canPlay = false;
            }
        }

        errorMsg = VHS.util.getErrorMessage(error, 'vod', canPlay);
        this.ui.errormsg.html(errorMsg);

        //show the controls to make more clear to user
        this.show();
    },
    /**
    * Hide the error slate on the controls
    *
    * @method hideErrorSlate
    */
    hideErrorSlate: function() {
        this.element.removeClass('nytd-player-error-controls');
        this.element.removeClass('nytd-player-error-not-supported');
        this.ui.errormsg.html("");
    },
    renderHdButton: function (isVisible) {
        if (isVisible) {
            this.element.removeClass('withouthd');
        } else {
            this.element.addClass('withouthd');
        }
    },
    setHDIconState: function () {
        if (this.player.enableHD) {
            this.ui.hd.addClass('vhs-icon-hd-on');
        } else {
            this.ui.hd.removeClass('vhs-icon-hd-on');
        }
    }
};

/**
@class Fullscreen
@module VHS.api
@constructor
**/
VHS.api.Fullscreen = function(player){
    this.player = player;
    this.listeners();
};

VHS.api.Fullscreen.prototype = {
    /**
     * a instance only has permission to handle to
     * fullscreen events when this flag is set
     * @type {Boolean}
     */
    _permissionGranted: false,
    _isFullscreen: false,
    _resizeProxy: null,
    listeners: function(){
        var self = this;
        this._resizeProxy = $.proxy(this.onVHSFullscreenResize, this);
        $(document).on("webkitfullscreenchange mozfullscreenchange fullscreenchange MSFullscreenChange vhsfullscreenchange", $.proxy(this.onFullscreenChange, this));
        $(window).on('keydown', $.proxy(this.onEscKey, this));
    },
    _canRequestFullScreen: function(element) {
        var el = element || document.createElement('video');
        var isSupported = function(elem, feature) {
            return typeof elem[feature] === 'function';
        };

        return isSupported(el, 'requestFullscreen') ||
            isSupported(el, 'webkitRequestFullscreen') ||
            isSupported(el, 'webkitEnterFullScreen') ||
            isSupported(el, 'mozRequestFullScreen') ||
            isSupported(el, 'msRequestFullscreen');
    },
    /**
     * when the player enters or leaves fullscreen update the state and fire events
     * @return {Undefined}
     */
    onFullscreenChange: function() {
        if (!this.getPermission()) return;
        var container = this.player.container;
        var ratioFixApplied = container.data('ratioFix');

        //using native fullscreen for ipad
        if (VHS.util.isIpad()) {
            if (this.isEnabled()) {
                this.player.trigger(VHS.api.events.GO_FULLSCREEN);
            } else {
                this.player.trigger(VHS.api.events.EXIT_FULLSCREEN);
                this.setPermission(false);
            }
            return false; //returning false for tests
        }

        if (this.isEnabled()) {
            this.player.trigger(VHS.api.events.GO_FULLSCREEN);
            container.width($(document).width());
        } else {
            this.player.trigger(VHS.api.events.EXIT_FULLSCREEN);
            container.css({
                height: ratioFixApplied ? 0: VHS.util.normalizeUnit(this.player.options.height),
                width: VHS.util.normalizeUnit(this.player.options.width)
            });
            this.setPermission(false);
        }
    },
    /**
     * Maintains the aspect ratio of the video when vhs
     * is fullscreen within the browser window
     * @return {Undefined}
     */
    onVHSFullscreenResize: function () {
        if (!this.getPermission()) return;
        var rect = this.computePlayerRect();
        var css = {
            "width": VHS.util.normalizeUnit(rect.width),
            "height": VHS.util.normalizeUnit(rect.height),
            "left": VHS.util.normalizeUnit(rect.left),
            "top": VHS.util.normalizeUnit(rect.top),
            "padding-bottom": 0
        };

        this.player.container.css(css);
    },
    /**
     * calculates the required css for the player
     * to be rendered using a 16 by 9 ratio
     * @return {Object} properties are width, height, left, and top
     */
    computePlayerRect: function () {
        var height = $(window).height();
        var width = $(window).width();
        var computedWidth = height * (16/9);
        var computedHeight = width * (9/16);
        var video = this.player.container;
        var left;
        var top;
        var css;

        if (height < width) {
            computedHeight = height;
        }

        // when the computed width is too large to fit on the screen
        // use the window's width and a height using the ratio
        if (computedWidth > width) {
            computedWidth = width;
            computedHeight = computedWidth * 9/16;
        }

        // there will be space left over, use it to center
        // the player
        left = (width - computedWidth) * 0.5;
        top = left <= 0 ? (height - computedHeight) * 0.5 : 0;

        css = {
            "width": VHS.util.normalizeUnit(computedWidth),
            "height": VHS.util.normalizeUnit(computedHeight),
            "left": VHS.util.normalizeUnit(left),
            "top": VHS.util.normalizeUnit(top)
        };

        return css;
    },
    /**
     * Event handler which is used for windowed fullscreen
     * when the esc key is pressed, vhs exits fullscreen.
     * @param  {Object} e jquery event
     * @return {undefined}
     */
    onEscKey: function (e) {
        var code = e.keyCode || e.which;

        if (code === 27) {
            this.exit();
        }
    },
    /**
     * puts vhs into a windowed fullscreen
     * and triggers a change event
     */
    vhsEnterFullscreen: function () {
        this.renderVHSFullscreenElement();

        this._isFullscreen = true;
        this.onFullscreenChange();
        this.onVHSFullscreenResize();
        $(window).resize(this._resizeProxy);
    },
    /**
     * takes the current vhs player out of fullscreen
     */
    vhsExitFullscreen: function () {
        this.removeVHSFullscreenElement();

        this._isFullscreen = false;
        this.onFullscreenChange();
        $(window).off("resize", this._resizeProxy);
    },
    /**
     * enables native fullscreen when possible
     * fallback to the vhs fullscreen
     */
    enter: function(){
        var el = this.player.container[0];
        var isSupported = function(elem, feature) {
            return typeof elem[feature] === 'function';
        };

        this.setPermission(true);

        //native fullscreen behavior
        if (VHS.util.isIpad() || VHS.util.isAndroid()) {
            el = this.player.element.get(0);
        }

        if (isSupported(el, 'requestFullscreen')) {
            el.requestFullscreen();
        } else if (isSupported(el, 'webkitRequestFullscreen')) {
            el.webkitRequestFullscreen();
        } else if (isSupported(el, 'webkitEnterFullScreen')) {
            el.webkitEnterFullScreen();
        } else if (isSupported(el, 'mozRequestFullScreen')) {
            el.mozRequestFullScreen();
        /* Lowercase 's' in fullscreen is intentional for IE! */
        } else if (isSupported(el, 'msRequestFullscreen')) {
            el.msRequestFullscreen();
            this.player.container.addClass('ms-fullscreen');
        } else {
            this.vhsEnterFullscreen();
        }
    },
    /**
     * exits fullscreen
     */
    exit: function(){
        if (!this.getPermission()) return;
        var el = this.player.container[0];

        //native fullscreen behavior
        if (VHS.util.isIpad()) {
            el = this.player.element.get(0);
        }

        if (typeof el.webkitCancelFullScreen === 'function') {
            el.webkitCancelFullScreen();
        } else if (typeof document.exitFullscreen === 'function') {
            document.exitFullscreen();
        } else if (typeof document.webkitExitFullscreen === 'function') {
            document.webkitExitFullscreen();
        } else if (typeof document.mozCancelFullScreen === 'function') {
            document.mozCancelFullScreen();
        } else if (typeof document.msExitFullscreen === 'function') {
            document.msExitFullscreen();
            this.player.container.removeClass('ms-fullscreen');
        } else {
            this.vhsExitFullscreen();
        }
    },
    getPermission: function () {
        return this._permissionGranted;
    },
    setPermission: function (hasPermission) {
        this._permissionGranted = hasPermission;
    },
    /**
     * Check if fullscreen is enabled
     * @return {Boolean} true when any player is in fullscreen
     */
    isEnabled: function() {
        var doc = VHS.util.getDocument();
        return  (doc.fullScreen ||
            doc.mozFullScreen ||
            doc.webkitIsFullScreen ||
            this.player.container.get(0).webkitIsFullScreen ||
            this._isFullscreen ||
            doc.msIsFullScreen);
    },
    /**
     * applies styles to the vhs player required
     * for being fullscreen in the browser window
     */
    renderVHSFullscreenElement: function () {
        var $video =this.player.container;
        var $controls = this.player.controls;
        var zIndex = 100000;

        $video.data('style', $video.attr('style'));
        $video.css({
                "position": "fixed",
                "top": 0,
                "left": 0,
                "z-index": zIndex
            });

        $('<div class="nytd-player-fullscreen"></div>')
            .appendTo('body')
            .css({
                width: "100%",
                height: "100%",
                background: "#000",
                position: "fixed",
                top: 0,
                left: 0,
                zIndex: zIndex - 1
            });

        $('body').data('overflow', $('body').css('overflow'));
        $('body').css('overflow', 'hidden');
        $controls.data('style', $controls.attr('style'));
        $controls.css('z-index', zIndex + 1);
    },
    /**
     * removes special styles for fullscreen
     * in the browser window
     */
    removeVHSFullscreenElement: function () {
        var $video = this.player.container;
        var $controls = this.player.controls;

        $('body').css('overflow', $('body').data('overflow'));
        $video.attr('style', $video.data('style'));
        $controls.attr('style', $controls.data('style'));
        $('.nytd-player-fullscreen').remove();
    }
};

/**
@class RenditionSelector
@module VHS.api
@constructor
**/
VHS.api.RenditionSelector = function(options){
    this.renditionsData = null;
    this.activeRendition = null;
    this.LIMITS = $.extend({
        SD: {
            min: 360,
            max: 480
        },
        HD: {
            min: 480,
            max: 720
        }
    }, options && options.renditions ? options.renditions : {});
};

VHS.api.RenditionSelector.prototype = {
    findNearest: function (arr, prop, max, min, ht) {
        var idx = -1;
        var len = arr.length;
        var smallest = 1080 + ht;

        for (var i = 0; i < len; i++) {
            var diff = Math.abs(ht - arr[i][prop]);
            if ((diff <= smallest) && (arr[i][prop] >= min) && (arr[i][prop] <= max)) {
                idx = i;
                smallest = diff;
            }
        }

        return idx;
    },
    filterByFileType: function (type, renditions) {
        var heights = {};
        var arr = [];
        var rendLen = renditions.length;

        for (var i = 0; i < rendLen; i++) {
            if (!heights.hasOwnProperty(renditions[i].height) && renditions[i] && renditions[i].url && renditions[i].url.indexOf(type) > -1) {
                arr.push(renditions[i]);
                heights[renditions[i].height] = true;
            }
        }

        return arr;
    },
    getCompatibleRenditions: function(renditions, playerType) {
        var renditionsData = this.filterByFileType("." + VHS.util.getSupportedType(playerType), renditions);
        if(!renditionsData.length && playerType === "flash"){
            renditionsData = this.filterByFileType(".flv", renditions);
            for(var i =0; i<renditionsData.length; i++){
                renditionsData[i].url = renditionsData[i].url.replace(".flv","");
            }
        }
        renditionsData.sort(function(leftObj, rightObj) {
            var left = leftObj.height;
            var right = rightObj.height;
            if (left > right) return 1;
            if (left < right) return -1;
            return left === right ? -1 : 1;
        });

        return renditionsData;
    },
    /**
     * Given a list of renditions returns the optimal one for the current player's height.
     * Return either the url or the entire rendition object based on the returnType
     * @param  {Array} renditions   a list of renditions which must containt the height and url for item
     * @param  {Number} playerHeight the height of the player, this value behaves the same as maxHeight but is only used when it is less than maxHeight
     * @param  {Boolean} hdEnabled   when true the rendition with the greatest height is returned
     * @param  {String} playerType   'flash' or 'html5' determines the compatible type for the player (mp4 or webm)
     * @params {String} returnType 'object' or 'url'
     * @return {String|Object}    selected rendition's url or object
     */
    getClosestRendition: function(renditions, playerHeight, hdEnabled, playerType, returnType) {
        var renditionIndex;
        var modeName = hdEnabled ? "HD" : "SD";
        var maxHeight = this.LIMITS[modeName].max;
        var minHeight = this.LIMITS[modeName].min;
        var rendition = (returnType === 'url') ? '' : {};

        playerHeight = !hdEnabled ? playerHeight : this.LIMITS[modeName].max;

        this.renditionsData = this.getCompatibleRenditions(renditions, playerType);
        renditionIndex = this.findNearest(this.renditionsData, "height", maxHeight, minHeight, playerHeight);

        if (renditionIndex === -1) {
            renditionIndex = this.renditionsData.length >> 1;
        }

        if (this.renditionsData && this.renditionsData[renditionIndex]) {

            if (returnType === 'url') {
                rendition = this.renditionsData[renditionIndex].url;
            } else {
                rendition = this.renditionsData[renditionIndex];

                if (rendition && rendition.type) {
                    rendition.bitrate = this.getBitrate(rendition.type);
                }
            }
        }

        return rendition;
    },
    /**
     * given a list of renditions returns the optimal one for the current player's height
     * @param  {Array} renditions   a list of renditions which must containt the height and url for item
     * @param  {Number} playerHeight the height of the player, this value behaves the same as maxHeight but is only used when it is less than maxHeight
     * @param  {Boolean} hdEnabled   when true the rendition with the greatest height is returned
     * @param  {String} playerType   'flash' or 'html5' determines the compatible type for the player (mp4 or webm)
     * @return {String}              selected rendition's url
     */
    getClosestRenditionUrl: function (renditions, playerHeight, hdEnabled, playerType) {
        return this.getClosestRendition(renditions, playerHeight, hdEnabled, playerType, 'url');
    },
    /**
     * given a list of renditions returns the optimal one for the current player's height
     * @param  {Array} renditions   a list of renditions which must containt the height and url for item
     * @param  {Number} playerHeight the height of the player, this value behaves the same as maxHeight but is only used when it is less than maxHeight
     * @param  {Boolean} hdEnabled   when true the rendition with the greatest height is returned
     * @param  {String} playerType   'flash' or 'html5' determines the compatible type for the player (mp4 or webm)
     * @return {Object}              selected rendition's object
     */
    getClosestRenditionObject: function (renditions, playerHeight, hdEnabled, playerType) {
        return this.getClosestRendition(renditions, playerHeight, hdEnabled, playerType, 'object');
    },
    getBitrate: function(videoType) {
        var bitrates = {
            "video_xs_2g_mob": 100,
            "video_l_3g_mob": 350,
            "video_xxxl_hb_mm": 1200,
            "video_s_3g_hp": 350,
            "video_l_bb_lib": 620,
            "video_xl_bb_art": 700,
            "video_xxl_bb_mm": 850,
            "video_s_nb_well": 450,
            "video_well_s_nb": 360,
            "syndication": 8000,
            "mobile_win": 90,
            "mobile_reg2": 106,
            "mobile_reg": 56,
            "video_s_nb": 275,
            "video_s_bb": 514,
            "video_l_nb": 464,
            "video_l_bb": 714,
            "video_a_nb": 525,
            "video_a_bb": 750,
            "video_well_s": 550,
            "touch_itunes": 1328,
            "mobile_iphone": 160,
            "video_xl_bb_mm": 720,
            "video_144p_mp4": 248,
            "video_240p_mp4": 369,
            "video_360p_mp4": 935,
            "video_480p_mp4": 1513,
            "video_720p_mp4": 2545,
            "video_1080p_mp4": 3689,
            "video_240p_webm": 369,
            "video_360p_webm": 968,
            "video_480p_webm": 1568,
            "video_720p_webm": 2632
        };

        return bitrates[videoType] || 2400;
    },
    resetActive: function () {
        this.activeRendition = null;
    },
    setActive: function (url) {
        this.activeRendition = url;
    },
    getActive: function () {
        return this.activeRendition;
    },
    findRenditionByUrl: function (url) {
        for (var i = 0, len = this.renditionsData.length; i < len; i++) {
            if(this.renditionsData[i].url === url) {
                return this.renditionsData[i];
            }
        }
    }
};

VHS.api.Responsive = function(player){
    this.player = player;
    this.setResponsiveClass = $.proxy(this.setResponsiveClass, this);

    this.setResponsiveClass();
    this.bindWindow();
};

VHS.api.Responsive.prototype.bindWindow = function (argument) {
    $(window).off('resize', this.setResponsiveClass);
    $(window).on('resize', this.setResponsiveClass);
};

VHS.api.Responsive.prototype.destroy = function () {
    $(window).off('resize', this.setResponsiveClass);
};

/**
 * Responsive class sizes with rules that dictate
 * when they should be applied
 *
 * @type {Object}
 */
VHS.api.Responsive.classSizes = {
    'XXSMALL': {
        'className': 'vhs-xxs',
        'rule': 'lte',
        'size': 335
    },
    'XSMALL': {
        'className': 'vhs-xs',
        'rule': 'lt',
        'size': 390
    },
    'SMALL': {
        'className': 'vhs-s',
        'rule': 'lt',
        'size': 540
    },
    'MEDIUM': {
        'className': 'vhs-m',
        'rule': 'lt',
        'size': 720
    },
    'LARGE': {
        'className': 'vhs-l',
        'rule': 'lt',
        'size': 945
    },
    'XLARGE': {
        'className': 'vhs-xl',
        'rule': 'lt',
        'size': 1050
    },
    'XXLARGE': {
        'className': 'vhs-xxl',
        'rule': 'gte',
        'size': 1050
    }
};

/**
 * Used to enforce order when looping
 * through the classSizes
 *
 * @type {Array}
 */
VHS.api.Responsive.orderedClassSizes = [
    VHS.api.Responsive.classSizes.XXSMALL,
    VHS.api.Responsive.classSizes.XSMALL,
    VHS.api.Responsive.classSizes.SMALL,
    VHS.api.Responsive.classSizes.MEDIUM,
    VHS.api.Responsive.classSizes.LARGE,
    VHS.api.Responsive.classSizes.XLARGE,
    VHS.api.Responsive.classSizes.XXLARGE
];

/**
 * Checks the current size of the player and determines
 * which responsive class should be set on its main container.
 *
 * Relies on VHS.api.Poster.orderedClassSizes for ordering.
 *
 */
VHS.api.Responsive.prototype.setResponsiveClass = function() {
    var playerContainer = this.player.container;
    var playerElementWidth = playerContainer.get(0).offsetWidth;
    var totalClassSizes = VHS.api.Responsive.orderedClassSizes.length;
    var orderedClassSizes = VHS.api.Responsive.orderedClassSizes;
    var ruleMatched = false;  //first match blocks further rules
    var classToRemove = '';
    var classSize, i;

    //operation rules to allow for variables as operators
    var ops = {
        'lt': function(a, b) { return a < b; },
        'lte': function(a, b) { return a <= b; },
        'gte': function(a, b) { return a >= b; }
    };

    for (i = 0; i < totalClassSizes; i++) {
        classSize = orderedClassSizes[i];

        //if size matches current player size
        if (!ruleMatched && ops[classSize.rule](playerElementWidth, classSize.size)) {
            ruleMatched = true;
            playerContainer.addClass(classSize.className);
        } else {
            classToRemove += classSize.className + " ";
        }
    }

    //remove any previous classes
    playerContainer.removeClass(classToRemove);
};

/**
@class Poster
@module VHS.api
@constructor
**/
VHS.api.Poster = function(player){
    this.player = player;
    this.ui = {
        'play': ''
    };
    this.defaultMode = 'duration';
    this.template = (VHS.templates && VHS.templates.cover) ? VHS.templates.cover : null;
};

VHS.api.Poster.prototype = {

    /**
     * Determines the proper Poster Image Url
     * @return {[string]} Image Url for the Poster Frame
     */
    getUrl: function() {
        var posterUrl,
            images = [];

        if (typeof this.player.options.poster !== 'undefined') {
            posterUrl = this.player.options.poster;
        } else if (this.player._data) {
            if (this.player.modules.features.isEnabled('poster-image-select')) {
                posterUrl = this.getClosestPosterMatch();
            } else {
                images = this.player._data.images;
                for (var i in images) {
                    if (images[i].type === 'videoSmall') {
                        posterUrl = this.player.staticBaseUrl + images[i].url;
                    }
                }
            }
        }

        return posterUrl;
    },

    /**
     * Genereates the available poster images
     * with default placeholder backups
     *
     * @return {array} Array of image objects, including url, width, height
     */
    getAvailableImages: function () {

        var images = this.player._data.images || [];
        var imagesLen = images.length;
        var availableImages = [];
        var undesireableImages = []; //2nd tier images that aren't marked 16:9
        var i,
            defaultImage,
            availableImagesLength;

        var placeholderImages = [
            {
                url: this.player.staticBaseUrl + 'video/static-timesvideo/img/video-default-16by9-96x54.png',
                width: 96,
                height: 54
            },
            {
                url: this.player.staticBaseUrl + 'video/static-timesvideo/img/video-default-16by9-225x126.png',
                width: 225,
                height: 126
            },
            {
                url: this.player.staticBaseUrl + 'video/static-timesvideo/img/video-default-16by9-310x174.png',
                width: 310,
                height: 174
            },
            {
                url: this.player.staticBaseUrl + 'video/static-timesvideo/img/video-default-16by9-500x281.png',
                width: 500,
                height: 281
            },
            {
                url: this.player.staticBaseUrl + 'video/static-timesvideo/img/video-default-16by9-1050x591.png',
                width: 1050,
                height: 591
            },
            {
                url: this.player.staticBaseUrl + 'video/static-timesvideo/img/video-default-16by9-1920x1080.png',
                width: 1920,
                height: 1080
            }
        ];

        for (i = 0; i < imagesLen; i++) {
            if (images[i].type && images[i].type.indexOf('videoSixteenByNine') > -1) {
                availableImages.push({
                    url: this.player.staticBaseUrl + images[i].url,
                    width: images[i].width,
                    height: images[i].height
                });
            } else {
                undesireableImages.push({
                    url: this.player.staticBaseUrl + images[i].url,
                    width: images[i].width,
                    height: images[i].height
                });
            }

            if (images[i].type === 'videoSmall') {
                defaultImage = {
                    url: this.player.staticBaseUrl + images[i].url,
                    width: 500,
                    height: 281
                };
            }
        }

        if (availableImages.length === 0) {
            if (defaultImage) {
                availableImages = [defaultImage];
            } else if (undesireableImages.length > 0) {
                availableImages = undesireableImages;
            } else {
                availableImages = placeholderImages;
            }
        }

        return availableImages;

    },

    /**
     * Returns the best fit poster image match
     * determined by the player size on load
     *
     * @return {string} Full poster image URL
     */
    getClosestPosterMatch: function () {
        var availableImages = this.getAvailableImages();
        var availableImagesLength = availableImages.length;
        var playerElementWidth = this.player.container.get(0).offsetWidth;
        var sizeTolerance = 0.1;
        var i,
            bestMatch,
            closestBelow,
            closestAbove;

        if (availableImagesLength === 0) {
            return '';
        }

        if (availableImagesLength === 1) {
            return availableImages[0].url;
        }

        //find the closest match
        for (i = 0;  i < availableImagesLength; i++) {

            //exact match
            if (availableImages[i].width === playerElementWidth) {
                bestMatch = availableImages[i];
                break;
            }

            //save the closest matching image below the player size
            if (availableImages[i].width <= playerElementWidth && (closestBelow === undefined || closestBelow.width < availableImages[i].width)) {
                closestBelow = availableImages[i];
                closestBelow.widthDiff = Math.abs(closestBelow.width - playerElementWidth);
            }

            //save the closest matching image above the player size
            if (availableImages[i].width >= playerElementWidth && (closestAbove === undefined || closestAbove.width > availableImages[i].width)) {
                closestAbove = availableImages[i];
                closestAbove.widthDiff = Math.abs(closestAbove.width - playerElementWidth);
            }
        }

        //determine if the smaller image is actually a better fit
        if (!bestMatch && closestBelow && closestAbove) {
            if (closestBelow.widthDiff < closestAbove.widthDiff) {
                if (closestBelow.widthDiff < playerElementWidth * sizeTolerance) {
                    bestMatch = closestBelow;
                }
            }
        }

        //set a default value if bestMatch not set yet
        bestMatch = bestMatch || closestAbove || closestBelow;

        return bestMatch.url;

    },

    /**
     * Renders the poster container on top of the video
     * and binds the proper events.
     * Binds VHS.api.events.PLAYING and VHS.api.events.AD_STARTED to hide the poster.
     *
     * @method render
     *
     */
    render: function() {
        var self = this;
        var posterUrl = this.getUrl();

        var element = [
            '<div class="nytd-player-poster">',
            '</div>'
        ].join('');

        if (!posterUrl) { return false; }

        // remove poster div if it already exists on DOM
        if (this.element) {
            this.element.remove();
        }

        this.element = $(element).css({
            "width": VHS.util.normalizeUnit(this.player.options.width),
            "height": VHS.util.normalizeUnit(this.player.options.height),
            "background": "url(" + posterUrl + ") center center no-repeat",
            "background-size": "cover"
        });

        // support pre-module poster in version below 1.7.0
        this.player.poster = this.element;

        this.processCover();
        this.player.container.prepend(this.element);

        // if we are not using the cover and not using controls, but using nativeControls then hide the poster so the user can see a native play button
        if (this.player.options.nativeControls && !this.player.options.controls && !this.player.options.cover) {
            this.element.hide();
        }

        this.player.on(VHS.api.events.PLAYING, function(){
            self.hide();
        });

        this.player.on(VHS.api.events.AD_STARTED, function(){
            self.hide();
        });

        this.player.on(VHS.api.events.RENDITION_NOT_FOUND, function(){
            self.hide();
        });
    },

    /**
     * Sets the poster attribute of the video tag to the poster url
     * @method renderNativePoster
     *
     */
    renderNativePoster: function() {
        var posterUrl = this.getUrl();
        if (posterUrl && this.player && this.player.element && this.player.getType() === 'html5') {
            this.player.element.attr('poster', posterUrl);
        }
    },

    /**
     * Removes the poster attribute of the video tag
     * @method removeNativePoster
     */
    removeNativePoster: function() {
        if (this.player && this.player.element && this.player.getType() === 'html5') {
            this.player.element.removeAttr('poster');
        }
    },

    /**
     * Updates the poster background
     *
     */
    update: function() {
        var posterUrl = this.getUrl();
        if (this.element && posterUrl) {
            this.element.css({
                "background": "url(" + posterUrl + ") center center no-repeat",
                "background-size": "cover"
            });
        }
    },

    /**
     * Calls the proper functions when the user clicks
     * the poster to play the video
     */
    handleOnClick: function() {
        var self = this;

        if (this.element) {
            this.element.on('click', function() {
                // add loader since we know render will be followed by a play
                if (self.player.firstPlay) {
                    self.player.addLoader();
                }

                if (self.player.rendered === false) {
                    if (self.player.getType() === 'flash') {
                        self.player.on(VHS.api.events.RENDERED, function videoReady() {
                            self.player.play();
                            self.player.off(VHS.api.events.RENDERED, videoReady);
                        });
                        self.player.render();
                    } else {
                        self.player.render();
                        self.player.play();
                    }
                } else {
                    self.player.play();
                }

                self.hide();

                // set focus on container so the spacebar toggle will work without needing to click on the video element first
                if (self.player.container && self.player.options.spacebarToggleEnabled) {
                    self.player.container.focus();
                }
            });
        }
    },

    /**
     * Hides the poster unless it is iOS
     */
    hide: function() {
        var self = this;

        if (this.element && !this.player.isIphone) {
            this.element.hide();
        } else if (this.player.isIphone && this.player.element) {
            this.player.element.one('webkitendfullscreen', function() {
                //handle 1 click poster behaviour after video is played
                if (self.player) {
                    // reset ad flags
                    if (self.player.adsController) {
                        self.player.adsController.isCompleted = false;
                        self.player.adsController.isContentPlaying = false;
                    }
                    // remove video element
                    if (self.player.element) {
                        self.player.element.off();
                        self.player.element.remove();
                    }
                    // reset player flags
                    self.player.rendered = false;
                    self.player.listenersInitialized = false;
                }
            });
        }
    },

    /**
     * Determines which, if any, cover template should be shown
     */
    processCover: function() {
        if (!this.player.options.cover || this.player.options.autoplay || !this.template) {
            return;
        }

        var mode = this.player.options.cover.mode || this.defaultMode;
        mode = mode.toLowerCase();

        //validate the mode
        switch(mode) {
            case 'duration':
            case 'clean':
            case 'article':
            case 'mobile':
            //disabled modes
            // case 'offsite':
                break;
            default:
                mode = this.defaultMode;
        }

        this.renderCover(mode);
    },

    /**
     * Renders the cover on top of the poster
     * container if it exists, otherwise does nothing
     */
    renderCover: function(mode) {
        var coverElement,
                duration = this.formatDuration(this.player.getDuration());

        var options = {
            'mode': mode || this.defaultMode,
            'data':  {
                'headline': '',
                'byline': '',
                'duration': duration,
                'channelName': '',
                'showName': ''
            }
        };

        if (this.player._data) {
            options.data.headline = this.player._data.headline;
            options.data.byline = this.player._data.byline;
            options.data.showName = this.player._data.playlist.display_name;
            options.data.channelName = this.player._data.playlist.parent_display_name;
        }

        coverElement = $.trim(this.template(options));

        if (this.element) {
            this.element.append(coverElement);
            this.ui.play = this.element.find('.vhs-icon-play');
        }
    },


    /**
     *  Takes a duration in seconds and formats it as a string
     *  HH:MM:SS
     *
     */
    formatDuration: function(duration) {
        var sec_num = parseInt(duration, 10);
        var hours   = Math.floor(sec_num / 3600);
        var minutes = Math.floor((sec_num - (hours * 3600)) / 60);
        var seconds = sec_num - (hours * 3600) - (minutes * 60);
        var time = '';

        if (hours) {
            time = hours + ':';
            time += ("0" + minutes).slice(-2) + ':';
        } else if (minutes) {
            time += minutes + ':';
        } else {
            time = '00:';
        }

        time += ("0" + seconds).slice(-2);

        return time;
    }
};

/**
* This is a module to handle errors that we want to display in an error slate over the player
*
* @class Errors
* @module VHS.api
* @constructor
*/

VHS.api.Errors = function(player){
    this.player = player;
    this.options = player.options;
    this.logger = player.logger;
    this.errorContainer = null;

    this.messages = {};
    this.messages[VHS.api.events.RENDITION_NOT_FOUND] = 'This video is not currently supported on your browser.';

    this.initialize();
};

VHS.api.Errors.prototype = {

    initialize: function() {
        var self = this;

        this.player.on(VHS.api.events.RENDITION_NOT_FOUND, function() {
            self.logger.error('RENDITION_NOT_FOUND. Update Error Slate.');
            self.updateErrorSlate(VHS.api.events.RENDITION_NOT_FOUND);
        });

        this.player.on(VHS.api.events.PLAY, function() {
            self.logger.log('Playing a video. Hide Error Slate.');
            self.hideErrorSlate();
        });

        this.player.on(VHS.api.events.AD_STARTED, function() {
            self.logger.log('Playing an ad. Hide Error Slate.');
            self.hideErrorSlate();
        });
    },

    createErrorSlate: function(error) {
        if (this.errorContainer) {
            this.errorContainer.remove();
        }
        this.icon = '<i class="vhs-icon-alert"></i>';
        this.errorContainer = $('<div class="vhs-error-slate"><p>'+this.icon+'</p></div>');
        this.player.container.append(this.errorContainer);
    },

    updateErrorSlate: function(error) {
        if (!this.errorContainer) {
            this.createErrorSlate();
        }

        this.errorContainer.find('p').html(this.icon+this.messages[error]);
        if (VHS.util.jqueryInUse()) {
            this.errorContainer.fadeIn(100);
        } else {
            this.errorContainer.show();
        }
    },

    hideErrorSlate: function() {
        var self = this;
        if (this.errorContainer && this.errorContainer.is(':visible')) {
            if (VHS.util.jqueryInUse()) {
                this.errorContainer.fadeOut(100, function(){
                    if (self.errorContainer) {
                        self.errorContainer.hide();
                    }
                });
            } else {
                this.errorContainer.hide();
            }
        }
    }

};

VHS.api.events = {
    'READY': 'ready',
    'LOADED': 'loaded',
    'PLAY': 'play',
    'PAUSE': 'pause',
    'MUTE': 'mute',
    'PLAYING': 'playing',
    'PROGRESS': 'progress',
    'SEEKED': 'seeked',
    'ENDED': 'ended',
    'BUFFERING': 'buffering',
    'BUFFER_FULL': 'bufferfull',
    'DURATION_CHANGE': 'durationchange',
    'TIME_UPDATE': 'timeupdate',
    'GO_FULLSCREEN': 'gofullscreen',
    'EXIT_FULLSCREEN': 'exitfullscreen',
    'AD_STARTED': 'adstarted',
    'AD_PAUSED': 'adpaused',
    'AD_RESUMED': 'adresumed',
    'AD_COMPLETED': 'adcompleted',
    'AD_TIME_UPDATE': 'adtimeupdate',
    'AD_PROGRESS': 'adprogress',
    'AD_SKIPPED': 'adskipped',
    'AD_STOPPED': 'adstopped',
    'AD_FIRST_QUARTILE': 'ad-first-quartile',
    'AD_MIDPOINT': 'ad-mid-point',
    'AD_THIRD_QUARTILE': 'ad-third-quartile',
    'AD_ERROR': 'ad-error',
    'RENDITION_CHANGED': 'renditionchanged',
    'LOADED_DATA': 'loadeddata',
    'RENDERED': 'rendered',
    'LOAD_START': 'loadstart',
    'ERROR': 'error',
    'STALLED': 'stalled',
    'WAITING': 'waiting',
    'VIDEO_READY':'video:ready',
    'VIDEO_LOADING':'video:loading',
    'VIDEO_FLASH_BYTES_LOADED_CHANGE':'video:flash:bytesloadedchange',
    'VIDEO_FLASH_BUFFER_TIME_CHANGE':'video:flash:buffertimechange',
    'LEVEL_ENDLIST': 'levelendlist',
    'HD_ON':'hdon',
    'HD_OFF':'hdoff',
    'SHOW_CONTROLS': 'showcontrols',
    'HIDE_CONTROLS': 'hidecontrols',
    'TRACKING_EVENT':'trackingevent',
    'RENDITION_NOT_FOUND':'renditionnotfound'
};

VHS.api.status = {
    VIDEO_PAUSED: 'paused',
    AD_PAUSED: 'adpaused',
    VIDEO_PLAYING: 'playing',
    AD_PLAYING: 'adplaying',
    VIDEO_ENDED: 'ended',
    AD_OVERLAY_ACTIVE: 'adoverlayactive'
};

/**
@class Player
@module VHS.api
@constructor
**/
VHS.api.Player = function(options, instance){
    this.MAX_SD_RENDITION = 480;
    this.enableHD = false;
    this.isIphone = VHS.util.isIphone();
    this._data = null;
    this._evts = {};
    this.poster = null;
    this.totalTimeToSkipAd = 15;
    this.skipAdThreshold = 20;
    this.isReady = false;
    this.isLoaded = false;
    this.seeking = false;
    this.readyCallbacks = [];
    this.loadedCallbacks = [];
    this.instance = instance;
    this.isTouch = 'ontouchstart' in document.documentElement;
    this.status = VHS.api.status.VIDEO_PAUSED;
    this.videoFullscreen = false;
    this.listenersInitialized = false;
    this.rendered = false;
    this.rendering = false;
    this.queuedPlayOnRendered = false;
    this.adPaused = false;
    this.adSkipped = false;
    this.hdRenditionChanging = false;
    this.videoChanged = false;
    this.modules = {
        fullscreen: null,
        renditions: null,
        responsive: null,
        conviva: null,
        errors: null,
        qos: null
    };
    this.playerStartTimestamp = new Date();
    var displayControls = (this.isIphone) ? false : true;

    /**
    @property options
    @type object
    **/
    this.options = $.extend({
        id: '',
        name: null,
        category: null,
        element: null,
        container: null,
        type: null,
        src: null,
        source: null,
        render: true,
        width: 600,
        height: 338,
        muted: false,
        preload: 'none',
        autoplay: false,
        duration: null,
        controls: displayControls,
        nativeControls: false,
        nativePoster: false,
        loop: false,
        ads: true,
        skipAd: true,
        cover: true,
        shareOptions: {
            articleId: null, //use article data in sharetools
            blogPostUrl: null,
            url: null
        },
        loader: true,
        //Depreacated
        freewheel: null,
        siteSection: null,
        playlist: false,
        ratio: '16:9',
        debug: false,
        api: true,
        usage: 'vanilla_js',
        mode: null,
        live: false,
        userInitiatedPlay: false,
        userInitiatedNext: false,
        autoPlayNext: false,
        onReady: null,
        onLoaded: null,
        renditions: {},
        conviva: true,
        debugConviva: false,
        qos: true,
        flashHdSwitchSeek: false,
        qosConfigUrl: null,
        enableVHSFullscreen: false,
        spacebarToggleEnabled: true
    }, options);

    this.controlsIsVisible = true;
    this.controlsRendered = false;
    this.initialize();
};

VHS.api.Player.prototype = {
    initialize: function(){
        this.logger = new VHS.api.Logger(this);
        this.validateEnvironment();
        this.setupEnvPaths();
        this.options.debugPathSWF = this.options.debugPathSWF || ('../../'+ VHS._version + '-' + VHS._release + '/vhs-debug.swf');
        this.swf = (this.options.debug && this.options.debugPathSWF) ? this.options.debugPathSWF : this.staticBaseUrl + 'video/vhs/'+ VHS._version + '-' + VHS._release + '/vhs.swf';
        this.device = VHS.util.getDeviceType();
        this.firstPlay = true;
        this.firstEnded = true;
        // introduced to track ended state for IE9 HTML5 (ended on the video is false reported in IE9)
        this.ended = false;
        this.loadingVideo = false;
        this.restoreHDState();

        this.ensureOptionDependencies();

        if (this.validate()) {
            this.create();
        }
    },
    /**
    * Check options and enforce option dependency rules.
    *
    * @method ensureOptionDependencies
    * @return {undefined} Returns undefined
    */
    ensureOptionDependencies: function() {
        // if the device does not support autoplay make sure we do not allow autoplay
        if (!VHS.util.supportsAutoplay()) {
            this.options.autoplay = false;
        }

        // do NOT use cover if no poster
        if (this.options.cover && !this.options.poster && (!this.options.id || !this.options.api)) {
            this.options.cover = false;
        }

        // do NOT use ads or analytics if looping
        if (this.options.loop) {
            this.options.ads = false;
            this.options.analytics = false;
        }

        // ensure that if conviva is explicitely turned off then we will turn off qos too
        // this is to make sure legacy players follow analytics rules for looping
        if (this.options.conviva === false) {
            this.options.qos = false;
        }

        // ensure conviva and qos are never on together
        if (this.options.qos) {
            this.options.conviva = false;
        }

        // set startup seek if there's deeplinking enabled on options
        if (this.options.deeplinking) {
          var url = VHS.util.getCurrentURL();
          this.startupSeek = VHS.util.seekStringToSeconds(url);
          if (VHS.util.getUrlParameterByName('cview')) {
            this.defaultAdsState = this.options.ads;
            this.options.ads = false;
          }
        }

        // if analytics is set to false then disable all analytics
        if (this.options.analytics === false) {
            this.options.comscore = false;
            this.options.conviva = false;
            this.options.eventTracker = false;
            this.options.qos = false;
            this.options.upt = false;
            this.options.webtrends = false;
            this.options.tagx = false;
        }
    },
    validateEnvironment: function() {
        var validEnvironments = ['localhost', 'development', 'staging', 'production'];
        var productionHosts = ['www.nytimes.com', 'cooking.nytimes.com', 'paidpost.nytimes.com', 'brandedplaylist.nytimes.com'];
        var host = VHS.util.getHost();

        // if env is not set, find a logical default from host
        if (this.options.env === undefined && !this.options.debug) {
            this.options.env = VHS.util.getEnvFromHost();
        } else if ($.inArray(this.options.env, validEnvironments) === -1 || $.inArray(host, productionHosts) !== -1) {
            // protect against VHS being set to stg on production
            // or being set to something other than the valid environment
            this.options.env = 'production';
        }
    },
    setupEnvPaths: function(){
        switch(this.options.env) {
            case 'localhost':
                this.apiBaseDomain = 'http://video-api.dev.nytimes.com';
                this.staticBaseUrl = 'http://static.dev.nytimes.com/';
                this.fwAdManager = "http://adm.fwmrm.net/p/nytimes_test/AdManager.swf";
                this.fwServer = "http://fw.stg.nytimes.com/ad/g/1";
                this.fwNetworkId = 379535;
                this.fwProfile = "ny_times_prop_as3_test";
                break;
            case 'development':
                this.apiBaseDomain = 'http://www.stg.nytimes.com';
                this.staticBaseUrl = 'http://static.dev.nytimes.com/';
                this.fwAdManager = "http://adm.fwmrm.net/p/nytimes_test/AdManager.swf";
                this.fwServer = "http://fw.stg.nytimes.com/ad/g/1";
                this.fwNetworkId = 379535;
                this.fwProfile = "ny_times_prop_as3_test";
                break;
            case 'staging':
                this.apiBaseDomain = 'http://www.stg.nytimes.com';
                this.staticBaseUrl = 'http://static.stg.nytimes.com/';
                this.fwAdManager = "http://adm.fwmrm.net/p/nytimes_test/AdManager.swf";
                this.fwServer = "http://fw.stg.nytimes.com/ad/g/1";
                this.fwNetworkId = 379535;
                this.fwProfile = "ny_times_prop_as3_test";
                break;
            default:
                this.apiBaseDomain = 'http://www.nytimes.com';
                this.staticBaseUrl = 'http://static01.nyt.com/';
                this.fwAdManager = "http://adm.fwmrm.net/p/nytimes_live/AdManager.swf";
                this.fwServer = "http://fw.nytimes.com/ad/g/1";
                this.fwNetworkId = 379536;
                this.fwProfile = "ny_times_prop_as3";
                break;
        }

        if (this.options.apiBaseDomain) {
            this.apiBaseDomain = this.options.apiBaseDomain;
        }

        this.apiBasePath = this.options.apiBasePath || '/svc/video/api/v2/';

        this.apiBaseUrl = this.apiBaseDomain + this.apiBasePath;
    },
    /**
    Create new player
    @method create
    @param {Object} options Player options
        @param {String} options.container DOM element that the player will be embeded
        @param {String} options.id NYT reference Id for the video
    **/
    create: function(){
        var self = this;
        var id = this.options.id;
        var videoId;
        this.element = this.options.element || null;

        if (!this.modules.features) {
            this.modules.features = new VHS.api.FeatureFlags(this);
        }

        this.options.flashHdSwitchSeek = this.modules.features.isEnabled('flash-hd-switch-seek');

        this.modules.renditions = new VHS.api.RenditionSelector(this.options);
        this.detectTearsheeting();

        // must happen before plugins are initialized
        this.renderContainer();

        // plugins need to load before we get data so we can report on bootstrap failures
        // _element is now assigned thru a _rendered handler
        this.plugins = new VHS.api.Plugins(this);

        // initialize the conviva module
        if (!this.modules.conviva) {
            this.modules.conviva = new VHS.api.Conviva(this);
        }

        // initialize the Akamai/qos module
        if (!this.modules.qos) {
            this.modules.qos = new VHS.api.Qos(this);
        }

        // initialize the errors module
        if (!this.modules.errors) {
            this.modules.errors = new VHS.api.Errors(this);
        }

        if (this.options.id !== '' && this.options.api) {
            this.getData(id, 'video', function(data){
                self._data = data;
                self.plugins.reload();
                self.renderPlayer();
            });
        } else {
            this.renderPlayer();
        }

        if (!VHS.styleLoaded) {
            this.loadControlsStyle();
        }

        this.modules.fullscreen = VHS.util.supportsFullscreen() || this.options.enableVHSFullscreen ? new VHS.api.Fullscreen(this) : null;
    },
    destroy: function(callback){
        if (this.element) {
            if (this.options.mode === 'html5') {
                if (this.element[0] && (this.status === VHS.api.status.VIDEO_PLAYING || this.status === VHS.api.status.AD_PLAYING) && typeof this.element[0].pause === 'function') {
                    this.element[0].pause();
                }
                if (this.adsController) {
                    if (typeof this.adsController.unregisterContextListeners === 'function') {
                        this.adsController.unregisterContextListeners();
                    }
                    if (this.adsController.isContentPlaying) {
                        this.adsController.stop();
                    }
                }
                this.element.attr('src', '');
                this.element.off();
                this.element.unbind();
                this.element.remove();
            } else if (this.options.mode === 'flash') {
                if (typeof swfobject !== 'undefined' && this.objectId) {
                    swfobject.removeSWF(this.objectId);
                }
            }
        }

        if (this.container) {
            this.container.remove();
        }

        delete window.vhs_instances[this.instance];
        if (typeof callback === 'function') {
            callback();
        }
    },
    /**
    Validate options
    @method validate
    @public
    **/
    validate: function(){
        var valid = true;
        if (this.options.id === '' && this.options.src === null && this.options.source === null) {
            valid = false;
            throw new Error('ID, SRC or SOURCE should be provided');
        }

        if (this.options.id === '' && this.options.name === null) {
            valid = false;
            throw new Error('NAME should be provided');
        }

        if (this.options.element === null && this.options.container === null) {
            valid = false;
            throw new Error('CONTAINER should be provided');
        }

        return valid;
    },
    /**
    Get video data from cherry
    @method getData
    @param {String} type [video|playlist]
    @param {Function} callback
    **/
    getData: function(id, type, callback){
        var url = this.apiBaseUrl + type + '/' + id;
        var jsonpCallback = id;
        var self = this;

        for (var i in window.vhs_instances) {
            if (id === window.vhs_instances[i].options.id) {
                jsonpCallback = this.instance;
            }
        }

        //handle option for share override with articleId OR blogPostUrl
        if (this.options.shareOptions) {
            if (this.options.shareOptions.articleId) {
                url += '?articleId=' + encodeURIComponent(this.options.shareOptions.articleId);
            } else if (this.options.shareOptions.blogPostUrl) {
                url += '?blogPostUrl=' + encodeURIComponent(this.options.shareOptions.blogPostUrl);
            }
        }

        $.ajax({
            url: url,
            cache: true,
            dataType: 'jsonp',
            jsonpCallback: 'vhs_callback_' + jsonpCallback,
            timeout: 15000,
            success: function(data) {
                callback(self.transformData(data, type));
            },
            error: function(e, status, errorThrown){
                self.logger.error("error", e, status, errorThrown);
                self.trigger(VHS.api.events.TRACKING_EVENT, {
                    data: {
                        name: "cherry-api-request-error",
                        errorStatus: status,
                        errorThrown: errorThrown
                    }
                });
            }
        });
    },

    /**
    * Transform data returned from scoop
    * Specifically if the byline does NOT start with 'By '
    * we will prepend 'By ' for backwards compatibility.
    *
    * @method transformData
    * @param {Object} data The data object from cherry/scoop
    * @param {String} type The type of resource requests (video|playlist)
    * @return {Object} Returns data with transformed data
    */
    transformData: function(data, type) {
        if (typeof data === 'object' && type === 'video') {
            // Transform byline for video
            if (typeof data.byline === 'string') {
                // for backwards compatibility - If byline does NOT start with 'By ' then prepend it.
                data.byline = (data.byline.toLowerCase().indexOf('by ') === 0 || data.byline.length === 0) ? data.byline : ['By ',data.byline].join('');
            }
        }
        return data;
    },

    /**
        @method renderPlayer
    **/
    renderPlayer: function(){
        var self = this;
        var renderVideo = (this.options.render && this.options.cover === false) || this.options.autoplay === true;

        this.on(VHS.api.events.RENDERED, function(){
            // We have rendered the video so wait to bind handleOnClick to the poster
            // This is so a user does not click on the poster before the swf is available under the poster
            if (renderVideo && this.modules.poster) {
                this.modules.poster.handleOnClick();
            }
        });

        this.registerSharedListeners();

        if (!this.options.autoplay) {
            this.renderPoster();
        } else {
            // for backwards compatibility
            this.poster = $('<div></div>');
        }

        if (!this.modules.responsive) {
            this.modules.responsive = new VHS.api.Responsive(this);
        }

        if ((this.options.ads && this.options.skipAd && this.options.controls) || this.options.deeplinking) {
            this.renderSkipAd();
        }

        if (!renderVideo && this.modules.poster) {
            // we are not rendering the video and we have a poster so setup click handler on poster
            // -- this will happen for cover: true
            // -- this will happen for poster true and render false
            this.modules.poster.handleOnClick();
        }

        // combining _loaded and _ready...  depricating _loaded in favor of the term _ready
        if (renderVideo) {
            // VHS to render player
            // trigger _loaded and _ready when video tag/object are rendered to the DOM
            // This will be depricated soon in favor of unifying _ready and _loaded
            // to trigger only when VHS is ready not when player rendered, but we need to refactor
            // tests so will be a larger effort.
            this.on(VHS.api.events.RENDERED, function playerRendered () {
                this._loaded();
                this._ready();
                this.off(VHS.api.events.RENDERED, playerRendered);
            });
            this.render();
        } else {
            // VHS did NOT render player (cover is on)
            // VHS is ready (container and data are loaded/ready, but the player is NOT rendered)
            // you need to listen to rendered to have confidence that the player is rendered
            this._loaded();
            this._ready();
        }
    },

    /**
    * Render the poster module
    * @method renderPoster
    *
    */
    renderPoster: function(){
        var posterUrl = null;

        if (this.modules.poster && this.modules.poster.element) {
            this.modules.poster.update();
        } else {
            this.modules.poster = new VHS.api.Poster(this);
            this.modules.poster.render();
        }
    },

    /**
        @method renderVideo
    **/
    render: function(){
    },
    /**
    Render player container
    @method renderContainer
    **/
    renderContainer: function(){
        var self = this;
        var containerOption = this.options.container;

        if (this.element) {
            //Deprecated version 1.5. Feature will be removed completed in VHS 1.6
            this.container = $('<div></div>');
            this.container.insertAfter(this.element);
        } else {
            this.container = (containerOption !== null && typeof containerOption === 'object' && containerOption.length) ? containerOption : $('#' + containerOption);
        }

        this.container.addClass('nytd-player-container');

        if (this.options.ratio === '16:9' && this.options.height === '100%' && this.options.width === '100%') {
            this.container
                .css({
                    "background": "#000",
                    "padding-bottom": "56.25%",
                    "height": 0,
                    "position": "relative",
                    "overflow": "hidden",
                    "width": VHS.util.normalizeUnit(this.options.width)
                })
                .data('ratioFix', true);
        } else {
            this.container
                .css({
                    "width": VHS.util.normalizeUnit(this.options.width),
                    "height": VHS.util.normalizeUnit(this.options.height)
            });
        }

        this.on('playing', function(){
            if (self.options.controls && self.isTouch) {
                self.modules.controls.hide();
            }
        });

        return this.container;
    },

    /**
    Load the stylesheet for the controls
    @method loadControlsStyle
    **/
    loadControlsStyle: function() {
        var head = $('head');
        var styleUrl = this.staticBaseUrl + 'video/vhs/'+ VHS._version + '-' + VHS._release + '/vhs.css';

        if (this.options.debug) {
            styleUrl = '../../'+ VHS._version + '-' + VHS._release + '/vhs.css';
            if (this.options.debugPathCSS) {
                styleUrl = this.options.debugPathCSS;
            }
        }

        if (!VHS.styleLoaded) {
            head.append('<style type="text/css">.nytd-player-controls{ display: none; }</style>');
            head.append('<link href="'+ styleUrl +'" rel="stylesheet">');
            VHS.styleLoaded = true;
        }
    },

    _skipAd: function () {
        // VHS.api.events.AD_SKIPPED event needs to go first to maintain proper state for ET analytics
        this.trigger(VHS.api.events.AD_SKIPPED);
        this.skipAd();
    },

    renderSkipAd: function(){
        var self = this;
        this.skipAdElement = $('<div class="nytd-player-ad-skip-ad" style="display: none;"><span></span><button>skip ad</button></div>');
        this.container.append(this.skipAdElement);

        this.skipAdElement.bind('click', function(e){
            if($(this).hasClass('vhs-countdown-done')) {
                e.preventDefault();
                self._skipAd();
            }
        });

        this.on(VHS.api.events.AD_STARTED, function(){
            if (self.skipAdElement) {
                self.skipAdElement
                    .removeClass('vhs-countdown-done')
                    .addClass('vhs-countdown-started')
                    .show();
                self.skipAdButtonVisible = false;
            }
        });

        this.on(VHS.api.events.AD_COMPLETED, function(){
            self.hideSkipAd();
        });

        this.on(VHS.api.events.AD_SKIPPED, function(){
            self.hideSkipAd();
        });

        this.on(VHS.api.events.AD_STOPPED, function(){
            self.hideSkipAd();
        });
    },

    hideSkipAd: function() {
        if (this.skipAdElement) {
            this.skipAdElement.hide();
        }
    },

    /**
    * My method description.  Like other pieces of your comment blocks,
    * this can span multiple lines.
    *
    * @method skipAdUpdate
    * @param {Number} unroundedTime This is the timecode of the ad that is Floating Point.
    *                               So it needs to be rounded to an Integer.
    *                               It counts down to zero from the duration.
    * @return {Undefined} Returns undefined
    */
    skipAdUpdate: function(unroundedTime){
        var timeUntilSkippable, timeUntilSkippableFormatted;
        var time = Math.round(unroundedTime);
        var formattedTime = ("0" + time).slice(-2);
        var skipLabel = this.skipAdElement.find("span");
        var skipButton = this.skipAdElement.find("button");
        var adDuration = Math.round(this.adDuration());

        if (adDuration >= this.skipAdThreshold) {
            // skippable ad (20 - 30 sec preroll)
            if (time > this.totalTimeToSkipAd) {
                timeUntilSkippable = time - this.totalTimeToSkipAd;
                timeUntilSkippableFormatted = ("0" + timeUntilSkippable).slice(-2);
                skipLabel.html("YOU CAN SKIP THIS AD IN <strong>" + timeUntilSkippableFormatted + "</strong> SECONDS");
            } else if (!this.skipAdButtonVisible) {
                // show skip
                this.skipAdElement.removeClass('vhs-countdown-started');
                this.skipAdElement.addClass('vhs-countdown-done');
                this.skipAdButtonVisible = true;
            }
        } else {
            // non-skippable ad (< 20 sec preroll)
            skipLabel.html("YOUR VIDEO WILL START IN <strong>" + formattedTime + "</strong> SECONDS");
        }
    },

    /**
    Render player controls
    @method renderControls
    **/
    renderControls: function(){
        if (!this.modules.controls) {
            this.modules.controls = new VHS.api.Controls(this);
            this.modules.controls.initialize();
            this.controls = this.modules.controls.element;
            this.modules.controls.renderHdButton(this._data && this._data.renditions && !this.options.live);
        }
    },
    /**
        @method loaded
    **/
    _loaded: function(){
        if (typeof this.options.onLoaded === 'function') {
            this.options.onLoaded.apply(this);
        }

        var len = this.loadedCallbacks.length;
        for (var i = 0; i < len; i++) {
            if (typeof this.loadedCallbacks[i] === "function") {
                this.loadedCallbacks[i].apply(this);
            }
        }

        this.isLoaded = true;
        this.container.data('loaded', true);
        this.container.trigger('vhs:loaded', this); // evt needs namespacing for Zepto
        this.trigger(VHS.api.events.LOADED);
    },
    /**
        @method loaded
    **/
    loaded: function(callback){
        if (this.isLoaded) {
            callback.apply(this);
        } else {
            this.loadedCallbacks.push(callback);
        }
    },
    /**
        @method _ready
    **/
    _ready: function(){
        if (typeof this.options.onReady === 'function') {
            this.options.onReady.apply(this);
        }

        var len = this.readyCallbacks.length;
        for (var i = 0; i < len; i++) {
            if (typeof this.readyCallbacks[i] === "function") {
                this.readyCallbacks[i].apply(this);
            }
        }

        this.isReady = true;
        this.container.data('ready', true);
        this.container.trigger('vhs:ready', this); // evt needs namespacing for Zepto
        this.trigger(VHS.api.events.READY);
        this.readyCallbacks = [];
    },
    /**
        @method ready
    **/
    ready: function(callback){
        if (this.isReady) {
            callback.apply(this);
        } else {
            this.readyCallbacks.push(callback);
        }
    },
    /**
    Add event listener
    @method on
    @param type Event type
    @param callback Callback function
    **/
    on: function(type, callback){
        if(typeof callback !== 'function'){
            throw new Error('The callback argument should be a function');
        }

        this._evts[type] = this._evts[type] || [];
        this._evts[type].unshift(callback);
    },
    /**
    Remove event listener
    @method off
    @param type Event type
    @param callback Specific callback to unbind
    **/
    off: function(type, callback){
        var callbacks;

        if (!this._evts.hasOwnProperty(type)) {
            return;
        }

        if (!callback) {
            delete this._evts[type];
            return;
        }

        callbacks = this._evts[type] || [];
        for (var i = 0, len = callbacks.length; i < len; i++) {
            if (callbacks[i] === callback) {
                callbacks.splice(i, 1);
                break;
            }
        }
    },
    /**
    Trigger event
    @method trigger
    @param type Event type
    **/
    trigger: function(type, data){
        if (this._evts && typeof this._evts === 'object') {
            for (var i in this._evts) {
                if (i === type) {
                    // loop thru callbacks for event
                    var callbacks = this._evts[i] || [];
                    for (var j = callbacks.length - 1; j >= 0; j--) {
                        if (typeof callbacks[j] === "function") {
                            callbacks[j].call(this, data);
                        }
                    }
                }
            }
        }
    },
    /**
    Toggle video volume
    @method toggleVolume
    **/
    toggleFullscreen: function(){
        this.fullscreen(!this.isFullscreen());
    },
    /**
    Check if browser is fullscreen
    @method isFullscreen
    **/
    isFullscreen: function(){
        return this.modules.fullscreen.isEnabled();
    },
    /**
    Fullscreen video
    @method fullscreen
    @param {Boolean} goFullscreen
    **/
    fullscreen: function(goFullscreen){
        if (!this.modules.fullscreen) return false;

        var fs = this.modules.fullscreen;
        var _goFullscreen = (goFullscreen === false) ? false : true;

        if (_goFullscreen && this.poster) {
            this.poster.hide();
        }

        if (_goFullscreen) {
            fs.enter();
        } else {
            fs.exit();
        }
    },
    /**
    @method getSiteSection
    **/
    getSiteSection: function(){
        var cg = $('meta[name="CG"]').attr('content') || '';
        var scg = $('meta[name="SCG"]').attr('content') || '';
        var pt = $('meta[name="PT"]').attr('content') || '';

        function isNone(meta){
            var _meta = (meta === '') ? 'none' : meta;
            return _meta.replace(/[^a-zA-Z]/g, "").toLowerCase();
        }

        var siteSection = isNone(cg) + '_' + isNone(scg) + '_' + isNone(pt);

        return siteSection;
    },
    getPlayerType: function() {
        var pt = $('meta[name="PT"]').attr('content');
        var pst = $('meta[name="PST"]').attr('content');
        var slug = $('meta[name="slug"]').attr('content');
        var pageType = (pt && pst) ? pt.toLowerCase() + '-' + pst.toLowerCase() : null;
        var type = null;

        if (this.options.type) {
            type = this.options.type;
        } else if (pageType === 'multimedia-interactive' && slug) {
            type = pageType + '|' + slug;
        } else if (pageType) {
            type = pageType;
        } else {
            this.logger.error('Player TYPE should be provided');
        }

        return type;
    },

    /**
    * Get the video id
    *
    * @public
    * @method getVideoId
    * @return {String} Returns videoId
    */
    getVideoId: function() {
        var videoId = 'unknown';
        if (this._data && this._data.id) {
            videoId = this._data.id;
        } else if (this.options && this.options.id) {
            videoId = this.options.id;
        }
        return videoId;
    },

    /**
    * Get the title of the video content
    *
    * @public
    * @method getTitle
    * @return {String} Returns title
    */
    getTitle: function() {
        var title = '';
        if (this.options.name) {
            title = this.options.name;
        } else if (this._data && this._data.headline) {
            title = this._data.headline;
        }
        return title;
    },

    /**
    * Get the category of the video content
    *
    * @public
    * @method getCategory
    * @return {String} Returns category
    */
    getCategory: function() {
        var category = '';
        if (this.options.category) {
            category = this.options.category;
        } else if (this._data && this._data.section && this._data.section.content) {
            category = this._data.section.content;
        }
        return category;
    },

    /**
    * Get the series/franchise of the video content
    *
    * @public
    * @method getSeries
    * @return {String} Returns series/franchise
    */
    getSeries: function() {
        var series = '';

        if (this.options.series) {
            series = this.options.series;
        } else if (this._data && this._data.contentSeries) {
            series = this._data.contentSeries.name;
        }

        return series;
    },


    /**
    * Get the contentLength of the video content
    *
    * @public
    * @method getDuration
    * @return {Number} Returns contentLength (must be in milliseconds)
    */
    getDuration: function() {
        var duration = 0;

        if (this.options.duration) {
            duration = this.options.duration;
        } else if (this._data && this._data.duration) {
            duration = this._data.duration;
        } else if (this.video) {
            duration = (typeof this.video.duration === 'function') ? this.video.duration() : this.video.duration;
        }

        return duration / 1000 || 0;
    },

    /**
    * Get the primary playlist id of the video content
    *
    * @public
    * @method getPrimaryPlaylistId
    * @return {Number} Returns id
    */
    getPrimaryPlaylistId: function() {
        var playlistId = '';

        if (this.options.playlistId) {
            playlistId = this.options.playlistId;
        } else if (this._data && this._data.playlist) {
            playlistId = this._data.playlist.id;
        }

        return playlistId;
    },

    /**
    Toggle play video
    @method togglePlay
    **/
    togglePlay: function(){
        // should play for  this.status === VHS.api.status.AD_OVERLAY_ACTIVE
        if (this.status !== VHS.api.status.VIDEO_PLAYING && this.status !== VHS.api.status.AD_PLAYING) {
            this.play();
        } else {
            this.pause();
        }
    },

    /**
    * Hide Controls alias to controls method hide
    * left to support legacy usage where people may be using the function
    *
    * @method hideControls
    */
    hideControls: function(){
        if (this.modules && this.modules.controls) {
            this.modules.controls.hide();
        }
    },

    /**
    * Show Controls alias to controls method show
    * left to support legacy usage where people may be using the function
    *
    * @method hideControls
    */
    showControls: function(){
        if (this.modules && this.modules.controls) {
            this.modules.controls.show();
        }
    },

    /**
    * Add the loader div to the DOM container only if it is not there already
    *
    * @method addLoader
    */
    addLoader: function() {
        if (this.container && this.options.loader) {
            if (this.container.find('.vhs-loader').length === 0) {
                this.container.append('<div class="vhs-loader"></div>');
            }
        }
    },

    /**
    * Remove the loader div
    *
    * @method removeLoader
    */
    removeLoader: function() {
        var vhs_loader;
        if (this.container) {
            vhs_loader = this.container.find('.vhs-loader');
            if (vhs_loader.length > 0) {
                vhs_loader.remove();
            }
        }
    },

    /**
    * Register Shared (Super) listeners for both HTML5 and Flash players.
    *
    * @method registerGeneralListeners
    */
    registerSharedListeners: function() {
        this.on(VHS.api.events.PLAY, function(){
            this.firstPlay = false;
            this.pauseOtherPlayers();
            this.removeLoader();
        });
        this.on(VHS.api.events.AD_STARTED, function(){
            this.firstPlay = false;
            this.pauseOtherPlayers();
            this.removeLoader();
        });
        this.on(VHS.api.events.AD_RESUMED, function(){
            this.pauseOtherPlayers();
        });
    },

    /**
    * Pause any other players on the same page
    *
    * @method pauseOtherPlayers
    */
    pauseOtherPlayers: function() {
        if (!VHS.config.allowMultiplePlayers) {
            for (var i in window.vhs_instances) {
                if (this.instance !== i) {
                    window.vhs_instances[i].pause();
                }
            }
        }
    },
    triggerHDEvent: function() {
        // trigger events for analytics
        if (this.enableHD) {
            if (Cookies.enabled) {
                Cookies.set('nytvhshd', '1');
            }
            this.trigger(VHS.api.events.HD_ON);
        } else {
            if (Cookies.enabled) {
                Cookies.set('nytvhshd');
            }
            this.trigger(VHS.api.events.HD_OFF);
        }
    },
    restoreHDState: function () {
        this.enableHD = Cookies.get('nytvhshd') === "1" ;
    },
    bindStartupSeekEvents: function() {
        var self = this;
        var evt = this.options.mode === 'html5' ? VHS.api.events.VIDEO_READY : VHS.api.events.PLAY;
        this.on(VHS.api.events.RENDERED, function startupSeekHandler() {
            this.on(evt, function playOnRendered() {
                self.off(evt, playOnRendered);
                if (this.startupSeek < this.getDuration()) {
                    self.seek(this.startupSeek);
                }
            });
            this.off(VHS.api.events.RENDERED, startupSeekHandler);
        });

        if (this.options.ads) {
            this.on(VHS.api.events.AD_COMPLETED, function startupSeekAdCompleted() {
                this.on(evt, function playOnAdCompleted() {
                    self.off(evt, playOnAdCompleted);
                    if (this.startupSeek < this.getDuration()) {
                        self.seek(this.startupSeek);
                    }
                });
                this.off(VHS.api.events.AD_COMPLETED, startupSeekAdCompleted);
            });

            this.on(VHS.api.events.AD_SKIPPED, function startupSeekAdSkipped() {
                this.on(evt, function playOnAdSkipped() {
                    self.off(evt, playOnAdSkipped);
                    if (this.startupSeek < this.getDuration()) {
                        self.seek(this.startupSeek);
                    }
                });
                this.off(VHS.api.events.AD_SKIPPED, startupSeekAdSkipped);
            });
        }

        this.on(VHS.api.events.ENDED, function onEndedHandler() {
            self.off(VHS.api.events.ENDED, onEndedHandler);
            self.resetStartupSeekState();
        });
    },
    resetStartupSeekState: function() {
        this.options.ads = this.defaultAdsState ? this.defaultAdsState: this.options.ads;
        if (this.options.mode === 'flash' && this.startupSeek) {
            this.restoreAdsStatus();
        }
        this.startupSeek = undefined;
    },
    detectTearsheeting: function () {
        if (!VHS.config.ts) {
            VHS.config.ts = true;
            (function (isProd) {
                var qs = window.location.search;
                var cookieValue = '';
                var cookieName = '_ro';
                var days = 1;
                // when tsdel=value is passed the cookie is deleted
                var qsDel;
                // sets the id to use for tearsheeting
                var qsPid;
                var fwServer;
                var date;
                var pid;

                if (!qs) {
                    return;
                }

                qsDel = /[&?]tsdel=/.exec(qs);
                // only create cookie if not in delete mode
                if (!qsDel) {
                    qsPid = /[&?]tspid=([^&#]*)/.exec(qs);
                    // exit early when tsdel and tspid querystrings are not present
                    if (!qsPid) {
                        return;
                    }
                    pid = qsPid[1];
                    fwServer =  isProd ? "tearsheet.fw.nytimes.com" : "tearsheet.fw.stg.nytimes.com";
                    cookieValue = encodeURIComponent([
                        "Candidate-Ads=", pid ,";",
                        "Internal-Call;",
                        "Opt-Out;",
                        "Testing-Placement=true;",
                        "Commercial-Pattern=14852;;",
                        "Target-Server;",
                        "domain=", fwServer ,";",
                        "Reload-Ads=", pid
                    ].join(''));
                }

                // set cookie date
                date = new Date();
                date.setTime(date.getTime()+(days*24*60*60*1000));
                document.cookie = cookieName +"=" + cookieValue + ";expires=" + date + ";domain=.nytimes.com;path=/";
            })(this.options.env === 'production');
        }
    }
};

/**
@class HtmlFive
@module VHS.api
@constructor
@param {Object}
    @param options.width {String}
    @param options.height {String}
    @param options.autoplay {Bollean}
    @param options.poster {Bollean|String} if its set to true, asset comes from brighcove, if its a string, we expect a URL
**/
VHS.api.HtmlFive = function(options, instance) {
    VHS.api.Player.call(this, options, instance);
};

VHS.api.HtmlFive.prototype = VHS.util.extend(VHS.api.Player.prototype);

VHS.api.HtmlFive.prototype.getType = function () {
    return 'html5';
};

VHS.api.HtmlFive.prototype.load = function(id, play) {
    var self = this;
    var playAfterLoad = play || false;

    this.loadingVideo = true;

    // reset hdRenditionChanging (fail safe)
    this.hdRenditionChanging = false;

    this.resetStartupSeekState();

    this.getData(id, 'video', function(data) {
        self._data = data;
        self.plugins.reload();
        self.renderSource();
        self.trigger(VHS.api.events.LOAD_START);
        if (self.modules.poster) {
            self.modules.poster.update();
            // if we have a native poster remove it before loading another video so we do not flash a poster img
            if (self.options.nativePoster) {
                self.modules.poster.removeNativePoster();
            }
        }
        self.element[0].load();

        if (self.adPlaying()) {
            self.trigger(VHS.api.events.AD_STOPPED);
        }

        if (self.adsController) {
            self.adsController.isCompleted = false;
            self.adsController.isContentPlaying = false;
        }

        if (playAfterLoad) {
            self.play();
        }
    });
};

VHS.api.HtmlFive.prototype.render = function() {
    // if muted set, mute the player once the player plugins have loaded
    this.on(VHS.api.events.RENDERED, function() {
        if (this.options.muted) {
            this.mute(true);
        }
        this.trigger(VHS.api.events.LOAD_START);

        if (this.options.autoplay) {
            this.play();
        }
    });

    if (this.startupSeek) {
      this.bindStartupSeekEvents();
    }

    // only add loader if we know a render will be followed by a play (autoplay)
    if (this.options.autoplay) {
        this.addLoader();
    }

    this.renderElement();
    this.container.append(this.element);
    this.primeVideoElement();
    this.renderElementAttr();
    this.renderSource();

    if (this.options.controls && !this.options.nativeControls) {
        this.renderControls();
        //bind source errors for html5 only
        this.element.find('source').on('error', $.proxy(this.modules.controls.onSourceError, this.modules.controls));
    }

    this.registerListeners();
    this.rendered = true;
    this.trigger(VHS.api.events.RENDERED);
};

/**
 * On mobile playback must occur within the same event loop as the click.
 * There can be no callbacks in the path from click to play.
 * To allow for a callback to get the data we prime the video element after we render it on mobile.
 *
 * @private
 * @method primeVideoElement
 * @return {undefined} Returns undefined
 */
VHS.api.HtmlFive.prototype.primeVideoElement = function() {
    var isMobileDevice = (VHS.util.isIpad() || VHS.util.isIphone() || VHS.util.isAndroid());
    if (isMobileDevice && this.element && this.element.length > 0) {
        this.element[0].play();
        this.element[0].pause();
    }
};

VHS.api.HtmlFive.prototype.renderElement = function() {
    if (this.options.element) {
        var element = this.options.element;
        this.element = element.clone(true);
        element.remove();
    } else {
        this.element = $('<video />');
    }
};

VHS.api.HtmlFive.prototype.renderElementAttr = function() {
    var posterUrl;
    var idAttr = this.element.attr('id');
    var preload = (this.options.cover || this.options.autoplay) ? 'auto' : this.options.preload;

    this.element
        .attr({
            "preload": preload,
            "x-webkit-airplay": "allow"
        });

    this.element
        .css({
            "height": '100%',
            "width": '100%'
        });

    if (this.options.ratio === '16:9' && this.options.height === '100%' && this.options.width === '100%') {
        this.element
            .css({
                "position": "absolute",
                "top": 0,
                "left": 0
            });
    }

    // adding loop attr
    if (this.options.loop) {
        this.element.attr('loop', 'loop');
    }

    if (this.options.src) {
        this.element.attr('src', this.options.src);
    }

    if (!idAttr || idAttr === '') {
        this.element.attr('id', 'video_' + new Date().getTime());
    }

    if (this.options.nativeControls || this.device === 'android_legacy' || this.device === 'ie_mobile') {
        this.options.nativeControls = true;
        this.element.attr('controls', 'controls');
    }

    if (this.modules.poster && this.options.nativePoster) {
        this.modules.poster.renderNativePoster();
    }

};

VHS.api.HtmlFive.prototype.renderSource = function() {
    var source, renditionUrl;
    if (this.options.src) {
        renditionUrl = this.options.src;
    } else if (this.options.source) {
        this.element.empty();
        for (var type in this.options.source) {
            source = $('<source />');
            source.attr({
                'src': this.options.source[type],
                'type': type
            });

            this.element.append(source);
        }
    } else if (this._data && this._data.renditions) {
        renditionUrl = this.modules.renditions.getClosestRenditionUrl(this._data.renditions, this.element.height(), this.enableHD);
    }

    if (renditionUrl) {
        this.element.attr("src", renditionUrl);
        this.modules.renditions.setActive(renditionUrl);
    } else if (this.options.source) {
        // if a source object is provided just set the rendition to the object
        this.modules.renditions.setActive(this.options.source);
    } else {
        this.trigger(VHS.api.events.RENDITION_NOT_FOUND);
        this.modules.renditions.resetActive();
    }
    this.videoChanged = true;
};

VHS.api.HtmlFive.prototype.adPlaying = function() {
    if (this.adsController && this.adsController.isContentPlaying) {
        return true;
    } else {
        return false;
    }
};

VHS.api.HtmlFive.prototype.adInitializing = function() {
    if (this.adsController && this.adsController.isInitializing) {
        return true;
    } else {
        return false;
    }
};

VHS.api.HtmlFive.prototype.adCompleted = function() {
    if (this.adsController && this.adsController.isCompleted) {
        return true;
    } else {
        return false;
    }
};


/**
* Get the Ad Title
*
* @public
* @method getAdTitle
* @return {String} Returns adTitle
*/
VHS.api.HtmlFive.prototype.getAdTitle = function() {
    var adTitle = '';
    if (this.adsController) {
        adTitle = this.adsController.getAdTitle();
    }
    return adTitle;
};

VHS.api.HtmlFive.prototype.fixForAndroidHLSBug = function() {
    if (this.device === "android_jellybean" && this.firstEnded) {
        this.pause();
        this.play();
        this.firstEnded = false;
    }
};

/**
Register Listeners
@method registerListeners
**/
VHS.api.HtmlFive.prototype.registerListeners = function() {
    var self = this;
    var nativeControls = this.element.attr('controls');
    this.video = this.element[0];

    if (this.listenersInitialized === false) {
        this.element.on(VHS.api.events.LOADED_DATA, function() {
            self.trigger(VHS.api.events.VIDEO_READY);
        });

        this.element.on('play', function() {
            self.logger.log('html5 play event');

            if (self.options.ads && !self.adPlaying() && !self.adCompleted() && VHS.util.supportsAds()) {
                if (self.adsController) {
                    self.adsController.nextAd(function(err, ads) {
                        this.start();
                    });
                } else {
                    self.adsController = new VHS.html.Ads(self, function(err, ads) {
                        this.start();
                    });
                }
            } else if (self.adPaused && !self.adCompleted()) {
                self.adPaused = false;
                self.status = VHS.api.status.AD_PLAYING;
                self.trigger(VHS.api.events.AD_RESUMED);
                self.loadingVideo = false;
            } else if (!self.adPlaying()) {
                self.status = VHS.api.status.VIDEO_PLAYING;
                self.trigger(VHS.api.events.PLAY);
                self.loadingVideo = false;
            } else {
                self.loadingVideo = false;
            }

            self.ended = false;
        });

        if (!nativeControls && !this.isTouch) {
            this.element.on('click', function(e) {
                self.togglePlay();
                e.stopPropagation();
            });
        }

        this.element.on('playing', function() {
            self.logger.log('html5 playing event');

            if (self.modules.poster) {
                self.modules.poster.hide();
            }

            if (!self.adPlaying() && !self.adInitializing()) {
                self.status = VHS.api.status.VIDEO_PLAYING;
                self.trigger(VHS.api.events.PLAYING);
            }
            self.ended = false;
        });

        this.element.on('progress', function(evt) {
            if (!self.adPlaying()) {
                self.trigger(VHS.api.events.PROGRESS, evt);
            } else {
                self.trigger(VHS.api.events.AD_PROGRESS, evt);
            }
        });

        this.element.on('timeupdate', function(e) {
            if (!self.adPlaying()) {
                self.trigger(VHS.api.events.TIME_UPDATE, self.video.currentTime);
            } else {
                self.trigger(VHS.api.events.AD_TIME_UPDATE, self.video.currentTime);
            }
        });

        this.element.on('seeked', function() {
            self.logger.log('html5 seeked event');
            if (!self.adPlaying()) {
                self.trigger(VHS.api.events.SEEKED);
            }
        });

        this.element.on('pause', function() {
            self.logger.log('html5 pause event');
            if (!self.adPlaying() && !self.adInitializing()) {
                // need to add 'self.ended' flag for IE9 which is reporting element ended incorrectly
                // need to add 'self.loadingVideo' flag for IE9 which is triggering a pause when we load a new video in the video tag
                if (self.element && self.element[0] && !self.element[0].ended && !self.ended && !self.loadingVideo) {
                    self.trigger(VHS.api.events.PAUSE);
                    self.status = VHS.api.status.VIDEO_PAUSED;
                }
            } else {
                if (self.element && self.element[0] && !self.element[0].ended && !self.ended && self.adPlaying() && !self.adSkipped && !self.loadingVideo) {
                    self.adPaused = true;
                    self.trigger(VHS.api.events.AD_PAUSED);
                    self.status = VHS.api.status.AD_PAUSED;
                }
            }
        });

        this.element.on('durationchange', function() {
            self.trigger(VHS.api.events.DURATION_CHANGE, self.element[0].duration || 0);
        });

        this.element.on('ended', function() {
            self.logger.log('html5 ended event');
            if (!self.adPlaying()) {
                self.status = VHS.api.status.VIDEO_ENDED;
                self.trigger(VHS.api.events.ENDED);
            }

            if (self.options.live) {
                self.fixForAndroidHLSBug();
            }
            self.ended = true;
        });

        this.element.on(VHS.api.events.ERROR, function(evt) {
            self.logger.log('html5 error event', evt);
            self.trigger(VHS.api.events.ERROR, evt);
        });

        this.element.on(VHS.api.events.STALLED, function(evt) {
            self.logger.log('html5 stalled event', evt);
            self.trigger(VHS.api.events.STALLED, evt);
        });

        this.element.on(VHS.api.events.WAITING, function() {
            self.logger.log('html5 waiting event');
            self.trigger(VHS.api.events.WAITING);
        });

        this.initializeSpacebarToggle();

        this.listenersInitialized = true;
    }

};

/**
* Initialize the spacebar toggle functionality for HTML5 player.
* Flash is handled in the swf. We can simplify by moving the logic to the container eventually.
* The container div needs to have a tabindex for key strokes to be bound to the div.
* To get rid of the focus visual indicator be sure to set outline: none in the css for the div in use.
* Only valid for keyCode 32 (spacebar).
* Private by convention, not for external use.
*
* @private
* @method initializeSpacebarToggle
* @return {undefined} Returns undefined
*/
VHS.api.HtmlFive.prototype.initializeSpacebarToggle = function() {
    var self = this;

    if (!this.options.spacebarToggleEnabled) return;

    // you need to set a tabindex on a div to be able to bind to key commands
    this.container.attr('tabindex', '-1');
    this.container.off('keydown.vhs');
    this.container.on('keydown.vhs', function(evt) {
        if (evt && evt.keyCode === 32) {
            evt.preventDefault();
            self.togglePlay();
        }
    });
};

/**
Reload video
@method reloadVideo
**/
VHS.api.HtmlFive.prototype.reloadVideo = function() {
    if (this.element && this.element.length > 0) {
        this.element[0].load();
        this.element[0].play();
        this.trigger(VHS.api.events.LOAD_START);
    }
};

/**
Toggle video volume
@method toggleVolume
**/
VHS.api.HtmlFive.prototype.toggleVolume = function() {
    this.mute(!this.isMuted());
};

/**
Toggle video volume
@method toggleVolume
**/
VHS.api.HtmlFive.prototype.duration = function() {
    return this.element[0].duration || 0;
};
/**
Play video
@method play
**/
VHS.api.HtmlFive.prototype.play = function() {
    var self = this;

    // only add loader for a first play and it was not added already because we are NOT autplaying
    if (this.firstPlay && !this.options.autoplay) {
        this.addLoader();
    }

    // setup a tracking session for a video in conviva
    // only start the session if a new src has been added to the video element
    var convivaTrack = function() {
        var continueWithPlay = true;
        if (self.videoChanged && self.options.conviva && self.modules && self.modules.conviva && !VHS.libraries.conviva.failed) {
            continueWithPlay = self.modules.conviva.trackVideo();
            if (continueWithPlay) {
                self.videoChanged = false;
            }
        }
        return continueWithPlay;
    };

    var safePlay = function() {
        if (convivaTrack()) {
            if (self.modules.renditions.getActive() && self.element && self.element.length > 0) {
                self.element[0].play();
            }
        }
    };

    if (!this.rendered) {
        if (VHS.util.getDeviceType() === 'desktop') {
            this.on(VHS.api.events.LOAD_START, function checkForPlay() {
                safePlay();
                self.off(VHS.api.events.LOAD_START, checkForPlay);
            });
            this.render();
        } else {
            // for one-click play in mobile need to call play immediately
            this.render();
            safePlay();
        }
    } else {
        safePlay();
    }
};

/**
Pause video
@method pause
**/
VHS.api.HtmlFive.prototype.pause = function() {
    this.element[0].pause();
    if (this.status !== VHS.api.status.VIDEO_PAUSED) {
        this.status = VHS.api.status.VIDEO_PAUSED;
    }
};

/**
* isPaused method.  Returns value of video tag property 'paused'.
* If there is no tag on the page we return undefined.
* If the element is NOT there returns, true to indicate video paused
*
* @method isPaused
* @return {Boolean} Returns true on paused
*/
VHS.api.HtmlFive.prototype.isPaused = function() {
    return (this.element && this.element.length > 0) ? this.element[0].paused : true;
};

/**
Unmute video
@method mute
@param {Boolean} muted Default True, passing false unmute the player
**/
VHS.api.HtmlFive.prototype.mute = function(mute) {
    var muted, volume;

    muted = (mute === false) ? false : true;
    this.element[0].muted = muted;

    this.trigger(VHS.api.events.MUTE, muted);
};

/**
* Check if the video element is muted.
*
* @method isMuted
* @return {Boolean} Returns true on set
*/
VHS.api.HtmlFive.prototype.isMuted = function() {
    return (this.element && this.element.length > 0) ? this.element[0].muted : undefined;
};

/**
 * Get current time
 */
VHS.api.HtmlFive.prototype.getCurrentTime = function() {
    return this.element && this.element[0] ? this.element[0].currentTime : 0;
};

/**
Seek video
@method seek
@param {Number} current time in seconds
**/
VHS.api.HtmlFive.prototype.seek = function(time) {
    var video = this.element[0];

    if(typeof time !== 'number') {
        throw new Error('time argument should be a Number');
    }

    if(time < 0 || time > video.duration) {
        throw new Error('time should be greater than 0 and lower than the duration of the video');
    }

    video.currentTime = time;
};

VHS.api.HtmlFive.prototype.skipAd = function() {
    this.adSkipped = true;
    this.adsController.stop();
};

/**
* Get the Ad Duration from either the ad instance data or from the video element duration
*
* @public
* @method adDuration
* @return {Number} Returns duration
*/
VHS.api.HtmlFive.prototype.adDuration = function() {
    var duration = 0;
    if (this.adsController) {
        if (this.adsController.currentSlot) {
            duration = this.adsController.currentSlot.getTotalDuration(true) || 0;
        } else {
            duration = this.adsController.getAdInstanceDuration();
        }
    } else if (this.element) {
        duration = this.element[0].duration;
    }
    return duration;
};

VHS.api.HtmlFive.prototype.toggleHD = function () {
    var self = this;
    var video = this.element.get(0);
    var currentTime = video.currentTime;
    this.hdRenditionChanging = true;
    this.enableHD = !this.enableHD;
    video.pause();
    this.renderSource();
    this.triggerHDEvent();

    this.element.one('canplaythrough', function () {
        video.currentTime = currentTime;
        video.play();
    });
    this.element.one('seeked', function() {
        self.hdRenditionChanging = false;
    });
    video.load();
};


/**
@class Ads
@module VHS.html
@constructor
**/
VHS.html.Ads = function(player, callback){
    var self = this;
    var isProd = true;

    this.player = player;
    this.callback = callback;
    this.adsLoaded = false;
    this.serverURL = 'http://fw.nytimes.com/ad/g/1';
    this.siteSectionId = this.player.options.siteSection || this.player.options.freewheel || this.player.getSiteSection();
    this.isCompleted = false;
    this.isContentPlaying = false;
    this.currentSlot = null;
    this.isInitializing = true;
    this.adStarted = false;

    switch(this.player.options.env) {
        case 'development':
        case 'staging':
            this.networkId = 379535;
            this.profileId = '379535:ny_times_js_test';
            this.adManagerUrl = 'http://adm.fwmrm.net/p/nytimes_test/AdManager.js';
            this.serverURL = 'http://fw.stg.nytimes.com/ad/g/1';
            isProd = false;
            break;
        default:
            this.networkId = 379536;
            this.profileId = "379536:ny_times_js_live";
            this.adManagerUrl = 'http://adm.fwmrm.net/p/nytimes_live/AdManager.js';
            break;
    }

    this.player.element[0].pause();

    this.loadAdManager(function(){
        self.adManager = new tv.freewheel.SDK.AdManager();
        self.adManager.setNetwork(self.networkId);
        self.adManager.setServer(self.serverURL);
        self.setupAdContext();
    });
};
/**
Load The Next Ad for the Next Video
@method nextAd
**/
VHS.html.Ads.prototype.nextAd = function(callback) {
    this.callback = callback;
    this.isCompleted = false;

    // reinit context & request ad
    this.setupAdContext();
};

/**
Load Google SDK
@method loadGoogleSdk
@param {Function} callback
**/
VHS.html.Ads.prototype.loadAdManager = function(callback){
    var self = this;

    // handle loading ad manager error
    var errorLoadingAdManager = function(err, errStatus, errThrown) {
        // turn off ads
        this.player.options.ads = false;

        // set flags
        this.adStarted = false;
        this.isCompleted = true;
        this.isContentPlaying = false;
        this.isInitializing = false;
        this.player.adSkipped = false;

        // continue to play the content
        this.player.element[0].play();

        // log error
        this.player.trigger(VHS.api.events.TRACKING_EVENT, {
            data: {
                name: VHS.api.events.FW_ADMANAGER_LOAD_ERROR,
                errorStatus: errStatus || '',
                errorThrown: errThrown || ''
            }
        });
    };

    // load ad manager
    VHS.util.getScript({
        url: self.adManagerUrl,
        success: function() {
            callback.call(self);
        },
        error: function(err, errStatus, errThrown) {
            errorLoadingAdManager.call(self, err, errStatus, errThrown);
        },
        cache: true,
        dataType: 'script',
        timeout: 5000
    });
};

/**
Setup Ad Context
@method setupAdContext
**/
VHS.html.Ads.prototype.setupAdContext = function(){
    var video = this.player.element;
    var videoId = this.player.element.attr('id');
    var containerId = this.player.container.attr('id');
    var videoDuration = this.player.getDuration();
    var videoAssetId = this.player.instance;

    // _data can not contain an id parameter if not a valid glass id
    // in that scenio use the options id if provided
    // default to using the player instance if no data id is valid and an options id was not provided
    if (this.player._data && this.player._data.id) {
        videoAssetId = this.player._data.id;
    } else if (this.player.options && this.player.options.id) {
        videoAssetId = this.player.options.id;
    }

    // destroy context
    if (this.theContext && typeof this.theContext.dispose === 'function') {
        this.unregisterContextListeners();
        this.theContext.dispose();
    }

    this.theContext = this.adManager.newContext();

    //set video container
    this.theContext.registerVideoDisplayBase(containerId);

    //set profile
    this.theContext.setProfile(this.profileId);

    // set the asset
    this.theContext.setVideoAsset(videoAssetId, videoDuration, this.networkId);

    // set section (similar to adxPagename)
    this.theContext.setSiteSection(this.siteSectionId, this.networkId);

    // Listen to AdManager Events
    this.registerContextListeners();

    //To make sure video ad playback in poor network condition, set video ad timeout parameters.
    this.theContext.setParameter(tv.freewheel.SDK.PARAMETER_RENDERER_VIDEO_START_DETECT_TIMEOUT, 10000, tv.freewheel.SDK.PARAMETER_LEVEL_GLOBAL);
    this.theContext.setParameter(tv.freewheel.SDK.PARAMETER_RENDERER_VIDEO_PROGRESS_DETECT_TIMEOUT, 10000, tv.freewheel.SDK.PARAMETER_LEVEL_GLOBAL);

    // do not show native controls when ad is paused
    this.theContext.setParameter(tv.freewheel.SDK.PARAMETER_RENDERER_VIDEO_DISPLAY_CONTROLS_WHEN_PAUSE, false, tv.freewheel.SDK.PARAMETER_LEVEL_GLOBAL);

    // add preroll slot
    this.theContext.addTemporalSlot("Preroll_1", tv.freewheel.SDK.ADUNIT_PREROLL, 0);

    //request ads (add a timesout 2sec)
    this.theContext.submitRequest(2);
};
/**
@method registerContextListeners
**/
VHS.html.Ads.prototype.registerContextListeners = function() {
    if (this.theContext && tv && tv.freewheel && typeof this.theContext.addEventListener === 'function') {
        this.theContext.addEventListener(tv.freewheel.SDK.EVENT_REQUEST_COMPLETE, $.proxy(this.onRequestComplete, this));
        this.theContext.addEventListener(tv.freewheel.SDK.EVENT_SLOT_ENDED, $.proxy(this.onSlotEnded, this));
        this.theContext.addEventListener(tv.freewheel.SDK.EVENT_SLOT_STARTED, $.proxy(this.onSlotStarted, this));
        this.theContext.addEventListener(tv.freewheel.SDK.EVENT_AD, $.proxy(this.onEventAd, this));

    }
};
/**
@method unregisterContextListeners
**/
VHS.html.Ads.prototype.unregisterContextListeners = function() {
    if (this.theContext && tv && tv.freewheel && typeof this.theContext.removeEventListener === 'function') {
        this.theContext.removeEventListener(tv.freewheel.SDK.EVENT_REQUEST_COMPLETE);
        this.theContext.removeEventListener(tv.freewheel.SDK.EVENT_SLOT_ENDED);
        this.theContext.removeEventListener(tv.freewheel.SDK.EVENT_SLOT_STARTED);
        this.theContext.removeEventListener(tv.freewheel.SDK.EVENT_AD, $.proxy(this.onEventAd, this));
    }
};
/**
@method onRequestComplete
**/
VHS.html.Ads.prototype.onRequestComplete = function(evt) {
    this.adsLoaded = true;

    // initialize slots
    this.prerollSlots = [];
    this.midrollSlots = [];
    this.overlaySlots = [];
    this.postrollSlots = [];

    // populate slots
    if (evt.success){
        var fwTemporalSlots = this.theContext.getTemporalSlots();
        for (var i = 0, slotsLength = fwTemporalSlots.length; i < slotsLength; i++) {
            var slot = fwTemporalSlots[i];
            switch (slot.getTimePositionClass()) {
                case tv.freewheel.SDK.TIME_POSITION_CLASS_PREROLL:
                    this.prerollSlots.push(slot);
                    break;

                case tv.freewheel.SDK.TIME_POSITION_CLASS_MIDROLL:
                    this.midrollSlots.push(slot);
                    break;

                case tv.freewheel.SDK.TIME_POSITION_CLASS_OVERLAY:
                    this.overlaySlots.push(slot);
                    break;

                case tv.freewheel.SDK.TIME_POSITION_CLASS_POSTROLL:
                    this.postrollSlots.push(slot);
                    break;
            }
        }
    }

    if (this.prerollSlots && this.prerollSlots.length){
        this.callback(null, this.prerollSlots);
    } else {
        this.callback(new Error('No prerolls available'));
    }
};
/**
@method getState
**/
VHS.html.Ads.prototype.getState = function() {
    return this.isCompleted;
};

VHS.html.Ads.prototype.onEventAd = function(evt) {
    if (evt && evt.subType) {
        switch(evt.subType) {
            case tv.freewheel.SDK.EVENT_AD_FIRST_QUARTILE:
                this.player.trigger(VHS.api.events.AD_FIRST_QUARTILE);
                break;
            case tv.freewheel.SDK.EVENT_AD_MIDPOINT:
                this.player.trigger(VHS.api.events.AD_MIDPOINT);
                break;
            case tv.freewheel.SDK.EVENT_AD_THIRD_QUARTILE:
                this.player.trigger(VHS.api.events.AD_THIRD_QUARTILE);
                break;
            case tv.freewheel.SDK.EVENT_ERROR:
                this.player.trigger(VHS.api.events.AD_ERROR, evt);
                break;

            case tv.freewheel.SDK.EVENT_AD_CLICK:
            case tv.freewheel.SDK.EVENT_AD_IMPRESSION:
            case tv.freewheel.SDK.EVENT_AD_IMPRESSION_END:
            case tv.freewheel.SDK.EVENT_AD_COMPLETE:
            case tv.freewheel.SDK.EVENT_AD_MUTE:
            case tv.freewheel.SDK.EVENT_AD_UNMUTE:
            case tv.freewheel.SDK.EVENT_AD_PAUSE:
            case tv.freewheel.SDK.EVENT_AD_RESUME:
            case tv.freewheel.SDK.EVENT_AD_REWIND:
            case tv.freewheel.SDK.EVENT_AD_EXPAND:
            case tv.freewheel.SDK.EVENT_AD_COLLAPSE:
            case tv.freewheel.SDK.EVENT_AD_MINIMIZE:
            case tv.freewheel.SDK.EVENT_AD_ACCEPT_INVITATION:
            case tv.freewheel.SDK.EVENT_AD_CLOSE:
            case tv.freewheel.SDK.EVENT_RESELLER_NO_AD:
                break;
        }
    }
};

/**
@method onSlotStarted
**/
VHS.html.Ads.prototype.onSlotStarted = function(evt) {
    var slotTimePositionClass = evt.slot.getTimePositionClass();
    var slotTotalDuration = evt.slot.getTotalDuration();

    if (slotTotalDuration > 0) {
        switch (slotTimePositionClass) {
            case tv.freewheel.SDK.TIME_POSITION_CLASS_PREROLL:
                this.isCompleted = false;
                this.isContentPlaying = true;
                this.adStarted = true;
                this.setCurrentlyPlayingSlot(this.prerollSlots[0]);
                this.player.trigger(VHS.api.events.AD_STARTED);
                break;
        }
    }

};
/**
@method onSlotEnded
**/
VHS.html.Ads.prototype.onSlotEnded = function(evt) {
    var slotTimePositionClass = evt.slot.getTimePositionClass();
    var slotTotalDuration = evt.slot.getTotalDuration();

    switch (slotTimePositionClass) {
        case tv.freewheel.SDK.TIME_POSITION_CLASS_PREROLL:
                if (this.prerollSlots.length){
                        this.prerollSlots.shift();

                        if (this.prerollSlots.length) {
                            this.prerollSlots[0].play();
                            this.setCurrentlyPlayingSlot(this.prerollSlots[0]);
                        } else {
                            this.resumeContent(slotTotalDuration);
                        }
                }
                break;

        case tv.freewheel.SDK.TIME_POSITION_CLASS_POSTROLL:
        case tv.freewheel.SDK.TIME_POSITION_CLASS_MIDROLL:
        case tv.freewheel.SDK.TIME_POSITION_CLASS_OVERLAY:
        case tv.freewheel.SDK.TIME_POSITION_CLASS_DISPLAY:
                break;
    }
};

VHS.html.Ads.prototype.setPlayerSource = function () {
    var self = this;
    var source = this.player.modules.renditions.getActive();
    var hasSourceTag = this.player.element.find('source').length > 0;

    if (hasSourceTag) {
        this.player.element.removeAttr('src');
    } else {
        this.player.element.attr('src', source);
    }
};

/**
Resume Video Content after and Ad or an Ad Error
@method resumeContent
**/
VHS.html.Ads.prototype.resumeContent = function(adDuration) {
    var self = this;

    // if we have not skipped the ad AND we have adDuration OR the ad has started, then send an ad_complete event
    if (!this.player.adSkipped && ( (adDuration && adDuration > 0) || this.adStarted ) ) {
        this.player.trigger(VHS.api.events.AD_COMPLETED);
    }

    this.adStarted = false;
    this.isCompleted = true;
    this.isContentPlaying = false;

    this.setPlayerSource();
    this.player.element[0].load();
    // start the conviva session for the video content
    if (this.player && this.player.options.conviva && this.player.modules && this.player.modules.conviva) {
        this.player.modules.conviva.startConvivaSession();
    }
    this.player.element[0].play();
    this.setCurrentlyPlayingSlot(null);

    // reset state of video to playing
    if (this.theContext) {
        this.theContext.setVideoState(tv.freewheel.SDK.VIDEO_STATE_PLAYING);
    }

    // setup listener to put video state into complete when video is ended
    this.player.on(VHS.api.events.ENDED, function(){
        if (self.theContext) {
            self.theContext.setVideoState(tv.freewheel.SDK.VIDEO_STATE_COMPLETED);
        }
    });

    this.player.adSkipped = false;
};

/**
Set the currently playing slot
@method setCurrentlyPlayingSlot
**/
VHS.html.Ads.prototype.setCurrentlyPlayingSlot = function(slot) {
    this.currentSlot = slot;
};

/**
* Get currently playing slot
*
* @public
* @method getCurrentlyPlayingSlot
* @return {Object} Returns slot (tv.freewheel.SDK.slot)
*/
VHS.html.Ads.prototype.getCurrentlyPlayingSlot = function() {
    return this.currentSlot;
};

/**
* Get the Ad Title
*
* @public
* @method getAdTitle
* @return {String} Returns adId (tv.freewheel.SDK.AdInstance.prototype.getAdId)
*/
VHS.html.Ads.prototype.getAdTitle = function() {
    var slot = this.getCurrentlyPlayingSlot();
    var adInstances = [];
    var adId = '';
    var adInstance;

    if (slot) {
        adInstances = slot.getAdInstances();
        if (adInstances.length > 0) {
            adInstance = adInstances[0];
            if (adInstance) {
                adId = adInstance.getAdId();
            }
        }
    }

    return adId;
};

/**
* Get the Ad Instance Duration
*
* @public
* @method getAdInstanceDuration
* @return {Number} Returns duration (tv.freewheel.SDK.AdInstance.prototype.getDuration)
*/
VHS.html.Ads.prototype.getAdInstanceDuration = function() {
    var slot = this.getCurrentlyPlayingSlot();
    var adInstances = [];
    var duration = 0;
    var adInstance;

    if (slot) {
        adInstances = slot.getAdInstances();
        if (adInstances.length > 0) {
            adInstance = adInstances[0];
            if (adInstance) {
                duration = adInstance.getDuration();
            }
        }
    }

    return duration;
};

/**
Start the currently queued ad
@method start
**/
VHS.html.Ads.prototype.start = function() {
    this.isInitializing = false;
    if (this.player.options.ads) {
        if (this.prerollSlots && this.prerollSlots.length) {
            this.isCompleted = false;
            this.isContentPlaying = true;
            this.setCurrentlyPlayingSlot(this.prerollSlots[0]);
            this.prerollSlots[0].play();
        } else {
            // no ad so just resume content
            this.resumeContent();
        }
    }
};

/**
Stop the currently playing ad
@method resume
**/
VHS.html.Ads.prototype.stop = function() {
    if (this.currentSlot) {
        this.currentSlot.stop();
    }
};

/**
Pause the currently playing ad
@method pause
**/
VHS.html.Ads.prototype.pause = function() {
    this.player.element[0].pause();
};

/**
Resume the currently playing ad
@method resume
**/
VHS.html.Ads.prototype.resume = function() {
    this.player.element[0].play();
};

/**
@class Flash
@module VHS
@submodule api
@constructor
@param {Object}
    @param options.width {String}
    @param options.height {String}
    @param options.autoplay {Bollean}
    @param options.poster {Bollean|String} if its set to true, asset comes from brighcove, if its a string, we expect a URL
**/
VHS.api.Flash = function(options, instance) {
    VHS.api.Player.call(this, options, instance);
};

VHS.api.Flash.prototype = VHS.util.extend(VHS.api.Player.prototype);

VHS.api.Flash.prototype.getType = function () {
    return 'flash';
};

VHS.api.Flash.prototype.load = function(id, play) {
    var self = this;
    var playAfterLoad = play || false;

    // reset hdRenditionChanging (fail safe)
    this.hdRenditionChanging = false;

    this.resetStartupSeekState();

    if (this.adPlaying()) {
        // stops the ad and does NOT play the content
        this.stopAd();
    }

    this.getData(id, 'video', function(data) {
        self._data = data;
        self.plugins.reload();
        self.renderSource();
        self.trigger(VHS.api.events.LOAD_START);
        if (self.modules.poster) {
            self.modules.poster.update();
        }

        if (playAfterLoad) {
            self.play();
        }
    });
};

/**
This function is necessary on flash playback only.
If the first video being played uses deeplinking,
we want to restore the ads state for the next ones.
@method restoreAdsStatus
**/
VHS.api.Flash.prototype.restoreAdsStatus = function() {
    if (this.video) {
        this.video.setAdsStatus({
            status: this.options.ads,
            fwAdManager: this.fwAdManager,
            fwServer: this.fwServer,
            fwNetworkId: this.fwNetworkId,
            fwProfile: this.fwProfile,
            fwSiteSection: this.options.siteSection || this.options.freewheel || this.getSiteSection(),
        });
    }
};

VHS.api.Flash.prototype.render = function() {
    if (this.rendering || this.rendered) {
        return;
    }

    // set rendering flag since swf may take a while to load
    // we set rendered only when swf loads and gives us a callback
    // need this flag so we do not render again while loading
    this.rendering = true;

    if (this.element) {
        this.element.remove();
    }

    // only add loader if we know a render will be followed by a play (autoplay)
    if (this.options.autoplay) {
        this.addLoader();
    }

    this.renderElement();

    if (this.options.controls && !this.options.nativeControls) {
        this.renderControls();
    }
    this.registerListeners();
};

VHS.api.Flash.prototype.renderElement = function() {
    var id = 'video_' + new Date().getTime();
    var flashvars = {instance: this.instance};
    var self = this;
    var overrideDomReady = true;

    // create sub container that will be replaced by swfobject
    var subcontainer = $('<div></div>');
    subcontainer.attr('id',id);
    this.container.append(subcontainer);

    // save flash object id for use in destroy later
    this.objectId = id;

    if (this.options.muted) {
        flashvars.muted = true;
    }

    flashvars.live = this.options.live;
    flashvars.ads = this.options.ads;
    flashvars.id = this.options.id || '';
    flashvars.autoplay = this.options.autoplay;
    flashvars.env = this.options.env;
    flashvars.type = this.getPlayerType();
    flashvars.version = VHS._version;
    flashvars.hdSwitchSeek = this.options.flashHdSwitchSeek;
    flashvars.spacebarToggleEnabled = this.options.spacebarToggleEnabled;
    flashvars.loop = this.options.loop;

    if (flashvars.ads) {
        flashvars.mediaLocation = (this.options.live) ? this.options.src : null;
        flashvars.fwAdManager = this.fwAdManager;
        flashvars.fwServer = this.fwServer;
        flashvars.fwNetworkId = this.fwNetworkId;
        flashvars.fwProfile = this.fwProfile;
        flashvars.fwSiteSection = this.options.siteSection || this.options.freewheel || this.getSiteSection();
    }

    // conviva parameters
    flashvars.conviva = this.options.conviva;
    if (this.modules.conviva) {
        flashvars.CONVIVA_PLUGIN_URL = this.modules.conviva.FLASH_PLUGIN_URL;
        flashvars.CONVIVA_CUSTOMER_ID = this.modules.conviva.CUSTOMER_ID;
        flashvars.CONVIVA_SERVICE_URL = this.modules.conviva.SERVICE_URL;
    }

    // qos parameters
    flashvars.qos = this.options.qos;
    if (this.modules.qos) {
        flashvars.QOS_CONFIG_PATH = this.modules.qos.CONFIG_PATH;
        flashvars.QOS_SWF_PATH = this.modules.qos.SWF_PATH;
    }

    var flashparams = {
        allowFullScreen: true,
        allowScriptAccess: "always",
        wmode: "opaque",
        seamlessTabbing: false,
        swliveconnect: true,
        quality: "high",
        bgcolor: "#000000"
    };

    var flashattr = {
        id: id
    };

    var flashCreationCallback = function(e) {};

    if (this.startupSeek) {
        this.bindStartupSeekEvents();
    }

    if (this.options.autoplay) {
        this.on(VHS.api.events.RENDERED, function autoplayHandler() {
            self.logger.log('RENDERED RECEIVED. HAPPENS WHEN FLASH RETURNS VIDEO_READY');
            self.play();
            self.off(VHS.api.events.RENDERED, autoplayHandler);
        });
    }

    // force swfobject to think the dom is ready to deal with bug using requirejs
    swfobject.embedSWF(
        this.swf,
        id,
        '100%',
        '100%',
        "11.0",
        null,
        flashvars,
        flashparams,
        flashattr,
        flashCreationCallback,
        overrideDomReady
    );
};

VHS.api.Flash.prototype.externalInterface = function() {
    this.logger.log('ExternalInterface initialized');
    this.element = this.container.find('object');
    this.video = this.element[0];

    var self = this;
    var renderedVideoReady = function () {
        if (!self.rendered) {
            self.rendered = true;
            self.trigger(VHS.api.events.RENDERED);
        }
        self.off(VHS.api.events.VIDEO_READY, renderedVideoReady);
    };

    this.on(VHS.api.events.VIDEO_READY, renderedVideoReady);
    this.renderSource();

    // error condition: if we do NOT have a rendition just issue rendered immediately (VIDEO_READY won't trigger)
    if (!this.modules.renditions.getActive()) {
        renderedVideoReady();
    }
};

VHS.api.Flash.prototype.renderSource = function() {
    var renditionUrl, renditionBitrate, renditionObject;
    var options = this.options;
    var id = options.id;
    var name = options.name;
    var category = options.category;
    var hdInteraction = this.hdUserInteraction ? "true" : "false";

    if (options.src) {
        renditionUrl = this.options.src;
    } else if (options.source) {
        for (var type in options.source) {
            if (type === 'video/mp4') {
                renditionUrl = options.source[type];
            }
        }
    } else if (this._data && this._data.renditions) {
        id = this._data.id;
        name = this._data.headline;
        renditionObject = this.modules.renditions.getClosestRenditionObject(this._data.renditions, this.element.height(), this.enableHD, this.getType());
        if (renditionObject && renditionObject.url) {
            renditionUrl = renditionObject.url;
            renditionBitrate = renditionObject.bitrate;
        }
        if (this._data.section) {
            category = this._data.section.content;
        }
    } else {
        throw new Error('at least one rendition should be provided.');
    }

    if (renditionUrl) {
        this.modules.renditions.setActive(renditionUrl);
        this.video.loadPlayerData({ id: id, name: name, url: renditionUrl, type: 'video/mp4', duration: this.getDuration(), hdInteraction: hdInteraction, bitrate: renditionBitrate, category: category });
    } else {
        this.trigger(VHS.api.events.RENDITION_NOT_FOUND);
        this.modules.renditions.resetActive();
    }
};

/**
Register Listeners
@method registerListeners
**/
VHS.api.Flash.prototype.registerListeners = function() {
    this.on(VHS.api.events.BUFFERING, function() {
        this.addLoader();
    });

    this.on(VHS.api.events.BUFFER_FULL, function() {
        this.removeLoader();
    });
};

/**
duration
@method duration
**/
VHS.api.Flash.prototype.duration = function() {
    var element = this.element[0];
    return element.duration() || 0;
};

/**
Skip Ad
@method skipAd
**/
VHS.api.Flash.prototype.skipAd = function() {
    if (this.video) {
        this.video.skipAd();
    }
};

/**
StopAd video
@method stopAd
**/
VHS.api.Flash.prototype.stopAd = function() {
    if (this.video) {
        this.video.stopAd();
        this.trigger(VHS.api.events.AD_STOPPED);
    }
};

/**
Play video
@method play
**/
VHS.api.Flash.prototype.playAd = function() {
    if (this.video) {
        this.video.playAd();
    }
};

/**
PauseAd video
@method pauseAd
**/
VHS.api.Flash.prototype.pauseAd = function() {
    if (this.video) {
        this.video.pauseAd();
    }
};

/**
Stop video
@method stop
**/
VHS.api.Flash.prototype.stop = function() {
    if (this.video) {
        this.video.stopVideo();
    }
};

/**
Reload live video
@method reloadLiveVideo
**/
VHS.api.Flash.prototype.reloadLiveVideo = function() {
    var self = this;
    this.on(VHS.api.events.VIDEO_READY, function reloadLiveVideoReady() {
        self.logger.log('Reload LIVE Video VIDEO_READY (flash)');
        self.video.playVideo();
        self.off(VHS.api.events.VIDEO_READY, reloadLiveVideoReady);
    });

    this.renderSource();

    // reset ui to live - if endlist encountered then ui will get switched back to VOD
    if (this.modules && this.modules.controls) {
        this.modules.controls.configureLive();
    }
};

/**
Play video
@method play
**/
VHS.api.Flash.prototype.play = function() {
    var self = this;

    // only add loader for a first play and it was not added already because we are NOT autplaying
    if (this.firstPlay && !this.options.autoplay) {
        this.addLoader();
    }

    // player is rendered so safe to play
    var safePlay = function() {
        if (self.modules.renditions.getActive() && self.video) {

            // load_start must trigger before the first play, but after render
            if (self.firstPlay) {
                self.trigger(VHS.api.events.LOAD_START);
            }

            if (self.adPlaying()) {
                self.playAd();
            } else if (self.options.live && self.status === VHS.api.status.VIDEO_ENDED) {
                // live player and ended -- reload resource
                self.reloadLiveVideo();
            } else if (self.video.playVideo) {
                self.video.playVideo();
            }
        }
    };

    if (this.rendered) {
        safePlay();
    } else if (this.rendering) {
        // we are already rendering, need to wait
        // if not autoplay, queue to play when rendered
        if (this.options.autoplay || this.queuedPlayOnRendered) {
            return;
        }

        // set flag so we don't keep queuing
        this.queuedPlayOnRendered = true;
        this.on(VHS.api.events.RENDERED, function checkForQueuedPlay() {
            safePlay();
            self.off(VHS.api.events.RENDERED, checkForQueuedPlay);
            self.queuedPlayOnRendered = false;
        });
    } else {
        this.on(VHS.api.events.RENDERED, function checkForPlay() {
            safePlay();
            self.off(VHS.api.events.RENDERED, checkForPlay);
        });
        this.render();
    }
};

/**
Pause video
@method play
**/
VHS.api.Flash.prototype.pause = function() {
    if (this.rendered) {
        if (this.adPlaying()) {
            this.pauseAd();
        } else if (this.isContentPlaying()) {
            this.video.pauseVideo();
        } else {
            return;
        }

        this.status = VHS.api.status.VIDEO_PAUSED;
    }
};

/**
* Check if the video element is paused.
* Added to give API parity with HTML5 player.
* If the element is NOT there returns true to indicate video paused
*
* @method isPaused
* @return {Boolean} Returns true on paused
*/
VHS.api.Flash.prototype.isPaused = function() {
    return (this.video && this.rendered) ? this.video.isPaused() : true;
};

VHS.api.Flash.prototype.isContentPlaying = function() {
    return (this.video && this.rendered) ? this.video.isContentPlaying() : undefined;
};

VHS.api.Flash.prototype.adPlaying = function() {
    return (this.video && this.rendered) ? this.video.adPlaying() : undefined;
};

VHS.api.Flash.prototype.adCompleted = function() {
    return (this.video && this.rendered) ? this.video.adComplete() : undefined;
};

VHS.api.Flash.prototype.adDuration = function() {
    return (this.video && this.rendered) ? this.video.adDuration() : undefined;
};

VHS.api.Flash.prototype.adCurrentTime = function() {
    return (this.video && this.rendered) ? this.video.adCurrentTime() : undefined;
};

/**
Seek video
@method seek
@param {Number} current time in seconds
**/
VHS.api.Flash.prototype.seek = function(time) {
    if (typeof time !== 'number') {
        throw new Error('time argument should be a Number');
    }

    if (time < 0 || time > this.video.duration()) {
        throw new Error('time should be greater than 0 and lower than the duration of the video');
    }

    this.video.seek({seconds:time});
};

/**
Reload live video
@method reloadVideo
**/
VHS.api.Flash.prototype.reloadVideo = function() {
    var self = this;

    // wait for media to be ready and then play it
    this.on(VHS.api.events.VIDEO_READY, function reloadVideoReady() {
        self.logger.log('Reload Video VIDEO_READY (flash)');
        self.play();
        self.off(VHS.api.events.VIDEO_READY, reloadVideoReady);
    });

    this.renderSource();
    this.trigger(VHS.api.events.LOAD_START);
};

/**
Pause video
@method play
**/
VHS.api.Flash.prototype.mute = function(mute) {
    if (this.video) {
        if (!mute) {
            this.video.unmute();
        } else {
            this.video.mute();
        }
    }
};

/**
Unmute video
@method play
**/
VHS.api.Flash.prototype.unmute = function() {
    if (this.video) {
        this.video.unmute();
    }
};


/**
Toggle video volume
@method toggleVolume
**/
VHS.api.Flash.prototype.toggleVolume = function() {
    if (this.video) {
        this.mute(!this.video.isMuted());
    }
};

/**
* Check if the video element is muted.
* Added to give API parity with HTML5 player.
*
* @method isMuted
* @return {Boolean} Returns true on set
*/
VHS.api.Flash.prototype.isMuted = function() {
    return this.video ? this.video.isMuted() : undefined;
};

/**
* Route click events on the video element from
* flash to javascript.
*/
VHS.api.Flash.prototype.onElementClick = function() {
    this.togglePlay();
};

/**
 * Get current time
 */
VHS.api.Flash.prototype.getCurrentTime = function() {
    return this.video ? this.video.currentTime() : 0;
};

VHS.api.Flash.prototype.toggleHD = function (userInteractionEvt) {
    var currentTime = this.video.currentTime();
    var self = this;

    // wait for media to be ready and then play it
    this.on(VHS.api.events.VIDEO_READY, function toggleHDVideoReady() {
        self.logger.log('Flash HD Rendition Switch VIDEO_READY');
        self.play();
        self.off(VHS.api.events.VIDEO_READY, toggleHDVideoReady);
        self.seek(currentTime);
        self.hdRenditionChanging = false;
    });

    this.hdRenditionChanging = true;
    this.enableHD = !this.enableHD;
    this.hdUserInteraction = userInteractionEvt.type.match(/(click|touch)/ig) !== null;
    this.pause();
    this.renderSource();
    this.hdUserInteraction = false;
    this.triggerHDEvent();
};


window.vhs_instances = window.vhs_instances || {};
VHS.styleLoaded = false;

/**
 * findInstance Find the instance of VHS within window.vhs_instances given the container.
 * The contaniner can be the ID or the jQuery/Zepto object
 *
 * @param  {String|Object} container The ID (string) of the div, or the jQuery/Zepto object of the container
 * @return {Object|undefined} returns the vhs object if one is in use with that container or undefined if the container is not in use.
 */
VHS.findInstance = function (container) {
    var instanceContainer, containerId;

    if (container) {
        // get the pass container id
        if (typeof container === 'string') {
            containerId = container;
        } else if (typeof container === 'object' && typeof container.attr === 'function') {
            containerId = container.attr('id');
        }

        // validate we are NOT using container already
        if (containerId) {
            for (var i in window.vhs_instances) {
                if (window.vhs_instances.hasOwnProperty(i)) {
                    instanceContainer = window.vhs_instances[i].container;
                    if (instanceContainer && typeof instanceContainer === "object" && typeof instanceContainer.attr === 'function') {
                        if (instanceContainer.attr('id') === containerId) {
                            // already in use, return the player they are already using
                            return window.vhs_instances[i];
                        }
                    }
                }
            }
        }
    }
};


/**
@module VHS
@function player
**/
VHS.player = function(options){
    var player, vhsInstance;
    var dtTime = new Date().getTime();
    var instance = 'player_' + Math.round(Math.random() * dtTime);
    var util = VHS.util;

    // Setting mode (default flash)
    options.mode = options.mode || 'flash';

    // check instances to see if player already exists in container
    vhsInstance = VHS.findInstance(options.container);
    if (vhsInstance) {
        if (window.console && typeof window.console.error === 'function') {
            window.console.error('VHS ERROR: Container is already in use.  Please destroy before creating a new VHS instance using this container: ', options.container);
        }
        return vhsInstance;
    }

    // switch to HTML5 if
    // - html5 is supported
    // - and -
    // --- flash is not supported
    // -- or --
    // --- mode is set to 'html5'
    // -- or --
    // --- browser is Safari
    if (util.getSupportedType() && (!util.checkFlashSupport() || options.mode === 'html5' || util.isSafari())) {
        options.mode = 'html5';
        // There is a FW conflict with IE9 HTML5 when we use the source tag and ads are enabled.
        // For now we will just disable ads in that context.
        if (options.source && VHS.util.isIE9()) {
            options.ads = false;
        }
        player = new VHS.api.HtmlFive(options, instance);
    } else {
        options.mode = 'flash';
        player = new VHS.api.Flash(options, instance);
    }

    if (player) {
        window.vhs_instances[instance] = player;
        player.instanceId = instance;
    }

    return player;
};

/**
@module VHS
@function auto
**/
VHS.auto = function(){
    var figures = $('figure[data-nytd]');
    var i, len, options, container, figure, usage;

    if (figures.length > 0) {
        for (i = 0, len = figures.length; i < len; i++) {
            figure = figures.eq(i);
            options = figure.data('setup') || {};
            options.id = options.nytd || figure.data('nytd');
            options.container = figure;
            options.usage = 'figure_tag';
            VHS.player(options);
        }
    }
};

/**
@module VHS
@function shortcuts
**/
VHS.shortcuts = function() {
    if ($) {
        $(function(){
            VHS.auto();
        });
    }
};
VHS._version = "2.28.0"; VHS._release = "366"; VHS._build = "desktop"; VHS.shortcuts();
    return VHS;
}));
